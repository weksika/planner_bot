{
  "version": 3,
  "sources": ["../../valibot/dist/index.js", "../../better-promises/node_modules/.pnpm/error-kid@0.0.7/node_modules/error-kid/dist/index.js", "../../better-promises/src/errors/CancelledError.ts", "../../better-promises/src/errors/TimeoutError.ts", "../../better-promises/src/promises/resolve.ts", "../../better-promises/src/promises/AbortablePromise.ts", "../../better-promises/src/promises/ManualPromise.ts", "../../@telegram-apps/toolkit/src/casing/camelToKebab.ts", "../../@telegram-apps/toolkit/src/casing/camelToSnake.ts", "../../@telegram-apps/toolkit/src/casing/camelToSnakeObjKeys.ts", "../../@telegram-apps/toolkit/src/casing/snakeToCamel.ts", "../../@telegram-apps/toolkit/src/casing/snakeToCamelObjKeys.ts", "../../@telegram-apps/toolkit/src/casing/deepSnakeToCamelObjKeys.ts", "../../@telegram-apps/toolkit/src/casing/snakeToKebab.ts", "../../@telegram-apps/toolkit/src/storage/storage.ts", "../../@telegram-apps/toolkit/src/createCbCollector.ts", "../../@telegram-apps/toolkit/src/createLogger.ts", "../../node_modules/.pnpm/valibot@1.0.0-beta.14_typescript@5.8.2/node_modules/valibot/dist/index.js", "../../@telegram-apps/toolkit/dist/index.js", "../../@telegram-apps/transformers/src/camel-casing/conditionalSnakeKeys.ts", "../../@telegram-apps/transformers/src/camel-casing/createCamelCaseGen.ts", "../../@telegram-apps/transformers/src/camel-casing/createCamelCaseSchemaParserGen.ts", "../../@telegram-apps/transformers/src/transformers/jsonParse.ts", "../../@telegram-apps/transformers/src/camel-casing/createJsonCamelCaseGen.ts", "../../@telegram-apps/transformers/src/transformers/transformQueryUsing.ts", "../../@telegram-apps/transformers/src/camel-casing/createQueryCamelCaseGen.ts", "../../@telegram-apps/transformers/src/schemas/init-data.ts", "../../@telegram-apps/transformers/src/generators/init-data.ts", "../../@telegram-apps/transformers/src/validation/rgb.ts", "../../@telegram-apps/transformers/src/generators/themeParams.ts", "../../@telegram-apps/transformers/src/schemas/LaunchParamsSchema.ts", "../../@telegram-apps/transformers/src/generators/launchParamsQuery.ts", "../../@telegram-apps/transformers/src/parsers/parseInitDataQuery.ts", "../../@telegram-apps/transformers/src/parsers/parseLaunchParamsQuery.ts", "../../@telegram-apps/transformers/src/schemas/MiniAppsMessageSchema.ts", "../../@telegram-apps/transformers/src/serializers/serializeToQuery.ts", "../../@telegram-apps/transformers/src/serializers/serializeInitDataQuery.ts", "../../@telegram-apps/transformers/src/serializers/serializeLaunchParamsQuery.ts", "../../@telegram-apps/transformers/src/validation/isLaunchParamsQuery.ts", "../../mitt/src/index.ts", "../../@telegram-apps/signals/src/batch.ts", "../../@telegram-apps/signals/src/signal.ts", "../../@telegram-apps/signals/src/computed.ts", "../../error-kid/src/isErrorOfKind.ts", "../../error-kid/src/errorClass.ts", "../../error-kid/src/errorClassWithData.ts", "../../@telegram-apps/bridge/src/base64-url/encodeBase64Url.ts", "../../@telegram-apps/bridge/src/base64-url/decodeBase64Url.ts", "../../@telegram-apps/bridge/src/env/hasWebviewProxy.ts", "../../@telegram-apps/bridge/src/env/isIframe.ts", "../../@telegram-apps/bridge/src/events/createEmitter.ts", "../../@telegram-apps/bridge/src/events/emitEvent.ts", "../../@telegram-apps/bridge/src/debug.ts", "../../@telegram-apps/bridge/src/logger.ts", "../../@telegram-apps/bridge/src/helpers/defineWithAccessors.ts", "../../@telegram-apps/bridge/src/helpers/defineEnhanceableProperty.ts", "../../@telegram-apps/bridge/src/helpers/defineDefaultProperty.ts", "../../@telegram-apps/bridge/src/helpers/defineFnComposer.ts", "../../@telegram-apps/bridge/src/events/emitter.ts", "../../@telegram-apps/bridge/src/errors.ts", "../../@telegram-apps/bridge/src/methods/postMessage.ts", "../../@telegram-apps/bridge/src/methods/targetOrigin.ts", "../../@telegram-apps/bridge/src/methods/postEvent.ts", "../../@telegram-apps/bridge/src/utils/request.ts", "../../@telegram-apps/bridge/src/launch-params/retrieveRawLaunchParams.ts", "../../@telegram-apps/bridge/src/launch-params/retrieveLaunchParams.ts", "../../@telegram-apps/bridge/src/env/isTMA.ts", "../../@telegram-apps/bridge/src/env/mockTelegramEnv.ts", "../../@telegram-apps/bridge/src/launch-params/retrieveRawInitData.ts", "../../@telegram-apps/bridge/src/methods/captureSameReq.ts", "../../@telegram-apps/bridge/src/utils/compareVersions.ts", "../../@telegram-apps/bridge/src/methods/supports.ts", "../../@telegram-apps/bridge/src/methods/createPostEvent.ts", "../../@telegram-apps/bridge/src/start-param/createStartParam.ts", "../../@telegram-apps/bridge/src/start-param/decodeStartParam.ts", "../../@telegram-apps/bridge/src/start-param/isSafeToCreateStartParam.ts", "../../@telegram-apps/bridge/src/utils/invokeCustomMethod.ts", "../../@telegram-apps/bridge/src/applyPolyfills.ts", "../../@telegram-apps/bridge/src/resetPackageState.ts", "../../@telegram-apps/navigation/src/history/getFirstNavigationEntry.ts", "../../@telegram-apps/navigation/src/history/isPageReload.ts", "../../@telegram-apps/navigation/src/ensurePrefix.ts", "../../@telegram-apps/navigation/src/url/createSafeURL.ts", "../../@telegram-apps/navigation/src/url/urlToPath.ts", "../../@telegram-apps/navigation/src/errors.ts", "../../@telegram-apps/sdk/src/signals-registry.ts", "../../@telegram-apps/sdk/src/debug.ts", "../../@telegram-apps/sdk/src/logger.ts", "../../@telegram-apps/sdk/src/globals.ts", "../../@telegram-apps/sdk/src/scopes/createIsSupported.ts", "../../@telegram-apps/sdk/src/errors.ts", "../../@telegram-apps/sdk/src/utils/isSSR.ts", "../../@telegram-apps/sdk/src/scopes/wrappers/wrapSafe.ts", "../../@telegram-apps/sdk/src/scopes/wrappers/createWrapSafe.ts", "../../@telegram-apps/sdk/src/scopes/wrappers/createWrapComplete.ts", "../../@telegram-apps/sdk/src/scopes/wrappers/createWrapSupported.ts", "../../@telegram-apps/sdk/src/scopes/components/back-button/back-button.ts", "../../@telegram-apps/sdk/src/scopes/defineNonConcurrentFn.ts", "../../@telegram-apps/sdk/src/scopes/defineMountFn.ts", "../../@telegram-apps/sdk/src/scopes/components/biometry/signals.ts", "../../@telegram-apps/sdk/src/scopes/components/biometry/requestBiometry.ts", "../../@telegram-apps/sdk/src/utils/ignoreCanceled.ts", "../../@telegram-apps/sdk/src/scopes/signalCancel.ts", "../../@telegram-apps/sdk/src/scopes/components/biometry/methods.ts", "../../@telegram-apps/sdk/src/scopes/wrappers/createWrapMounted.ts", "../../@telegram-apps/sdk/src/scopes/wrappers/createWrapBasic.ts", "../../@telegram-apps/sdk/src/scopes/components/closing-behavior/closing-behavior.ts", "../../@telegram-apps/sdk/src/scopes/components/cloud-storage/cloud-storage.ts", "../../@telegram-apps/sdk/src/scopes/components/haptic-feedback/haptic-feedback.ts", "../../@telegram-apps/sdk/src/scopes/components/init-data/init-data.ts", "../../@telegram-apps/sdk/src/scopes/components/invoice/invoice.ts", "../../@telegram-apps/sdk/src/scopes/components/location-manager/location-manager.ts", "../../@telegram-apps/sdk/src/utils/removeUndefined.ts", "../../@telegram-apps/sdk/src/utils/isColorDark.ts", "../../@telegram-apps/sdk/src/scopes/components/theme-params/signals.ts", "../../@telegram-apps/sdk/src/scopes/components/main-button/signals.ts", "../../@telegram-apps/sdk/src/scopes/components/main-button/methods.ts", "../../@telegram-apps/sdk/src/utils/css-vars.ts", "../../@telegram-apps/sdk/src/scopes/components/theme-params/methods.ts", "../../@telegram-apps/sdk/src/scopes/components/mini-app/utils.ts", "../../@telegram-apps/sdk/src/scopes/components/mini-app/signals.ts", "../../@telegram-apps/sdk/src/scopes/components/mini-app/methods.ts", "../../@telegram-apps/sdk/src/scopes/components/popup/prepareParams.ts", "../../@telegram-apps/sdk/src/scopes/components/popup/popup.ts", "../../@telegram-apps/sdk/src/scopes/components/qr-scanner/qr-scanner.ts", "../../@telegram-apps/sdk/src/scopes/components/secondary-button/signals.ts", "../../@telegram-apps/sdk/src/scopes/components/secondary-button/methods.ts", "../../@telegram-apps/sdk/src/scopes/components/settings-button/settings-button.ts", "../../@telegram-apps/sdk/src/scopes/components/swipe-behavior/swipe-behavior.ts", "../../@telegram-apps/sdk/src/scopes/components/viewport/const.ts", "../../@telegram-apps/sdk/src/scopes/components/viewport/wrappers.ts", "../../@telegram-apps/sdk/src/scopes/components/viewport/signals.ts", "../../@telegram-apps/sdk/src/scopes/components/viewport/static.ts", "../../@telegram-apps/sdk/src/scopes/components/viewport/mounting.ts", "../../@telegram-apps/sdk/src/scopes/components/viewport/css-vars.ts", "../../@telegram-apps/sdk/src/scopes/components/viewport/expand.ts", "../../@telegram-apps/sdk/src/scopes/components/viewport/fullscreen.ts", "../../@telegram-apps/sdk/src/scopes/utilities/emoji-status/requestEmojiStatusAccess.ts", "../../@telegram-apps/sdk/src/scopes/utilities/emoji-status/setEmojiStatus.ts", "../../@telegram-apps/sdk/src/scopes/utilities/home-screen/add-to-home-screen-failed.ts", "../../@telegram-apps/sdk/src/scopes/utilities/home-screen/added-to-home-screen.ts", "../../@telegram-apps/sdk/src/scopes/utilities/home-screen/addToHomeScreen.ts", "../../@telegram-apps/sdk/src/scopes/utilities/home-screen/checkHomeScreenStatus.ts", "../../@telegram-apps/sdk/src/scopes/utilities/links/openLink.ts", "../../@telegram-apps/sdk/src/scopes/utilities/links/openTelegramLink.ts", "../../@telegram-apps/sdk/src/scopes/utilities/links/shareURL.ts", "../../@telegram-apps/sdk/src/utils/sleep.ts", "../../@telegram-apps/sdk/src/scopes/utilities/privacy/requestPhoneAccess.ts", "../../@telegram-apps/sdk/src/scopes/utilities/privacy/requestContact.ts", "../../@telegram-apps/sdk/src/scopes/utilities/privacy/requestWriteAccess.ts", "../../@telegram-apps/sdk/src/scopes/utilities/uncategorized/copyTextToClipboard.ts", "../../@telegram-apps/sdk/src/scopes/utilities/uncategorized/downloadFile.ts", "../../@telegram-apps/sdk/src/scopes/utilities/uncategorized/getCurrentTime.ts", "../../@telegram-apps/sdk/src/scopes/utilities/uncategorized/readTextFromClipboard.ts", "../../@telegram-apps/sdk/src/scopes/utilities/uncategorized/retrieveAndroidDeviceDataFrom.ts", "../../@telegram-apps/sdk/src/scopes/utilities/uncategorized/retrieveAndroidDeviceData.ts", "../../@telegram-apps/sdk/src/scopes/utilities/uncategorized/sendData.ts", "../../@telegram-apps/sdk/src/scopes/utilities/uncategorized/shareMessage.ts", "../../@telegram-apps/sdk/src/scopes/utilities/uncategorized/shareStory.ts", "../../@telegram-apps/sdk/src/scopes/utilities/uncategorized/switchInlineQuery.ts", "../../@telegram-apps/sdk/src/utils/safeCall.ts", "../../@telegram-apps/sdk/src/init.ts"],
  "sourcesContent": ["// src/storages/globalConfig/globalConfig.ts\nvar store;\nfunction setGlobalConfig(config2) {\n  store = { ...store, ...config2 };\n}\n// @__NO_SIDE_EFFECTS__\nfunction getGlobalConfig(config2) {\n  return {\n    lang: config2?.lang ?? store?.lang,\n    message: config2?.message,\n    abortEarly: config2?.abortEarly ?? store?.abortEarly,\n    abortPipeEarly: config2?.abortPipeEarly ?? store?.abortPipeEarly\n  };\n}\nfunction deleteGlobalConfig() {\n  store = void 0;\n}\n\n// src/storages/globalMessage/globalMessage.ts\nvar store2;\nfunction setGlobalMessage(message, lang) {\n  if (!store2) store2 = /* @__PURE__ */ new Map();\n  store2.set(lang, message);\n}\n// @__NO_SIDE_EFFECTS__\nfunction getGlobalMessage(lang) {\n  return store2?.get(lang);\n}\nfunction deleteGlobalMessage(lang) {\n  store2?.delete(lang);\n}\n\n// src/storages/schemaMessage/schemaMessage.ts\nvar store3;\nfunction setSchemaMessage(message, lang) {\n  if (!store3) store3 = /* @__PURE__ */ new Map();\n  store3.set(lang, message);\n}\n// @__NO_SIDE_EFFECTS__\nfunction getSchemaMessage(lang) {\n  return store3?.get(lang);\n}\nfunction deleteSchemaMessage(lang) {\n  store3?.delete(lang);\n}\n\n// src/storages/specificMessage/specificMessage.ts\nvar store4;\nfunction setSpecificMessage(reference, message, lang) {\n  if (!store4) store4 = /* @__PURE__ */ new Map();\n  if (!store4.get(reference)) store4.set(reference, /* @__PURE__ */ new Map());\n  store4.get(reference).set(lang, message);\n}\n// @__NO_SIDE_EFFECTS__\nfunction getSpecificMessage(reference, lang) {\n  return store4?.get(reference)?.get(lang);\n}\nfunction deleteSpecificMessage(reference, lang) {\n  store4?.get(reference)?.delete(lang);\n}\n\n// src/utils/_stringify/_stringify.ts\n// @__NO_SIDE_EFFECTS__\nfunction _stringify(input) {\n  const type = typeof input;\n  if (type === \"string\") {\n    return `\"${input}\"`;\n  }\n  if (type === \"number\" || type === \"bigint\" || type === \"boolean\") {\n    return `${input}`;\n  }\n  if (type === \"object\" || type === \"function\") {\n    return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? \"null\";\n  }\n  return type;\n}\n\n// src/utils/_addIssue/_addIssue.ts\nfunction _addIssue(context, label, dataset, config2, other) {\n  const input = other && \"input\" in other ? other.input : dataset.value;\n  const expected = other?.expected ?? context.expects ?? null;\n  const received = other?.received ?? _stringify(input);\n  const issue = {\n    kind: context.kind,\n    type: context.type,\n    input,\n    expected,\n    received,\n    message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : \"R\"}eceived ${received}`,\n    requirement: context.requirement,\n    path: other?.path,\n    issues: other?.issues,\n    lang: config2.lang,\n    abortEarly: config2.abortEarly,\n    abortPipeEarly: config2.abortPipeEarly\n  };\n  const isSchema = context.kind === \"schema\";\n  const message = other?.message ?? context.message ?? getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? getSchemaMessage(issue.lang) : null) ?? config2.message ?? getGlobalMessage(issue.lang);\n  if (message !== void 0) {\n    issue.message = typeof message === \"function\" ? (\n      // @ts-expect-error\n      message(issue)\n    ) : message;\n  }\n  if (isSchema) {\n    dataset.typed = false;\n  }\n  if (dataset.issues) {\n    dataset.issues.push(issue);\n  } else {\n    dataset.issues = [issue];\n  }\n}\n\n// src/utils/_getByteCount/_getByteCount.ts\nvar textEncoder;\n// @__NO_SIDE_EFFECTS__\nfunction _getByteCount(input) {\n  if (!textEncoder) {\n    textEncoder = new TextEncoder();\n  }\n  return textEncoder.encode(input).length;\n}\n\n// src/utils/_getGraphemeCount/_getGraphemeCount.ts\nvar segmenter;\n// @__NO_SIDE_EFFECTS__\nfunction _getGraphemeCount(input) {\n  if (!segmenter) {\n    segmenter = new Intl.Segmenter();\n  }\n  const segments = segmenter.segment(input);\n  let count = 0;\n  for (const _ of segments) {\n    count++;\n  }\n  return count;\n}\n\n// src/utils/_getStandardProps/_getStandardProps.ts\n// @__NO_SIDE_EFFECTS__\nfunction _getStandardProps(context) {\n  return {\n    version: 1,\n    vendor: \"valibot\",\n    validate(value2) {\n      return context[\"~run\"]({ value: value2 }, getGlobalConfig());\n    }\n  };\n}\n\n// src/utils/_getWordCount/_getWordCount.ts\nvar store5;\n// @__NO_SIDE_EFFECTS__\nfunction _getWordCount(locales, input) {\n  if (!store5) {\n    store5 = /* @__PURE__ */ new Map();\n  }\n  if (!store5.get(locales)) {\n    store5.set(locales, new Intl.Segmenter(locales, { granularity: \"word\" }));\n  }\n  const segments = store5.get(locales).segment(input);\n  let count = 0;\n  for (const segment of segments) {\n    if (segment.isWordLike) {\n      count++;\n    }\n  }\n  return count;\n}\n\n// src/utils/_isLuhnAlgo/_isLuhnAlgo.ts\nvar NON_DIGIT_REGEX = /\\D/gu;\n// @__NO_SIDE_EFFECTS__\nfunction _isLuhnAlgo(input) {\n  const number2 = input.replace(NON_DIGIT_REGEX, \"\");\n  let length2 = number2.length;\n  let bit = 1;\n  let sum = 0;\n  while (length2) {\n    const value2 = +number2[--length2];\n    bit ^= 1;\n    sum += bit ? [0, 2, 4, 6, 8, 1, 3, 5, 7, 9][value2] : value2;\n  }\n  return sum % 10 === 0;\n}\n\n// src/utils/_isValidObjectKey/_isValidObjectKey.ts\n// @__NO_SIDE_EFFECTS__\nfunction _isValidObjectKey(object2, key) {\n  return Object.hasOwn(object2, key) && key !== \"__proto__\" && key !== \"prototype\" && key !== \"constructor\";\n}\n\n// src/utils/_joinExpects/_joinExpects.ts\n// @__NO_SIDE_EFFECTS__\nfunction _joinExpects(values2, separator) {\n  const list = [...new Set(values2)];\n  if (list.length > 1) {\n    return `(${list.join(` ${separator} `)})`;\n  }\n  return list[0] ?? \"never\";\n}\n\n// src/utils/entriesFromList/entriesFromList.ts\n// @__NO_SIDE_EFFECTS__\nfunction entriesFromList(list, schema) {\n  const entries = {};\n  for (const key of list) {\n    entries[key] = schema;\n  }\n  return entries;\n}\n\n// src/utils/entriesFromObjects/entriesFromObjects.ts\n// @__NO_SIDE_EFFECTS__\nfunction entriesFromObjects(schemas) {\n  const entries = {};\n  for (const schema of schemas) {\n    Object.assign(entries, schema.entries);\n  }\n  return entries;\n}\n\n// src/utils/getDotPath/getDotPath.ts\n// @__NO_SIDE_EFFECTS__\nfunction getDotPath(issue) {\n  if (issue.path) {\n    let key = \"\";\n    for (const item of issue.path) {\n      if (typeof item.key === \"string\" || typeof item.key === \"number\") {\n        if (key) {\n          key += `.${item.key}`;\n        } else {\n          key += item.key;\n        }\n      } else {\n        return null;\n      }\n    }\n    return key;\n  }\n  return null;\n}\n\n// src/utils/isOfKind/isOfKind.ts\n// @__NO_SIDE_EFFECTS__\nfunction isOfKind(kind, object2) {\n  return object2.kind === kind;\n}\n\n// src/utils/isOfType/isOfType.ts\n// @__NO_SIDE_EFFECTS__\nfunction isOfType(type, object2) {\n  return object2.type === type;\n}\n\n// src/utils/isValiError/isValiError.ts\n// @__NO_SIDE_EFFECTS__\nfunction isValiError(error) {\n  return error instanceof ValiError;\n}\n\n// src/utils/ValiError/ValiError.ts\nvar ValiError = class extends Error {\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(issues) {\n    super(issues[0].message);\n    this.name = \"ValiError\";\n    this.issues = issues;\n  }\n};\n\n// src/actions/args/args.ts\n// @__NO_SIDE_EFFECTS__\nfunction args(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"args\",\n    reference: args,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = (...args_) => {\n        const argsDataset = this.schema[\"~run\"]({ value: args_ }, config2);\n        if (argsDataset.issues) {\n          throw new ValiError(argsDataset.issues);\n        }\n        return func(...argsDataset.value);\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/args/argsAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction argsAsync(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"args\",\n    reference: argsAsync,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = async (...args2) => {\n        const argsDataset = await schema[\"~run\"]({ value: args2 }, config2);\n        if (argsDataset.issues) {\n          throw new ValiError(argsDataset.issues);\n        }\n        return func(...argsDataset.value);\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/await/awaitAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction awaitAsync() {\n  return {\n    kind: \"transformation\",\n    type: \"await\",\n    reference: awaitAsync,\n    async: true,\n    async \"~run\"(dataset) {\n      dataset.value = await dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/regex.ts\nvar BASE64_REGEX = /^(?:[\\da-z+/]{4})*(?:[\\da-z+/]{2}==|[\\da-z+/]{3}=)?$/iu;\nvar BIC_REGEX = /^[A-Z]{6}(?!00)[\\dA-Z]{2}(?:[\\dA-Z]{3})?$/u;\nvar CUID2_REGEX = /^[a-z][\\da-z]*$/u;\nvar DECIMAL_REGEX = /^[+-]?(?:\\d*\\.)?\\d+$/u;\nvar DIGITS_REGEX = /^\\d+$/u;\nvar EMAIL_REGEX = /^[\\w+-]+(?:\\.[\\w+-]+)*@[\\da-z]+(?:[.-][\\da-z]+)*\\.[a-z]{2,}$/iu;\nvar EMOJI_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex, regexp/no-dupe-disjunctions -- false positives\n  /^(?:[\\u{1F1E6}-\\u{1F1FF}]{2}|\\u{1F3F4}[\\u{E0061}-\\u{E007A}]{2}[\\u{E0030}-\\u{E0039}\\u{E0061}-\\u{E007A}]{1,3}\\u{E007F}|(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation})(?:\\u200D(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation}))*)+$/u\n);\nvar HEXADECIMAL_REGEX = /^(?:0[hx])?[\\da-fA-F]+$/u;\nvar HEX_COLOR_REGEX = /^#(?:[\\da-fA-F]{3,4}|[\\da-fA-F]{6}|[\\da-fA-F]{8})$/u;\nvar IMEI_REGEX = /^\\d{15}$|^\\d{2}-\\d{6}-\\d{6}-\\d$/u;\nvar IPV4_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive\n  /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$/u\n);\nvar IPV6_REGEX = /^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar IP_REGEX = /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$|^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar ISO_DATE_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])$/u;\nvar ISO_DATE_TIME_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])[T ](?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_REGEX = /^(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_SECOND_REGEX = /^(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}$/u;\nvar ISO_TIMESTAMP_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])[T ](?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}(?:\\.\\d{1,9})?(?:Z|[+-](?:0\\d|1\\d|2[0-3])(?::?[0-5]\\d)?)$/u;\nvar ISO_WEEK_REGEX = /^\\d{4}-W(?:0[1-9]|[1-4]\\d|5[0-3])$/u;\nvar MAC48_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$/iu;\nvar MAC64_REGEX = /^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar MAC_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$|^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar NANO_ID_REGEX = /^[\\w-]+$/u;\nvar OCTAL_REGEX = /^(?:0o)?[0-7]+$/u;\nvar RFC_EMAIL_REGEX = (\n  // eslint-disable-next-line regexp/prefer-w, no-useless-escape, regexp/no-useless-escape, regexp/require-unicode-regexp\n  /^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/\n);\nvar SLUG_REGEX = /^[\\da-z]+(?:[-_][\\da-z]+)*$/u;\nvar ULID_REGEX = /^[\\da-hjkmnp-tv-zA-HJKMNP-TV-Z]{26}$/u;\nvar UUID_REGEX = /^[\\da-f]{8}(?:-[\\da-f]{4}){3}-[\\da-f]{12}$/iu;\n\n// src/actions/base64/base64.ts\n// @__NO_SIDE_EFFECTS__\nfunction base64(message) {\n  return {\n    kind: \"validation\",\n    type: \"base64\",\n    reference: base64,\n    async: false,\n    expects: null,\n    requirement: BASE64_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Base64\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/bic/bic.ts\n// @__NO_SIDE_EFFECTS__\nfunction bic(message) {\n  return {\n    kind: \"validation\",\n    type: \"bic\",\n    reference: bic,\n    async: false,\n    expects: null,\n    requirement: BIC_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"BIC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/brand/brand.ts\n// @__NO_SIDE_EFFECTS__\nfunction brand(name) {\n  return {\n    kind: \"transformation\",\n    type: \"brand\",\n    reference: brand,\n    async: false,\n    name,\n    \"~run\"(dataset) {\n      return dataset;\n    }\n  };\n}\n\n// src/actions/bytes/bytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction bytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"bytes\",\n    reference: bytes,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 !== this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/check/check.ts\n// @__NO_SIDE_EFFECTS__\nfunction check(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: check,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/check/checkAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction checkAsync(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: checkAsync,\n    async: true,\n    expects: null,\n    requirement,\n    message,\n    async \"~run\"(dataset, config2) {\n      if (dataset.typed && !await this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/checkItems/checkItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction checkItems(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check_items\",\n    reference: checkItems,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        for (let index = 0; index < dataset.value.length; index++) {\n          const item = dataset.value[index];\n          if (!this.requirement(item, index, dataset.value)) {\n            _addIssue(this, \"item\", dataset, config2, {\n              input: item,\n              path: [\n                {\n                  type: \"array\",\n                  origin: \"value\",\n                  input: dataset.value,\n                  key: index,\n                  value: item\n                }\n              ]\n            });\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/checkItems/checkItemsAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction checkItemsAsync(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check_items\",\n    reference: checkItemsAsync,\n    async: true,\n    expects: null,\n    requirement,\n    message,\n    async \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const requirementResults = await Promise.all(\n          dataset.value.map(this.requirement)\n        );\n        for (let index = 0; index < dataset.value.length; index++) {\n          if (!requirementResults[index]) {\n            const item = dataset.value[index];\n            _addIssue(this, \"item\", dataset, config2, {\n              input: item,\n              path: [\n                {\n                  type: \"array\",\n                  origin: \"value\",\n                  input: dataset.value,\n                  key: index,\n                  value: item\n                }\n              ]\n            });\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/creditCard/creditCard.ts\nvar CREDIT_CARD_REGEX = /^(?:\\d{14,19}|\\d{4}(?: \\d{3,6}){2,4}|\\d{4}(?:-\\d{3,6}){2,4})$/u;\nvar SANITIZE_REGEX = /[- ]/gu;\nvar PROVIDER_REGEX_LIST = [\n  // American Express\n  /^3[47]\\d{13}$/u,\n  // Diners Club\n  /^3(?:0[0-5]|[68]\\d)\\d{11,13}$/u,\n  // Discover\n  /^6(?:011|5\\d{2})\\d{12,15}$/u,\n  // JCB\n  /^(?:2131|1800|35\\d{3})\\d{11}$/u,\n  // Mastercard\n  // eslint-disable-next-line redos-detector/no-unsafe-regex\n  /^5[1-5]\\d{2}|(?:222\\d|22[3-9]\\d|2[3-6]\\d{2}|27[01]\\d|2720)\\d{12}$/u,\n  // UnionPay\n  /^(?:6[27]\\d{14,17}|81\\d{14,17})$/u,\n  // Visa\n  /^4\\d{12}(?:\\d{3,6})?$/u\n];\n// @__NO_SIDE_EFFECTS__\nfunction creditCard(message) {\n  return {\n    kind: \"validation\",\n    type: \"credit_card\",\n    reference: creditCard,\n    async: false,\n    expects: null,\n    requirement(input) {\n      let sanitized;\n      return CREDIT_CARD_REGEX.test(input) && // Remove any hyphens and blanks\n      (sanitized = input.replace(SANITIZE_REGEX, \"\")) && // Check if it matches a provider\n      PROVIDER_REGEX_LIST.some((regex2) => regex2.test(sanitized)) && // Check if passes luhn algorithm\n      _isLuhnAlgo(sanitized);\n    },\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"credit card\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/cuid2/cuid2.ts\n// @__NO_SIDE_EFFECTS__\nfunction cuid2(message) {\n  return {\n    kind: \"validation\",\n    type: \"cuid2\",\n    reference: cuid2,\n    async: false,\n    expects: null,\n    requirement: CUID2_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Cuid2\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/decimal/decimal.ts\n// @__NO_SIDE_EFFECTS__\nfunction decimal(message) {\n  return {\n    kind: \"validation\",\n    type: \"decimal\",\n    reference: decimal,\n    async: false,\n    expects: null,\n    requirement: DECIMAL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"decimal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/description/description.ts\n// @__NO_SIDE_EFFECTS__\nfunction description(description_) {\n  return {\n    kind: \"metadata\",\n    type: \"description\",\n    reference: description,\n    description: description_\n  };\n}\n\n// src/actions/digits/digits.ts\n// @__NO_SIDE_EFFECTS__\nfunction digits(message) {\n  return {\n    kind: \"validation\",\n    type: \"digits\",\n    reference: digits,\n    async: false,\n    expects: null,\n    requirement: DIGITS_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"digits\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/email/email.ts\n// @__NO_SIDE_EFFECTS__\nfunction email(message) {\n  return {\n    kind: \"validation\",\n    type: \"email\",\n    reference: email,\n    expects: null,\n    async: false,\n    requirement: EMAIL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"email\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/emoji/emoji.ts\n// @__NO_SIDE_EFFECTS__\nfunction emoji(message) {\n  return {\n    kind: \"validation\",\n    type: \"emoji\",\n    reference: emoji,\n    async: false,\n    expects: null,\n    requirement: EMOJI_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"emoji\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/empty/empty.ts\n// @__NO_SIDE_EFFECTS__\nfunction empty(message) {\n  return {\n    kind: \"validation\",\n    type: \"empty\",\n    reference: empty,\n    async: false,\n    expects: \"0\",\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length > 0) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/endsWith/endsWith.ts\n// @__NO_SIDE_EFFECTS__\nfunction endsWith(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"ends_with\",\n    reference: endsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.endsWith(this.requirement)) {\n        _addIssue(this, \"end\", dataset, config2, {\n          received: `\"${dataset.value.slice(-this.requirement.length)}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/everyItem/everyItem.ts\n// @__NO_SIDE_EFFECTS__\nfunction everyItem(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"every_item\",\n    reference: everyItem,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.every(this.requirement)) {\n        _addIssue(this, \"item\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/excludes/excludes.ts\n// @__NO_SIDE_EFFECTS__\nfunction excludes(requirement, message) {\n  const received = _stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"excludes\",\n    reference: excludes,\n    async: false,\n    expects: `!${received}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.includes(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2, { received });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/filterItems/filterItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction filterItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"filter_items\",\n    reference: filterItems,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.filter(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/findItem/findItem.ts\n// @__NO_SIDE_EFFECTS__\nfunction findItem(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"find_item\",\n    reference: findItem,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.find(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/finite/finite.ts\n// @__NO_SIDE_EFFECTS__\nfunction finite(message) {\n  return {\n    kind: \"validation\",\n    type: \"finite\",\n    reference: finite,\n    async: false,\n    expects: null,\n    requirement: Number.isFinite,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"finite\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/graphemes/graphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction graphemes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"graphemes\",\n    reference: graphemes,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count !== this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/gtValue/gtValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction gtValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"gt_value\",\n    reference: gtValue,\n    async: false,\n    expects: `>${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(dataset.value > this.requirement)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hash/hash.ts\nvar HASH_LENGTHS = {\n  md4: 32,\n  md5: 32,\n  sha1: 40,\n  sha256: 64,\n  sha384: 96,\n  sha512: 128,\n  ripemd128: 32,\n  ripemd160: 40,\n  tiger128: 32,\n  tiger160: 40,\n  tiger192: 48,\n  crc32: 8,\n  crc32b: 8,\n  adler32: 8\n};\n// @__NO_SIDE_EFFECTS__\nfunction hash(types, message) {\n  return {\n    kind: \"validation\",\n    type: \"hash\",\n    reference: hash,\n    expects: null,\n    async: false,\n    requirement: RegExp(\n      types.map((type) => `^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join(\"|\"),\n      \"iu\"\n    ),\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hash\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hexadecimal/hexadecimal.ts\n// @__NO_SIDE_EFFECTS__\nfunction hexadecimal(message) {\n  return {\n    kind: \"validation\",\n    type: \"hexadecimal\",\n    reference: hexadecimal,\n    async: false,\n    expects: null,\n    requirement: HEXADECIMAL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hexadecimal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hexColor/hexColor.ts\n// @__NO_SIDE_EFFECTS__\nfunction hexColor(message) {\n  return {\n    kind: \"validation\",\n    type: \"hex_color\",\n    reference: hexColor,\n    async: false,\n    expects: null,\n    requirement: HEX_COLOR_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hex color\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/imei/imei.ts\n// @__NO_SIDE_EFFECTS__\nfunction imei(message) {\n  return {\n    kind: \"validation\",\n    type: \"imei\",\n    reference: imei,\n    async: false,\n    expects: null,\n    requirement(input) {\n      return IMEI_REGEX.test(input) && _isLuhnAlgo(input);\n    },\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"IMEI\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/includes/includes.ts\n// @__NO_SIDE_EFFECTS__\nfunction includes(requirement, message) {\n  const expects = _stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"includes\",\n    reference: includes,\n    async: false,\n    expects,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.includes(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2, {\n          received: `!${expects}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/integer/integer.ts\n// @__NO_SIDE_EFFECTS__\nfunction integer(message) {\n  return {\n    kind: \"validation\",\n    type: \"integer\",\n    reference: integer,\n    async: false,\n    expects: null,\n    requirement: Number.isInteger,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"integer\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ip/ip.ts\n// @__NO_SIDE_EFFECTS__\nfunction ip(message) {\n  return {\n    kind: \"validation\",\n    type: \"ip\",\n    reference: ip,\n    async: false,\n    expects: null,\n    requirement: IP_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IP\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ipv4/ipv4.ts\n// @__NO_SIDE_EFFECTS__\nfunction ipv4(message) {\n  return {\n    kind: \"validation\",\n    type: \"ipv4\",\n    reference: ipv4,\n    async: false,\n    expects: null,\n    requirement: IPV4_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IPv4\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ipv6/ipv6.ts\n// @__NO_SIDE_EFFECTS__\nfunction ipv6(message) {\n  return {\n    kind: \"validation\",\n    type: \"ipv6\",\n    reference: ipv6,\n    async: false,\n    expects: null,\n    requirement: IPV6_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IPv6\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoDate/isoDate.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoDate(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date\",\n    reference: isoDate,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"date\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoDateTime/isoDateTime.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoDateTime(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date_time\",\n    reference: isoDateTime,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_TIME_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"date-time\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTime/isoTime.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoTime(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time\",\n    reference: isoTime,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"time\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTimeSecond/isoTimeSecond.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoTimeSecond(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time_second\",\n    reference: isoTimeSecond,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_SECOND_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"time-second\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTimestamp/isoTimestamp.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoTimestamp(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_timestamp\",\n    reference: isoTimestamp,\n    async: false,\n    expects: null,\n    requirement: ISO_TIMESTAMP_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"timestamp\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoWeek/isoWeek.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoWeek(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_week\",\n    reference: isoWeek,\n    async: false,\n    expects: null,\n    requirement: ISO_WEEK_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"week\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/length/length.ts\n// @__NO_SIDE_EFFECTS__\nfunction length(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"length\",\n    reference: length,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length !== this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ltValue/ltValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction ltValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"lt_value\",\n    reference: ltValue,\n    async: false,\n    expects: `<${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(dataset.value < this.requirement)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac/mac.ts\n// @__NO_SIDE_EFFECTS__\nfunction mac(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac\",\n    reference: mac,\n    async: false,\n    expects: null,\n    requirement: MAC_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac48/mac48.ts\n// @__NO_SIDE_EFFECTS__\nfunction mac48(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac48\",\n    reference: mac48,\n    async: false,\n    expects: null,\n    requirement: MAC48_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"48-bit MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac64/mac64.ts\n// @__NO_SIDE_EFFECTS__\nfunction mac64(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac64\",\n    reference: mac64,\n    async: false,\n    expects: null,\n    requirement: MAC64_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"64-bit MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mapItems/mapItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction mapItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"map_items\",\n    reference: mapItems,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.map(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxBytes/maxBytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_bytes\",\n    reference: maxBytes,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 > this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxGraphemes/maxGraphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxGraphemes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_graphemes\",\n    reference: maxGraphemes,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count > this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxLength/maxLength.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_length\",\n    reference: maxLength,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length > this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxSize/maxSize.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_size\",\n    reference: maxSize,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size > this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxValue/maxValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_value\",\n    reference: maxValue,\n    async: false,\n    expects: `<=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(dataset.value <= this.requirement)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxWords/maxWords.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxWords(locales, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_words\",\n    reference: maxWords,\n    async: false,\n    expects: `<=${requirement}`,\n    locales,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count > this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/metadata/metadata.ts\n// @__NO_SIDE_EFFECTS__\nfunction metadata(metadata_) {\n  return {\n    kind: \"metadata\",\n    type: \"metadata\",\n    reference: metadata,\n    metadata: metadata_\n  };\n}\n\n// src/actions/mimeType/mimeType.ts\n// @__NO_SIDE_EFFECTS__\nfunction mimeType(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"mime_type\",\n    reference: mimeType,\n    async: false,\n    expects: _joinExpects(\n      requirement.map((option) => `\"${option}\"`),\n      \"|\"\n    ),\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.includes(dataset.value.type)) {\n        _addIssue(this, \"MIME type\", dataset, config2, {\n          received: `\"${dataset.value.type}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minBytes/minBytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction minBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_bytes\",\n    reference: minBytes,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 < this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minGraphemes/minGraphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction minGraphemes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_graphemes\",\n    reference: minGraphemes,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count < this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minLength/minLength.ts\n// @__NO_SIDE_EFFECTS__\nfunction minLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_length\",\n    reference: minLength,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length < this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minSize/minSize.ts\n// @__NO_SIDE_EFFECTS__\nfunction minSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_size\",\n    reference: minSize,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size < this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minValue/minValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction minValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_value\",\n    reference: minValue,\n    async: false,\n    expects: `>=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(dataset.value >= this.requirement)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minWords/minWords.ts\n// @__NO_SIDE_EFFECTS__\nfunction minWords(locales, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_words\",\n    reference: minWords,\n    async: false,\n    expects: `>=${requirement}`,\n    locales,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count < this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/multipleOf/multipleOf.ts\n// @__NO_SIDE_EFFECTS__\nfunction multipleOf(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"multiple_of\",\n    reference: multipleOf,\n    async: false,\n    expects: `%${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value % this.requirement !== 0) {\n        _addIssue(this, \"multiple\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/nanoid/nanoid.ts\n// @__NO_SIDE_EFFECTS__\nfunction nanoid(message) {\n  return {\n    kind: \"validation\",\n    type: \"nanoid\",\n    reference: nanoid,\n    async: false,\n    expects: null,\n    requirement: NANO_ID_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Nano ID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/nonEmpty/nonEmpty.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonEmpty(message) {\n  return {\n    kind: \"validation\",\n    type: \"non_empty\",\n    reference: nonEmpty,\n    async: false,\n    expects: \"!0\",\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length === 0) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: \"0\"\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/normalize/normalize.ts\n// @__NO_SIDE_EFFECTS__\nfunction normalize(form) {\n  return {\n    kind: \"transformation\",\n    type: \"normalize\",\n    reference: normalize,\n    async: false,\n    form,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.normalize(this.form);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notBytes/notBytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction notBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_bytes\",\n    reference: notBytes,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 === this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notGraphemes/notGraphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction notGraphemes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_graphemes\",\n    reference: notGraphemes,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count === this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notLength/notLength.ts\n// @__NO_SIDE_EFFECTS__\nfunction notLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_length\",\n    reference: notLength,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length === this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notSize/notSize.ts\n// @__NO_SIDE_EFFECTS__\nfunction notSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_size\",\n    reference: notSize,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size === this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notValue/notValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction notValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_value\",\n    reference: notValue,\n    async: false,\n    expects: requirement instanceof Date ? `!${requirement.toJSON()}` : `!${_stringify(requirement)}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notValues/notValues.ts\n// @__NO_SIDE_EFFECTS__\nfunction notValues(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_values\",\n    reference: notValues,\n    async: false,\n    expects: `!${_joinExpects(\n      requirement.map(\n        (value2) => value2 instanceof Date ? value2.toJSON() : _stringify(value2)\n      ),\n      \"|\"\n    )}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && this.requirement.some(\n        (value2) => value2 <= dataset.value && value2 >= dataset.value\n      )) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notWords/notWords.ts\n// @__NO_SIDE_EFFECTS__\nfunction notWords(locales, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_words\",\n    reference: notWords,\n    async: false,\n    expects: `!${requirement}`,\n    locales,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count === this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/octal/octal.ts\n// @__NO_SIDE_EFFECTS__\nfunction octal(message) {\n  return {\n    kind: \"validation\",\n    type: \"octal\",\n    reference: octal,\n    async: false,\n    expects: null,\n    requirement: OCTAL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"octal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/partialCheck/utils/_isPartiallyTyped/_isPartiallyTyped.ts\n// @__NO_SIDE_EFFECTS__\nfunction _isPartiallyTyped(dataset, paths) {\n  if (dataset.issues) {\n    for (const path of paths) {\n      for (const issue of dataset.issues) {\n        let typed = false;\n        const bound = Math.min(path.length, issue.path?.length ?? 0);\n        for (let index = 0; index < bound; index++) {\n          if (\n            // @ts-expect-error\n            path[index] !== issue.path[index].key && // @ts-expect-error\n            (path[index] !== \"$\" || issue.path[index].type !== \"array\")\n          ) {\n            typed = true;\n            break;\n          }\n        }\n        if (!typed) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\n// src/actions/partialCheck/partialCheck.ts\n// @__NO_SIDE_EFFECTS__\nfunction partialCheck(paths, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"partial_check\",\n    reference: partialCheck,\n    async: false,\n    expects: null,\n    paths,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if ((dataset.typed || _isPartiallyTyped(dataset, paths)) && // @ts-expect-error\n      !this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/partialCheck/partialCheckAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction partialCheckAsync(paths, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"partial_check\",\n    reference: partialCheckAsync,\n    async: true,\n    expects: null,\n    paths,\n    requirement,\n    message,\n    async \"~run\"(dataset, config2) {\n      if ((dataset.typed || _isPartiallyTyped(dataset, paths)) && // @ts-expect-error\n      !await this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawCheck/rawCheck.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawCheck(action) {\n  return {\n    kind: \"validation\",\n    type: \"raw_check\",\n    reference: rawCheck,\n    async: false,\n    expects: null,\n    \"~run\"(dataset, config2) {\n      action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info)\n      });\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawCheck/rawCheckAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawCheckAsync(action) {\n  return {\n    kind: \"validation\",\n    type: \"raw_check\",\n    reference: rawCheckAsync,\n    async: true,\n    expects: null,\n    async \"~run\"(dataset, config2) {\n      await action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info)\n      });\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawTransform/rawTransform.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawTransform(action) {\n  return {\n    kind: \"transformation\",\n    type: \"raw_transform\",\n    reference: rawTransform,\n    async: false,\n    \"~run\"(dataset, config2) {\n      const output = action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info),\n        NEVER: null\n      });\n      if (dataset.issues) {\n        dataset.typed = false;\n      } else {\n        dataset.value = output;\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawTransform/rawTransformAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawTransformAsync(action) {\n  return {\n    kind: \"transformation\",\n    type: \"raw_transform\",\n    reference: rawTransformAsync,\n    async: true,\n    async \"~run\"(dataset, config2) {\n      const output = await action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info),\n        NEVER: null\n      });\n      if (dataset.issues) {\n        dataset.typed = false;\n      } else {\n        dataset.value = output;\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/readonly/readonly.ts\n// @__NO_SIDE_EFFECTS__\nfunction readonly() {\n  return {\n    kind: \"transformation\",\n    type: \"readonly\",\n    reference: readonly,\n    async: false,\n    \"~run\"(dataset) {\n      return dataset;\n    }\n  };\n}\n\n// src/actions/reduceItems/reduceItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction reduceItems(operation, initial) {\n  return {\n    kind: \"transformation\",\n    type: \"reduce_items\",\n    reference: reduceItems,\n    async: false,\n    operation,\n    initial,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.reduce(this.operation, this.initial);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/regex/regex.ts\n// @__NO_SIDE_EFFECTS__\nfunction regex(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"regex\",\n    reference: regex,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"format\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/returns/returns.ts\n// @__NO_SIDE_EFFECTS__\nfunction returns(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"returns\",\n    reference: returns,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = (...args_) => {\n        const returnsDataset = this.schema[\"~run\"](\n          { value: func(...args_) },\n          config2\n        );\n        if (returnsDataset.issues) {\n          throw new ValiError(returnsDataset.issues);\n        }\n        return returnsDataset.value;\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/returns/returnsAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction returnsAsync(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"returns\",\n    reference: returnsAsync,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = async (...args_) => {\n        const returnsDataset = await this.schema[\"~run\"](\n          { value: await func(...args_) },\n          config2\n        );\n        if (returnsDataset.issues) {\n          throw new ValiError(returnsDataset.issues);\n        }\n        return returnsDataset.value;\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rfcEmail/rfcEmail.ts\n// @__NO_SIDE_EFFECTS__\nfunction rfcEmail(message) {\n  return {\n    kind: \"validation\",\n    type: \"rfc_email\",\n    reference: rfcEmail,\n    expects: null,\n    async: false,\n    requirement: RFC_EMAIL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"email\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/safeInteger/safeInteger.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeInteger(message) {\n  return {\n    kind: \"validation\",\n    type: \"safe_integer\",\n    reference: safeInteger,\n    async: false,\n    expects: null,\n    requirement: Number.isSafeInteger,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"safe integer\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/size/size.ts\n// @__NO_SIDE_EFFECTS__\nfunction size(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"size\",\n    reference: size,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size !== this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/slug/slug.ts\n// @__NO_SIDE_EFFECTS__\nfunction slug(message) {\n  return {\n    kind: \"validation\",\n    type: \"slug\",\n    reference: slug,\n    async: false,\n    expects: null,\n    requirement: SLUG_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"slug\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/someItem/someItem.ts\n// @__NO_SIDE_EFFECTS__\nfunction someItem(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"some_item\",\n    reference: someItem,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.some(this.requirement)) {\n        _addIssue(this, \"item\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/sortItems/sortItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction sortItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"sort_items\",\n    reference: sortItems,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.sort(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/startsWith/startsWith.ts\n// @__NO_SIDE_EFFECTS__\nfunction startsWith(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"starts_with\",\n    reference: startsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.startsWith(this.requirement)) {\n        _addIssue(this, \"start\", dataset, config2, {\n          received: `\"${dataset.value.slice(0, this.requirement.length)}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/title/title.ts\n// @__NO_SIDE_EFFECTS__\nfunction title(title_) {\n  return {\n    kind: \"metadata\",\n    type: \"title\",\n    reference: title,\n    title: title_\n  };\n}\n\n// src/actions/toLowerCase/toLowerCase.ts\n// @__NO_SIDE_EFFECTS__\nfunction toLowerCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_lower_case\",\n    reference: toLowerCase,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.toLowerCase();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toMaxValue/toMaxValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction toMaxValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_max_value\",\n    reference: toMaxValue,\n    async: false,\n    requirement,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toMinValue/toMinValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction toMinValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_min_value\",\n    reference: toMinValue,\n    async: false,\n    requirement,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toUpperCase/toUpperCase.ts\n// @__NO_SIDE_EFFECTS__\nfunction toUpperCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_upper_case\",\n    reference: toUpperCase,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.toUpperCase();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/transform/transform.ts\n// @__NO_SIDE_EFFECTS__\nfunction transform(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transform,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = this.operation(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/transform/transformAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction transformAsync(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transformAsync,\n    async: true,\n    operation,\n    async \"~run\"(dataset) {\n      dataset.value = await this.operation(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trim/trim.ts\n// @__NO_SIDE_EFFECTS__\nfunction trim() {\n  return {\n    kind: \"transformation\",\n    type: \"trim\",\n    reference: trim,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.trim();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trimEnd/trimEnd.ts\n// @__NO_SIDE_EFFECTS__\nfunction trimEnd() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_end\",\n    reference: trimEnd,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.trimEnd();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trimStart/trimStart.ts\n// @__NO_SIDE_EFFECTS__\nfunction trimStart() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_start\",\n    reference: trimStart,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.trimStart();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ulid/ulid.ts\n// @__NO_SIDE_EFFECTS__\nfunction ulid(message) {\n  return {\n    kind: \"validation\",\n    type: \"ulid\",\n    reference: ulid,\n    async: false,\n    expects: null,\n    requirement: ULID_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"ULID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/url/url.ts\n// @__NO_SIDE_EFFECTS__\nfunction url(message) {\n  return {\n    kind: \"validation\",\n    type: \"url\",\n    reference: url,\n    async: false,\n    expects: null,\n    requirement(input) {\n      try {\n        new URL(input);\n        return true;\n      } catch {\n        return false;\n      }\n    },\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"URL\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/uuid/uuid.ts\n// @__NO_SIDE_EFFECTS__\nfunction uuid(message) {\n  return {\n    kind: \"validation\",\n    type: \"uuid\",\n    reference: uuid,\n    async: false,\n    expects: null,\n    requirement: UUID_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"UUID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/value/value.ts\n// @__NO_SIDE_EFFECTS__\nfunction value(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"value\",\n    reference: value,\n    async: false,\n    expects: requirement instanceof Date ? requirement.toJSON() : _stringify(requirement),\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/values/values.ts\n// @__NO_SIDE_EFFECTS__\nfunction values(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"values\",\n    reference: values,\n    async: false,\n    expects: `${_joinExpects(\n      requirement.map(\n        (value2) => value2 instanceof Date ? value2.toJSON() : _stringify(value2)\n      ),\n      \"|\"\n    )}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.some(\n        (value2) => value2 <= dataset.value && value2 >= dataset.value\n      )) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/words/words.ts\n// @__NO_SIDE_EFFECTS__\nfunction words(locales, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"words\",\n    reference: words,\n    async: false,\n    expects: `${requirement}`,\n    locales,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count !== this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/assert/assert.ts\nfunction assert(schema, input) {\n  const issues = schema[\"~run\"]({ value: input }, { abortEarly: true }).issues;\n  if (issues) {\n    throw new ValiError(issues);\n  }\n}\n\n// src/methods/config/config.ts\n// @__NO_SIDE_EFFECTS__\nfunction config(schema, config2) {\n  return {\n    ...schema,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config_) {\n      return schema[\"~run\"](dataset, { ...config_, ...config2 });\n    }\n  };\n}\n\n// src/methods/getFallback/getFallback.ts\n// @__NO_SIDE_EFFECTS__\nfunction getFallback(schema, dataset, config2) {\n  return typeof schema.fallback === \"function\" ? (\n    // @ts-expect-error\n    schema.fallback(dataset, config2)\n  ) : (\n    // @ts-expect-error\n    schema.fallback\n  );\n}\n\n// src/methods/fallback/fallback.ts\n// @__NO_SIDE_EFFECTS__\nfunction fallback(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const outputDataset = schema[\"~run\"](dataset, config2);\n      return outputDataset.issues ? { typed: true, value: getFallback(this, outputDataset, config2) } : outputDataset;\n    }\n  };\n}\n\n// src/methods/fallback/fallbackAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction fallbackAsync(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    async: true,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const outputDataset = await schema[\"~run\"](dataset, config2);\n      return outputDataset.issues ? {\n        typed: true,\n        value: await getFallback(this, outputDataset, config2)\n      } : outputDataset;\n    }\n  };\n}\n\n// src/methods/flatten/flatten.ts\n// @__NO_SIDE_EFFECTS__\nfunction flatten(issues) {\n  const flatErrors = {};\n  for (const issue of issues) {\n    if (issue.path) {\n      const dotPath = getDotPath(issue);\n      if (dotPath) {\n        if (!flatErrors.nested) {\n          flatErrors.nested = {};\n        }\n        if (flatErrors.nested[dotPath]) {\n          flatErrors.nested[dotPath].push(issue.message);\n        } else {\n          flatErrors.nested[dotPath] = [issue.message];\n        }\n      } else {\n        if (flatErrors.other) {\n          flatErrors.other.push(issue.message);\n        } else {\n          flatErrors.other = [issue.message];\n        }\n      }\n    } else {\n      if (flatErrors.root) {\n        flatErrors.root.push(issue.message);\n      } else {\n        flatErrors.root = [issue.message];\n      }\n    }\n  }\n  return flatErrors;\n}\n\n// src/methods/forward/forward.ts\n// @__NO_SIDE_EFFECTS__\nfunction forward(action, path) {\n  return {\n    ...action,\n    \"~run\"(dataset, config2) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      dataset = action[\"~run\"](dataset, config2);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) {\n          if (!prevIssues?.includes(issue)) {\n            let pathInput = dataset.value;\n            for (const key of path) {\n              const pathValue = pathInput[key];\n              const pathItem = {\n                type: \"unknown\",\n                origin: \"value\",\n                input: pathInput,\n                key,\n                value: pathValue\n              };\n              if (issue.path) {\n                issue.path.push(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              if (!pathValue) {\n                break;\n              }\n              pathInput = pathValue;\n            }\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/forward/forwardAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction forwardAsync(action, path) {\n  return {\n    ...action,\n    async: true,\n    async \"~run\"(dataset, config2) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      dataset = await action[\"~run\"](dataset, config2);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) {\n          if (!prevIssues?.includes(issue)) {\n            let pathInput = dataset.value;\n            for (const key of path) {\n              const pathValue = pathInput[key];\n              const pathItem = {\n                type: \"unknown\",\n                origin: \"value\",\n                input: pathInput,\n                key,\n                value: pathValue\n              };\n              if (issue.path) {\n                issue.path.push(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              if (!pathValue) {\n                break;\n              }\n              pathInput = pathValue;\n            }\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/getDefault/getDefault.ts\n// @__NO_SIDE_EFFECTS__\nfunction getDefault(schema, dataset, config2) {\n  return typeof schema.default === \"function\" ? (\n    // @ts-expect-error\n    schema.default(dataset, config2)\n  ) : (\n    // @ts-expect-error\n    schema.default\n  );\n}\n\n// src/methods/getDefaults/getDefaults.ts\n// @__NO_SIDE_EFFECTS__\nfunction getDefaults(schema) {\n  if (\"entries\" in schema) {\n    const object2 = {};\n    for (const key in schema.entries) {\n      object2[key] = /* @__PURE__ */ getDefaults(schema.entries[key]);\n    }\n    return object2;\n  }\n  if (\"items\" in schema) {\n    return schema.items.map(getDefaults);\n  }\n  return getDefault(schema);\n}\n\n// src/methods/getDefaults/getDefaultsAsync.ts\n// @__NO_SIDE_EFFECTS__\nasync function getDefaultsAsync(schema) {\n  if (\"entries\" in schema) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await /* @__PURE__ */ getDefaultsAsync(value2)\n        ])\n      )\n    );\n  }\n  if (\"items\" in schema) {\n    return Promise.all(schema.items.map(getDefaultsAsync));\n  }\n  return getDefault(schema);\n}\n\n// src/methods/getFallbacks/getFallbacks.ts\n// @__NO_SIDE_EFFECTS__\nfunction getFallbacks(schema) {\n  if (\"entries\" in schema) {\n    const object2 = {};\n    for (const key in schema.entries) {\n      object2[key] = /* @__PURE__ */ getFallbacks(schema.entries[key]);\n    }\n    return object2;\n  }\n  if (\"items\" in schema) {\n    return schema.items.map(getFallbacks);\n  }\n  return getFallback(schema);\n}\n\n// src/methods/getFallbacks/getFallbacksAsync.ts\n// @__NO_SIDE_EFFECTS__\nasync function getFallbacksAsync(schema) {\n  if (\"entries\" in schema) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await /* @__PURE__ */ getFallbacksAsync(value2)\n        ])\n      )\n    );\n  }\n  if (\"items\" in schema) {\n    return Promise.all(schema.items.map(getFallbacksAsync));\n  }\n  return getFallback(schema);\n}\n\n// src/methods/is/is.ts\n// @__NO_SIDE_EFFECTS__\nfunction is(schema, input) {\n  return !schema[\"~run\"]({ value: input }, { abortEarly: true }).issues;\n}\n\n// src/schemas/any/any.ts\n// @__NO_SIDE_EFFECTS__\nfunction any() {\n  return {\n    kind: \"schema\",\n    type: \"any\",\n    reference: any,\n    expects: \"any\",\n    async: false,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/array/array.ts\n// @__NO_SIDE_EFFECTS__\nfunction array(item, message) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: array,\n    expects: \"Array\",\n    async: false,\n    item,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < input.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.item[\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/array/arrayAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction arrayAsync(item, message) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: arrayAsync,\n    expects: \"Array\",\n    async: true,\n    item,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          input.map((value2) => this.item[\"~run\"]({ value: value2 }, config2))\n        );\n        for (let key = 0; key < itemDatasets.length; key++) {\n          const itemDataset = itemDatasets[key];\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: input[key]\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/bigint/bigint.ts\n// @__NO_SIDE_EFFECTS__\nfunction bigint(message) {\n  return {\n    kind: \"schema\",\n    type: \"bigint\",\n    reference: bigint,\n    expects: \"bigint\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"bigint\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/blob/blob.ts\n// @__NO_SIDE_EFFECTS__\nfunction blob(message) {\n  return {\n    kind: \"schema\",\n    type: \"blob\",\n    reference: blob,\n    expects: \"Blob\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof Blob) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/boolean/boolean.ts\n// @__NO_SIDE_EFFECTS__\nfunction boolean(message) {\n  return {\n    kind: \"schema\",\n    type: \"boolean\",\n    reference: boolean,\n    expects: \"boolean\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"boolean\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/custom/custom.ts\n// @__NO_SIDE_EFFECTS__\nfunction custom(check2, message) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: custom,\n    expects: \"unknown\",\n    async: false,\n    check: check2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.check(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/custom/customAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction customAsync(check2, message) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: customAsync,\n    expects: \"unknown\",\n    async: true,\n    check: check2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (await this.check(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/date/date.ts\n// @__NO_SIDE_EFFECTS__\nfunction date(message) {\n  return {\n    kind: \"schema\",\n    type: \"date\",\n    reference: date,\n    expects: \"Date\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof Date) {\n        if (!isNaN(dataset.value)) {\n          dataset.typed = true;\n        } else {\n          _addIssue(this, \"type\", dataset, config2, {\n            received: '\"Invalid Date\"'\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/enum/enum.ts\n// @__NO_SIDE_EFFECTS__\nfunction enum_(enum__, message) {\n  const options = [];\n  for (const key in enum__) {\n    if (`${+key}` !== key || typeof enum__[key] !== \"string\" || !Object.is(enum__[enum__[key]], +key)) {\n      options.push(enum__[key]);\n    }\n  }\n  return {\n    kind: \"schema\",\n    type: \"enum\",\n    reference: enum_,\n    expects: _joinExpects(options.map(_stringify), \"|\"),\n    async: false,\n    enum: enum__,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.options.includes(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/exactOptional/exactOptional.ts\n// @__NO_SIDE_EFFECTS__\nfunction exactOptional(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"exact_optional\",\n    reference: exactOptional,\n    expects: wrapped.expects,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/exactOptional/exactOptionalAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction exactOptionalAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"exact_optional\",\n    reference: exactOptionalAsync,\n    expects: wrapped.expects,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/file/file.ts\n// @__NO_SIDE_EFFECTS__\nfunction file(message) {\n  return {\n    kind: \"schema\",\n    type: \"file\",\n    reference: file,\n    expects: \"File\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof File) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/function/function.ts\n// @__NO_SIDE_EFFECTS__\nfunction function_(message) {\n  return {\n    kind: \"schema\",\n    type: \"function\",\n    reference: function_,\n    expects: \"Function\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"function\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/instance/instance.ts\n// @__NO_SIDE_EFFECTS__\nfunction instance(class_, message) {\n  return {\n    kind: \"schema\",\n    type: \"instance\",\n    reference: instance,\n    expects: class_.name,\n    async: false,\n    class: class_,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof this.class) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/intersect/utils/_merge/_merge.ts\n// @__NO_SIDE_EFFECTS__\nfunction _merge(value1, value2) {\n  if (typeof value1 === typeof value2) {\n    if (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) {\n      return { value: value1 };\n    }\n    if (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {\n      for (const key in value2) {\n        if (key in value1) {\n          const dataset = /* @__PURE__ */ _merge(value1[key], value2[key]);\n          if (dataset.issue) {\n            return dataset;\n          }\n          value1[key] = dataset.value;\n        } else {\n          value1[key] = value2[key];\n        }\n      }\n      return { value: value1 };\n    }\n    if (Array.isArray(value1) && Array.isArray(value2)) {\n      if (value1.length === value2.length) {\n        for (let index = 0; index < value1.length; index++) {\n          const dataset = /* @__PURE__ */ _merge(value1[index], value2[index]);\n          if (dataset.issue) {\n            return dataset;\n          }\n          value1[index] = dataset.value;\n        }\n        return { value: value1 };\n      }\n    }\n  }\n  return { issue: true };\n}\n\n// src/schemas/intersect/intersect.ts\n// @__NO_SIDE_EFFECTS__\nfunction intersect(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersect,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"&\"\n    ),\n    async: false,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        for (const schema of this.options) {\n          const optionDataset = schema[\"~run\"]({ value: input }, config2);\n          if (optionDataset.issues) {\n            if (dataset.issues) {\n              dataset.issues.push(...optionDataset.issues);\n            } else {\n              dataset.issues = optionDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) {\n            dataset.typed = false;\n          }\n          if (dataset.typed) {\n            if (outputs) {\n              outputs.push(optionDataset.value);\n            } else {\n              outputs = [optionDataset.value];\n            }\n          }\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = _merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config2, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/intersect/intersectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction intersectAsync(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersectAsync,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"&\"\n    ),\n    async: true,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        const optionDatasets = await Promise.all(\n          this.options.map((schema) => schema[\"~run\"]({ value: input }, config2))\n        );\n        for (const optionDataset of optionDatasets) {\n          if (optionDataset.issues) {\n            if (dataset.issues) {\n              dataset.issues.push(...optionDataset.issues);\n            } else {\n              dataset.issues = optionDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) {\n            dataset.typed = false;\n          }\n          if (dataset.typed) {\n            if (outputs) {\n              outputs.push(optionDataset.value);\n            } else {\n              outputs = [optionDataset.value];\n            }\n          }\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = _merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config2, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/lazy/lazy.ts\n// @__NO_SIDE_EFFECTS__\nfunction lazy(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazy,\n    expects: \"unknown\",\n    async: false,\n    getter,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      return this.getter(dataset.value)[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/lazy/lazyAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction lazyAsync(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazyAsync,\n    expects: \"unknown\",\n    async: true,\n    getter,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      return (await this.getter(dataset.value))[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/literal/literal.ts\n// @__NO_SIDE_EFFECTS__\nfunction literal(literal_, message) {\n  return {\n    kind: \"schema\",\n    type: \"literal\",\n    reference: literal,\n    expects: _stringify(literal_),\n    async: false,\n    literal: literal_,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === this.literal) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseObject/looseObject.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseObject(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObject,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.fallback !== void 0) {\n            dataset.value[key] = getFallback(valueSchema);\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              dataset.value[key] = input[key];\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseObject/looseObjectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseObjectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, valueSchema]) => {\n            if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n            valueSchema.default !== void 0) {\n              const value2 = key in input ? (\n                // @ts-expect-error\n                input[key]\n              ) : await getDefault(valueSchema);\n              return [\n                key,\n                value2,\n                valueSchema,\n                await valueSchema[\"~run\"]({ value: value2 }, config2)\n              ];\n            }\n            return [\n              key,\n              // @ts-expect-error\n              input[key],\n              valueSchema,\n              null\n            ];\n          })\n        );\n        for (const [key, value2, valueSchema, valueDataset] of valueDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.fallback !== void 0) {\n            dataset.value[key] = await getFallback(valueSchema);\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              dataset.value[key] = input[key];\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseTuple/looseTuple.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseTuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            dataset.value.push(input[key]);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseTuple/looseTupleAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseTupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [key, value2, await item[\"~run\"]({ value: value2 }, config2)];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            dataset.value.push(input[key]);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/map/map.ts\n// @__NO_SIDE_EFFECTS__\nfunction map(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: map,\n    expects: \"Map\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Map();\n        for (const [inputKey, inputValue] of input) {\n          const keyDataset = this.key[\"~run\"]({ value: inputKey }, config2);\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          const valueDataset = this.value[\"~run\"](\n            { value: inputValue },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/map/mapAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction mapAsync(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: mapAsync,\n    expects: \"Map\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Map();\n        const datasets = await Promise.all(\n          [...input].map(\n            ([inputKey, inputValue]) => Promise.all([\n              inputKey,\n              inputValue,\n              this.key[\"~run\"]({ value: inputKey }, config2),\n              this.value[\"~run\"]({ value: inputValue }, config2)\n            ])\n          )\n        );\n        for (const [\n          inputKey,\n          inputValue,\n          keyDataset,\n          valueDataset\n        ] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nan/nan.ts\n// @__NO_SIDE_EFFECTS__\nfunction nan(message) {\n  return {\n    kind: \"schema\",\n    type: \"nan\",\n    reference: nan,\n    expects: \"NaN\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (Number.isNaN(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/never/never.ts\n// @__NO_SIDE_EFFECTS__\nfunction never(message) {\n  return {\n    kind: \"schema\",\n    type: \"never\",\n    reference: never,\n    expects: \"never\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullable.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullable(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullable,\n    expects: \"!null\",\n    async: false,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value !== null) {\n        dataset = this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullableAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullableAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullableAsync,\n    expects: \"!null\",\n    async: true,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value !== null) {\n        dataset = await this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullish.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullish(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullish,\n    expects: \"(!null & !undefined)\",\n    async: false,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (!(dataset.value === null || dataset.value === void 0)) {\n        dataset = this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null || dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullishAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullishAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullishAsync,\n    expects: \"(!null & !undefined)\",\n    async: true,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (!(dataset.value === null || dataset.value === void 0)) {\n        dataset = await this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null || dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptional.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonOptional(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptional,\n    expects: \"!undefined\",\n    async: false,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value !== void 0) {\n        dataset = this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptionalAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonOptionalAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptionalAsync,\n    expects: \"!undefined\",\n    async: true,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value !== void 0) {\n        dataset = await this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/null/null.ts\n// @__NO_SIDE_EFFECTS__\nfunction null_(message) {\n  return {\n    kind: \"schema\",\n    type: \"null\",\n    reference: null_,\n    expects: \"null\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === null) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nullable/nullable.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullable(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullable,\n    expects: `(${wrapped.expects} | null)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === null) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nullable/nullableAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullableAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullableAsync,\n    expects: `(${wrapped.expects} | null)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === null) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nullish/nullish.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullish(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullish,\n    expects: `(${wrapped.expects} | null | undefined)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nullish/nullishAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullishAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullishAsync,\n    expects: `(${wrapped.expects} | null | undefined)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/number/number.ts\n// @__NO_SIDE_EFFECTS__\nfunction number(message) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: number,\n    expects: \"number\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"number\" && !isNaN(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/object/object.ts\n// @__NO_SIDE_EFFECTS__\nfunction object(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: object,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.fallback !== void 0) {\n            dataset.value[key] = getFallback(valueSchema);\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/object/objectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction objectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: objectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, valueSchema]) => {\n            if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n            valueSchema.default !== void 0) {\n              const value2 = key in input ? (\n                // @ts-expect-error\n                input[key]\n              ) : await getDefault(valueSchema);\n              return [\n                key,\n                value2,\n                valueSchema,\n                await valueSchema[\"~run\"]({ value: value2 }, config2)\n              ];\n            }\n            return [\n              key,\n              // @ts-expect-error\n              input[key],\n              valueSchema,\n              null\n            ];\n          })\n        );\n        for (const [key, value2, valueSchema, valueDataset] of valueDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.fallback !== void 0) {\n            dataset.value[key] = await getFallback(valueSchema);\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/objectWithRest/objectWithRest.ts\n// @__NO_SIDE_EFFECTS__\nfunction objectWithRest(entries, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRest,\n    expects: \"Object\",\n    async: false,\n    entries,\n    rest,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.fallback !== void 0) {\n            dataset.value[key] = getFallback(valueSchema);\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              const valueDataset = this.rest[\"~run\"](\n                // @ts-expect-error\n                { value: input[key] },\n                config2\n              );\n              if (valueDataset.issues) {\n                const pathItem = {\n                  type: \"object\",\n                  origin: \"value\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                };\n                for (const issue of valueDataset.issues) {\n                  if (issue.path) {\n                    issue.path.unshift(pathItem);\n                  } else {\n                    issue.path = [pathItem];\n                  }\n                  dataset.issues?.push(issue);\n                }\n                if (!dataset.issues) {\n                  dataset.issues = valueDataset.issues;\n                }\n                if (config2.abortEarly) {\n                  dataset.typed = false;\n                  break;\n                }\n              }\n              if (!valueDataset.typed) {\n                dataset.typed = false;\n              }\n              dataset.value[key] = valueDataset.value;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/objectWithRest/objectWithRestAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction objectWithRestAsync(entries, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRestAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    rest,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const [normalDatasets, restDatasets] = await Promise.all([\n          // If key is present or its an optional schema with a default value,\n          // parse input of key or default value asynchronously\n          Promise.all(\n            Object.entries(this.entries).map(async ([key, valueSchema]) => {\n              if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n              valueSchema.default !== void 0) {\n                const value2 = key in input ? (\n                  // @ts-expect-error\n                  input[key]\n                ) : await getDefault(valueSchema);\n                return [\n                  key,\n                  value2,\n                  valueSchema,\n                  await valueSchema[\"~run\"]({ value: value2 }, config2)\n                ];\n              }\n              return [\n                key,\n                // @ts-expect-error\n                input[key],\n                valueSchema,\n                null\n              ];\n            })\n          ),\n          // Parse other entries with rest schema asynchronously\n          // Hint: We exclude specific keys for security reasons\n          Promise.all(\n            Object.entries(input).filter(\n              ([key]) => _isValidObjectKey(input, key) && !(key in this.entries)\n            ).map(\n              async ([key, value2]) => [\n                key,\n                value2,\n                await this.rest[\"~run\"]({ value: value2 }, config2)\n              ]\n            )\n          )\n        ]);\n        for (const [key, value2, valueSchema, valueDataset] of normalDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.fallback !== void 0) {\n            dataset.value[key] = await getFallback(valueSchema);\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const [key, value2, valueDataset] of restDatasets) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/optional/optional.ts\n// @__NO_SIDE_EFFECTS__\nfunction optional(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optional,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/optional/optionalAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction optionalAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optionalAsync,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/picklist/picklist.ts\n// @__NO_SIDE_EFFECTS__\nfunction picklist(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"picklist\",\n    reference: picklist,\n    expects: _joinExpects(options.map(_stringify), \"|\"),\n    async: false,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.options.includes(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/promise/promise.ts\n// @__NO_SIDE_EFFECTS__\nfunction promise(message) {\n  return {\n    kind: \"schema\",\n    type: \"promise\",\n    reference: promise,\n    expects: \"Promise\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof Promise) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/record/record.ts\n// @__NO_SIDE_EFFECTS__\nfunction record(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: record,\n    expects: \"Object\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const entryKey in input) {\n          if (_isValidObjectKey(input, entryKey)) {\n            const entryValue = input[entryKey];\n            const keyDataset = this.key[\"~run\"]({ value: entryKey }, config2);\n            if (keyDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"key\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of keyDataset.issues) {\n                issue.path = [pathItem];\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = keyDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            const valueDataset = this.value[\"~run\"](\n              { value: entryValue },\n              config2\n            );\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!keyDataset.typed || !valueDataset.typed) {\n              dataset.typed = false;\n            }\n            if (keyDataset.typed) {\n              dataset.value[keyDataset.value] = valueDataset.value;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/record/recordAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction recordAsync(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: recordAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const datasets = await Promise.all(\n          Object.entries(input).filter(([key2]) => _isValidObjectKey(input, key2)).map(\n            ([entryKey, entryValue]) => Promise.all([\n              entryKey,\n              entryValue,\n              this.key[\"~run\"]({ value: entryKey }, config2),\n              this.value[\"~run\"]({ value: entryValue }, config2)\n            ])\n          )\n        );\n        for (const [\n          entryKey,\n          entryValue,\n          keyDataset,\n          valueDataset\n        ] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"key\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of keyDataset.issues) {\n              issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (keyDataset.typed) {\n            dataset.value[keyDataset.value] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/set/set.ts\n// @__NO_SIDE_EFFECTS__\nfunction set(value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: set,\n    expects: \"Set\",\n    async: false,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Set();\n        for (const inputValue of input) {\n          const valueDataset = this.value[\"~run\"](\n            { value: inputValue },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              key: null,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.add(valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/set/setAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction setAsync(value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: setAsync,\n    expects: \"Set\",\n    async: true,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Set();\n        const valueDatasets = await Promise.all(\n          [...input].map(\n            async (inputValue) => [\n              inputValue,\n              await this.value[\"~run\"]({ value: inputValue }, config2)\n            ]\n          )\n        );\n        for (const [inputValue, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              key: null,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.add(valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictObject/strictObject.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictObject(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObject,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.fallback !== void 0) {\n            dataset.value[key] = getFallback(valueSchema);\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              _addIssue(this, \"key\", dataset, config2, {\n                input: key,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"key\",\n                    input,\n                    key,\n                    // @ts-expect-error\n                    value: input[key]\n                  }\n                ]\n              });\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictObject/strictObjectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictObjectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, valueSchema]) => {\n            if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n            valueSchema.default !== void 0) {\n              const value2 = key in input ? (\n                // @ts-expect-error\n                input[key]\n              ) : await getDefault(valueSchema);\n              return [\n                key,\n                value2,\n                valueSchema,\n                await valueSchema[\"~run\"]({ value: value2 }, config2)\n              ];\n            }\n            return [\n              key,\n              // @ts-expect-error\n              input[key],\n              valueSchema,\n              null\n            ];\n          })\n        );\n        for (const [key, value2, valueSchema, valueDataset] of valueDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.fallback !== void 0) {\n            dataset.value[key] = await getFallback(valueSchema);\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              _addIssue(this, \"key\", dataset, config2, {\n                input: key,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"key\",\n                    input,\n                    key,\n                    // @ts-expect-error\n                    value: input[key]\n                  }\n                ]\n              });\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictTuple/strictTuple.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictTuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\n          _addIssue(this, \"type\", dataset, config2, {\n            input: input[this.items.length],\n            expected: \"never\",\n            path: [\n              {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key: this.items.length,\n                value: input[this.items.length]\n              }\n            ]\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictTuple/strictTupleAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictTupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [key, value2, await item[\"~run\"]({ value: value2 }, config2)];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\n          _addIssue(this, \"type\", dataset, config2, {\n            input: input[this.items.length],\n            expected: \"never\",\n            path: [\n              {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key: this.items.length,\n                value: input[this.items.length]\n              }\n            ]\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/string/string.ts\n// @__NO_SIDE_EFFECTS__\nfunction string(message) {\n  return {\n    kind: \"schema\",\n    type: \"string\",\n    reference: string,\n    expects: \"string\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"string\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/symbol/symbol.ts\n// @__NO_SIDE_EFFECTS__\nfunction symbol(message) {\n  return {\n    kind: \"schema\",\n    type: \"symbol\",\n    reference: symbol,\n    expects: \"symbol\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"symbol\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tuple/tuple.ts\n// @__NO_SIDE_EFFECTS__\nfunction tuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tuple/tupleAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction tupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [key, value2, await item[\"~run\"]({ value: value2 }, config2)];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tupleWithRest/tupleWithRest.ts\n// @__NO_SIDE_EFFECTS__\nfunction tupleWithRest(items, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRest,\n    expects: \"Array\",\n    async: false,\n    items,\n    rest,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            const value2 = input[key];\n            const itemDataset = this.rest[\"~run\"]({ value: value2 }, config2);\n            if (itemDataset.issues) {\n              const pathItem = {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of itemDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = itemDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!itemDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value.push(itemDataset.value);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tupleWithRest/tupleWithRestAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction tupleWithRestAsync(items, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRestAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    rest,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const [normalDatasets, restDatasets] = await Promise.all([\n          // Parse schema of each normal item\n          Promise.all(\n            this.items.map(async (item, key) => {\n              const value2 = input[key];\n              return [\n                key,\n                value2,\n                await item[\"~run\"]({ value: value2 }, config2)\n              ];\n            })\n          ),\n          // Parse other items with rest schema\n          Promise.all(\n            input.slice(this.items.length).map(async (value2, key) => {\n              return [\n                key + this.items.length,\n                value2,\n                await this.rest[\"~run\"]({ value: value2 }, config2)\n              ];\n            })\n          )\n        ]);\n        for (const [key, value2, itemDataset] of normalDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const [key, value2, itemDataset] of restDatasets) {\n            if (itemDataset.issues) {\n              const pathItem = {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of itemDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = itemDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!itemDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value.push(itemDataset.value);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/undefined/undefined.ts\n// @__NO_SIDE_EFFECTS__\nfunction undefined_(message) {\n  return {\n    kind: \"schema\",\n    type: \"undefined\",\n    reference: undefined_,\n    expects: \"undefined\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/undefinedable/undefinedable.ts\n// @__NO_SIDE_EFFECTS__\nfunction undefinedable(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"undefinedable\",\n    reference: undefinedable,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/undefinedable/undefinedableAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction undefinedableAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"undefinedable\",\n    reference: undefinedableAsync,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/union/utils/_subIssues/_subIssues.ts\n// @__NO_SIDE_EFFECTS__\nfunction _subIssues(datasets) {\n  let issues;\n  if (datasets) {\n    for (const dataset of datasets) {\n      if (issues) {\n        issues.push(...dataset.issues);\n      } else {\n        issues = dataset.issues;\n      }\n    }\n  }\n  return issues;\n}\n\n// src/schemas/union/union.ts\n// @__NO_SIDE_EFFECTS__\nfunction union(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: union,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"|\"\n    ),\n    async: false,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = schema[\"~run\"]({ value: dataset.value }, config2);\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) {\n              typedDatasets.push(optionDataset);\n            } else {\n              typedDatasets = [optionDataset];\n            }\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else {\n          if (untypedDatasets) {\n            untypedDatasets.push(optionDataset);\n          } else {\n            untypedDatasets = [optionDataset];\n          }\n        }\n      }\n      if (validDataset) {\n        return validDataset;\n      }\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) {\n          return typedDatasets[0];\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) {\n        return untypedDatasets[0];\n      } else {\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(untypedDatasets)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/union/unionAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction unionAsync(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: unionAsync,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"|\"\n    ),\n    async: true,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = await schema[\"~run\"](\n          { value: dataset.value },\n          config2\n        );\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) {\n              typedDatasets.push(optionDataset);\n            } else {\n              typedDatasets = [optionDataset];\n            }\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else {\n          if (untypedDatasets) {\n            untypedDatasets.push(optionDataset);\n          } else {\n            untypedDatasets = [optionDataset];\n          }\n        }\n      }\n      if (validDataset) {\n        return validDataset;\n      }\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) {\n          return typedDatasets[0];\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) {\n        return untypedDatasets[0];\n      } else {\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(untypedDatasets)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/unknown/unknown.ts\n// @__NO_SIDE_EFFECTS__\nfunction unknown() {\n  return {\n    kind: \"schema\",\n    type: \"unknown\",\n    reference: unknown,\n    expects: \"unknown\",\n    async: false,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/variant/variant.ts\n// @__NO_SIDE_EFFECTS__\nfunction variant(key, options, message) {\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variant,\n    expects: \"Object\",\n    async: false,\n    key,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        let outputDataset;\n        let maxDiscriminatorPriority = 0;\n        let invalidDiscriminatorKey = this.key;\n        let expectedDiscriminators = [];\n        const parseOptions = (variant2, allKeys) => {\n          for (const schema of variant2.options) {\n            if (schema.type === \"variant\") {\n              parseOptions(schema, new Set(allKeys).add(schema.key));\n            } else {\n              let keysAreValid = true;\n              let currentPriority = 0;\n              for (const currentKey of allKeys) {\n                const discriminatorSchema = schema.entries[currentKey];\n                if (currentKey in input ? discriminatorSchema[\"~run\"](\n                  // @ts-expect-error\n                  { typed: false, value: input[currentKey] },\n                  config2\n                ).issues : discriminatorSchema.type !== \"exact_optional\" && discriminatorSchema.type !== \"optional\" && discriminatorSchema.type !== \"nullish\") {\n                  keysAreValid = false;\n                  if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {\n                    maxDiscriminatorPriority = currentPriority;\n                    invalidDiscriminatorKey = currentKey;\n                    expectedDiscriminators = [];\n                  }\n                  if (invalidDiscriminatorKey === currentKey) {\n                    expectedDiscriminators.push(\n                      schema.entries[currentKey].expects\n                    );\n                  }\n                  break;\n                }\n                currentPriority++;\n              }\n              if (keysAreValid) {\n                const optionDataset = schema[\"~run\"]({ value: input }, config2);\n                if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                  outputDataset = optionDataset;\n                }\n              }\n            }\n            if (outputDataset && !outputDataset.issues) {\n              break;\n            }\n          }\n        };\n        parseOptions(this, /* @__PURE__ */ new Set([this.key]));\n        if (outputDataset) {\n          return outputDataset;\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          // @ts-expect-error\n          input: input[invalidDiscriminatorKey],\n          expected: _joinExpects(expectedDiscriminators, \"|\"),\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: invalidDiscriminatorKey,\n              // @ts-expect-error\n              value: input[invalidDiscriminatorKey]\n            }\n          ]\n        });\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/variant/variantAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction variantAsync(key, options, message) {\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variantAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        let outputDataset;\n        let maxDiscriminatorPriority = 0;\n        let invalidDiscriminatorKey = this.key;\n        let expectedDiscriminators = [];\n        const parseOptions = async (variant2, allKeys) => {\n          for (const schema of variant2.options) {\n            if (schema.type === \"variant\") {\n              await parseOptions(schema, new Set(allKeys).add(schema.key));\n            } else {\n              let keysAreValid = true;\n              let currentPriority = 0;\n              for (const currentKey of allKeys) {\n                const discriminatorSchema = schema.entries[currentKey];\n                if (currentKey in input ? (await discriminatorSchema[\"~run\"](\n                  // @ts-expect-error\n                  { typed: false, value: input[currentKey] },\n                  config2\n                )).issues : discriminatorSchema.type !== \"exact_optional\" && discriminatorSchema.type !== \"optional\" && discriminatorSchema.type !== \"nullish\") {\n                  keysAreValid = false;\n                  if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {\n                    maxDiscriminatorPriority = currentPriority;\n                    invalidDiscriminatorKey = currentKey;\n                    expectedDiscriminators = [];\n                  }\n                  if (invalidDiscriminatorKey === currentKey) {\n                    expectedDiscriminators.push(\n                      schema.entries[currentKey].expects\n                    );\n                  }\n                  break;\n                }\n                currentPriority++;\n              }\n              if (keysAreValid) {\n                const optionDataset = await schema[\"~run\"](\n                  { value: input },\n                  config2\n                );\n                if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                  outputDataset = optionDataset;\n                }\n              }\n            }\n            if (outputDataset && !outputDataset.issues) {\n              break;\n            }\n          }\n        };\n        await parseOptions(this, /* @__PURE__ */ new Set([this.key]));\n        if (outputDataset) {\n          return outputDataset;\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          // @ts-expect-error\n          input: input[invalidDiscriminatorKey],\n          expected: _joinExpects(expectedDiscriminators, \"|\"),\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: invalidDiscriminatorKey,\n              // @ts-expect-error\n              value: input[invalidDiscriminatorKey]\n            }\n          ]\n        });\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/void/void.ts\n// @__NO_SIDE_EFFECTS__\nfunction void_(message) {\n  return {\n    kind: \"schema\",\n    type: \"void\",\n    reference: void_,\n    expects: \"void\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/keyof/keyof.ts\n// @__NO_SIDE_EFFECTS__\nfunction keyof(schema, message) {\n  return picklist(Object.keys(schema.entries), message);\n}\n\n// src/methods/omit/omit.ts\n// @__NO_SIDE_EFFECTS__\nfunction omit(schema, keys) {\n  const entries = {\n    ...schema.entries\n  };\n  for (const key of keys) {\n    delete entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/parse/parse.ts\nfunction parse(schema, input, config2) {\n  const dataset = schema[\"~run\"]({ value: input }, getGlobalConfig(config2));\n  if (dataset.issues) {\n    throw new ValiError(dataset.issues);\n  }\n  return dataset.value;\n}\n\n// src/methods/parse/parseAsync.ts\nasync function parseAsync(schema, input, config2) {\n  const dataset = await schema[\"~run\"](\n    { value: input },\n    getGlobalConfig(config2)\n  );\n  if (dataset.issues) {\n    throw new ValiError(dataset.issues);\n  }\n  return dataset.value;\n}\n\n// src/methods/parser/parser.ts\n// @__NO_SIDE_EFFECTS__\nfunction parser(schema, config2) {\n  const func = (input) => parse(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/parser/parserAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction parserAsync(schema, config2) {\n  const func = (input) => parseAsync(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/partial/partial.ts\n// @__NO_SIDE_EFFECTS__\nfunction partial(schema, keys) {\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? optional(schema.entries[key]) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/partial/partialAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction partialAsync(schema, keys) {\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? optionalAsync(schema.entries[key]) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/pick/pick.ts\n// @__NO_SIDE_EFFECTS__\nfunction pick(schema, keys) {\n  const entries = {};\n  for (const key of keys) {\n    entries[key] = schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/pipe/pipe.ts\n// @__NO_SIDE_EFFECTS__\nfunction pipe(...pipe2) {\n  return {\n    ...pipe2[0],\n    pipe: pipe2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      for (const item of pipe2) {\n        if (item.kind !== \"metadata\") {\n          if (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n            dataset.typed = false;\n            break;\n          }\n          if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\n            dataset = item[\"~run\"](dataset, config2);\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/pipe/pipeAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction pipeAsync(...pipe2) {\n  return {\n    ...pipe2[0],\n    pipe: pipe2,\n    async: true,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      for (const item of pipe2) {\n        if (item.kind !== \"metadata\") {\n          if (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n            dataset.typed = false;\n            break;\n          }\n          if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\n            dataset = await item[\"~run\"](dataset, config2);\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/required/required.ts\n// @__NO_SIDE_EFFECTS__\nfunction required(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message = Array.isArray(arg2) ? arg3 : arg2;\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? nonOptional(schema.entries[key], message) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/required/requiredAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction requiredAsync(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message = Array.isArray(arg2) ? arg3 : arg2;\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? nonOptionalAsync(schema.entries[key], message) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/safeParse/safeParse.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeParse(schema, input, config2) {\n  const dataset = schema[\"~run\"]({ value: input }, getGlobalConfig(config2));\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n// src/methods/safeParse/safeParseAsync.ts\n// @__NO_SIDE_EFFECTS__\nasync function safeParseAsync(schema, input, config2) {\n  const dataset = await schema[\"~run\"](\n    { value: input },\n    getGlobalConfig(config2)\n  );\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n// src/methods/safeParser/safeParser.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeParser(schema, config2) {\n  const func = (input) => safeParse(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/safeParser/safeParserAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeParserAsync(schema, config2) {\n  const func = (input) => safeParseAsync(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/unwrap/unwrap.ts\n// @__NO_SIDE_EFFECTS__\nfunction unwrap(schema) {\n  return schema.wrapped;\n}\nexport {\n  BASE64_REGEX,\n  BIC_REGEX,\n  CUID2_REGEX,\n  DECIMAL_REGEX,\n  DIGITS_REGEX,\n  EMAIL_REGEX,\n  EMOJI_REGEX,\n  HEXADECIMAL_REGEX,\n  HEX_COLOR_REGEX,\n  IMEI_REGEX,\n  IPV4_REGEX,\n  IPV6_REGEX,\n  IP_REGEX,\n  ISO_DATE_REGEX,\n  ISO_DATE_TIME_REGEX,\n  ISO_TIMESTAMP_REGEX,\n  ISO_TIME_REGEX,\n  ISO_TIME_SECOND_REGEX,\n  ISO_WEEK_REGEX,\n  MAC48_REGEX,\n  MAC64_REGEX,\n  MAC_REGEX,\n  NANO_ID_REGEX,\n  OCTAL_REGEX,\n  RFC_EMAIL_REGEX,\n  SLUG_REGEX,\n  ULID_REGEX,\n  UUID_REGEX,\n  ValiError,\n  _addIssue,\n  _getByteCount,\n  _getGraphemeCount,\n  _getStandardProps,\n  _getWordCount,\n  _isLuhnAlgo,\n  _isValidObjectKey,\n  _joinExpects,\n  _stringify,\n  any,\n  args,\n  argsAsync,\n  array,\n  arrayAsync,\n  assert,\n  awaitAsync,\n  base64,\n  bic,\n  bigint,\n  blob,\n  boolean,\n  brand,\n  bytes,\n  check,\n  checkAsync,\n  checkItems,\n  checkItemsAsync,\n  config,\n  creditCard,\n  cuid2,\n  custom,\n  customAsync,\n  date,\n  decimal,\n  deleteGlobalConfig,\n  deleteGlobalMessage,\n  deleteSchemaMessage,\n  deleteSpecificMessage,\n  description,\n  digits,\n  email,\n  emoji,\n  empty,\n  endsWith,\n  entriesFromList,\n  entriesFromObjects,\n  enum_ as enum,\n  enum_,\n  everyItem,\n  exactOptional,\n  exactOptionalAsync,\n  excludes,\n  fallback,\n  fallbackAsync,\n  file,\n  filterItems,\n  findItem,\n  finite,\n  flatten,\n  forward,\n  forwardAsync,\n  function_ as function,\n  function_,\n  getDefault,\n  getDefaults,\n  getDefaultsAsync,\n  getDotPath,\n  getFallback,\n  getFallbacks,\n  getFallbacksAsync,\n  getGlobalConfig,\n  getGlobalMessage,\n  getSchemaMessage,\n  getSpecificMessage,\n  graphemes,\n  gtValue,\n  hash,\n  hexColor,\n  hexadecimal,\n  imei,\n  includes,\n  instance,\n  integer,\n  intersect,\n  intersectAsync,\n  ip,\n  ipv4,\n  ipv6,\n  is,\n  isOfKind,\n  isOfType,\n  isValiError,\n  isoDate,\n  isoDateTime,\n  isoTime,\n  isoTimeSecond,\n  isoTimestamp,\n  isoWeek,\n  keyof,\n  lazy,\n  lazyAsync,\n  length,\n  literal,\n  looseObject,\n  looseObjectAsync,\n  looseTuple,\n  looseTupleAsync,\n  ltValue,\n  mac,\n  mac48,\n  mac64,\n  map,\n  mapAsync,\n  mapItems,\n  maxBytes,\n  maxGraphemes,\n  maxLength,\n  maxSize,\n  maxValue,\n  maxWords,\n  metadata,\n  mimeType,\n  minBytes,\n  minGraphemes,\n  minLength,\n  minSize,\n  minValue,\n  minWords,\n  multipleOf,\n  nan,\n  nanoid,\n  never,\n  nonEmpty,\n  nonNullable,\n  nonNullableAsync,\n  nonNullish,\n  nonNullishAsync,\n  nonOptional,\n  nonOptionalAsync,\n  normalize,\n  notBytes,\n  notGraphemes,\n  notLength,\n  notSize,\n  notValue,\n  notValues,\n  notWords,\n  null_ as null,\n  null_,\n  nullable,\n  nullableAsync,\n  nullish,\n  nullishAsync,\n  number,\n  object,\n  objectAsync,\n  objectWithRest,\n  objectWithRestAsync,\n  octal,\n  omit,\n  optional,\n  optionalAsync,\n  parse,\n  parseAsync,\n  parser,\n  parserAsync,\n  partial,\n  partialAsync,\n  partialCheck,\n  partialCheckAsync,\n  pick,\n  picklist,\n  pipe,\n  pipeAsync,\n  promise,\n  rawCheck,\n  rawCheckAsync,\n  rawTransform,\n  rawTransformAsync,\n  readonly,\n  record,\n  recordAsync,\n  reduceItems,\n  regex,\n  required,\n  requiredAsync,\n  returns,\n  returnsAsync,\n  rfcEmail,\n  safeInteger,\n  safeParse,\n  safeParseAsync,\n  safeParser,\n  safeParserAsync,\n  set,\n  setAsync,\n  setGlobalConfig,\n  setGlobalMessage,\n  setSchemaMessage,\n  setSpecificMessage,\n  size,\n  slug,\n  someItem,\n  sortItems,\n  startsWith,\n  strictObject,\n  strictObjectAsync,\n  strictTuple,\n  strictTupleAsync,\n  string,\n  symbol,\n  title,\n  toLowerCase,\n  toMaxValue,\n  toMinValue,\n  toUpperCase,\n  transform,\n  transformAsync,\n  trim,\n  trimEnd,\n  trimStart,\n  tuple,\n  tupleAsync,\n  tupleWithRest,\n  tupleWithRestAsync,\n  ulid,\n  undefined_ as undefined,\n  undefined_,\n  undefinedable,\n  undefinedableAsync,\n  union,\n  unionAsync,\n  unknown,\n  unwrap,\n  url,\n  uuid,\n  value,\n  values,\n  variant,\n  variantAsync,\n  void_ as void,\n  void_,\n  words\n};\n", "var f = Object.defineProperty;\nvar u = (r, t, e) => t in r ? f(r, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : r[t] = e;\nvar c = (r, t, e) => u(r, typeof t != \"symbol\" ? t + \"\" : t, e);\nfunction a(r, t) {\n  return (e) => e instanceof r && e.type === t;\n}\nfunction p(r, t) {\n  t || (t = []);\n  const e = Symbol(r);\n  class n extends Error {\n    constructor(...i) {\n      const o = typeof t == \"function\" ? t(...i) : typeof t == \"string\" ? [t] : t || [];\n      super(...o);\n      c(this, \"type\", e);\n      this.name = r;\n    }\n  }\n  return Object.defineProperty(n, \"name\", { value: r }), [n, a(n, e)];\n}\nfunction l(r, t, e) {\n  const n = Symbol(r);\n  class s extends p(r, e)[0] {\n    constructor(...o) {\n      super(...o);\n      c(this, \"data\");\n      c(this, \"type\", n);\n      this.data = t(...o);\n    }\n  }\n  return Object.defineProperty(s, \"name\", { value: r }), [s, a(s, n)];\n}\nexport {\n  p as errorClass,\n  l as errorClassWithData,\n  a as isErrorOfKind\n};\n//# sourceMappingURL=index.js.map\n", "import { errorClass } from 'error-kid';\r\n\r\nexport const [CancelledError, isCancelledError] =\r\n  errorClass('CancelledError', 'Promise was canceled');", "import { errorClass } from 'error-kid';\r\n\r\nexport const [TimeoutError, isTimeoutError] =\r\n  errorClass<[timeout: number, cause?: unknown]>(\r\n    'TimeoutError',\r\n    (timeout, cause) => [`Timeout reached: ${timeout}ms`, { cause }],\r\n  );\r\n", "export type PromiseResolveResult<T> = [typeof RESOLVED_SYMBOL, T];\r\n\r\nconst RESOLVED_SYMBOL = Symbol('Resolved');\r\n\r\n/**\r\n * @return True if passed value determines that the promise was resolved.\r\n * @param value\r\n * @example\r\n * const promise = new ManualPromise(async (res, rej, signal) => {\r\n *   // Imitate something async here.\r\n *   await new Promise(res => setTimeout(res, 1000));\r\n *\r\n *   if (isResolved(signal.reason)) {\r\n *     // It means that ManualPromise was resolved outside. We probably want to stop executing\r\n *     // the function as long as the result will not affect anything.\r\n *     return;\r\n *   }\r\n *\r\n *   // Otherwise keep doing what we do.\r\n * });\r\n */\r\nexport function isPromiseResolveResult(value: unknown): value is PromiseResolveResult<unknown> {\r\n  return Array.isArray(value) && value[0] === RESOLVED_SYMBOL;\r\n}\r\n\r\nexport function withResolved<T>(value: T): PromiseResolveResult<T> {\r\n  return [RESOLVED_SYMBOL, value];\r\n}", "import type {\r\n  PromiseExecutorFn,\r\n  PromiseOnRejectedFn,\r\n  PromiseRejectFn,\r\n  PromiseOnFulfilledFn,\r\n  PromiseResolveFn,\r\n  PromiseOptions,\r\n  Maybe,\r\n  WithFnFunction,\r\n} from './types.js';\r\nimport { TimeoutError } from '../errors/TimeoutError.js';\r\nimport { CancelledError } from '../errors/CancelledError.js';\r\nimport { isPromiseResolveResult, withResolved } from './resolve.js';\r\n\r\nfunction reassignProps<P extends AbortablePromise<any>>(\r\n  childPromise: P,\r\n  parentPromise: AbortablePromise<any>,\r\n): P {\r\n  childPromise.reject = parentPromise.reject;\r\n  childPromise.abort = parentPromise.abort;\r\n  return childPromise;\r\n}\r\n\r\n/**\r\n * Improved version of the JavaScript Promise.\r\n */\r\nexport class AbortablePromise<Result> extends Promise<Result> {\r\n  /**\r\n   * Creates a new AbortablePromise instance using an executor, resolving the promise when a result\r\n   * was returned.\r\n   * @param fn - function returning promise result.\r\n   * @param options - additional options.\r\n   */\r\n  static fn<T>(fn: WithFnFunction<T>, options?: PromiseOptions): AbortablePromise<T> {\r\n    return new AbortablePromise(async (res, rej, context) => {\r\n      try {\r\n        res(await fn(context));\r\n      } catch (e) {\r\n        rej(e);\r\n      }\r\n    }, options);\r\n  }\r\n\r\n  /**\r\n   * @see Promise.resolve\r\n   */\r\n  static override resolve(): AbortablePromise<void>;\r\n  /**\r\n   * @see Promise.resolve\r\n   */\r\n  static override resolve<T>(value: T | PromiseLike<T>): AbortablePromise<Awaited<T>>;\r\n  static override resolve<T>(value?: T | PromiseLike<T>): AbortablePromise<Awaited<T>> {\r\n    return this.fn(() => value) as AbortablePromise<Awaited<T>>;\r\n  }\r\n\r\n  /**\r\n   * @see Promise.reject\r\n   */\r\n  static override reject<T = never>(reason?: any): AbortablePromise<T> {\r\n    return new AbortablePromise((_, rej) => {\r\n      rej(reason);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Creates a new AbortablePromise instance using only options.\r\n   * @param options - additional options.\r\n   */\r\n  constructor(options?: PromiseOptions);\r\n  /**\r\n   * Creates a new AbortablePromise instance using specified executor and additional options.\r\n   * @param executor - promise executor.\r\n   * @param options - additional options.\r\n   */\r\n  constructor(executor?: PromiseExecutorFn<Result>, options?: PromiseOptions);\r\n  constructor(\r\n    executorOrOptions?: PromiseExecutorFn<Result> | PromiseOptions,\r\n    maybeOptions?: PromiseOptions,\r\n  ) {\r\n    let reject!: PromiseRejectFn;\r\n    let abort!: (reason: unknown) => void;\r\n    super((res, rej) => {\r\n      let executor: PromiseExecutorFn<Result> | undefined;\r\n      let options: PromiseOptions | undefined;\r\n\r\n      if (typeof executorOrOptions === 'function') {\r\n        executor = executorOrOptions;\r\n        options = maybeOptions;\r\n      } else {\r\n        options = executorOrOptions;\r\n      }\r\n\r\n      //#region Cleanup section.\r\n      const cleanupFns: VoidFunction[] = [];\r\n      const withCleanup = <F extends (...args: any) => any>(\r\n        fn: F,\r\n      ): (...args: Parameters<F>) => ReturnType<F> => {\r\n        return (...args) => {\r\n          const result = fn(...args);\r\n          cleanupFns.forEach(fn => fn());\r\n          return result;\r\n        };\r\n      };\r\n      //#endregion\r\n\r\n      // We are going to use our controller signal in the executor because we can control it.\r\n      // We can't say the same about the abort signal passed from above, we can't abort it by\r\n      // ourselves.\r\n      const controller = new AbortController();\r\n      const { signal } = controller;\r\n      abort = reason => {\r\n        !signal.aborted && controller.abort(reason);\r\n      };\r\n      const abortReason = () => signal.reason;\r\n      const onAborted = (listener: (reason: unknown) => void): VoidFunction => {\r\n        const wrapped = () => {\r\n          listener(abortReason());\r\n        };\r\n        signal.addEventListener('abort', wrapped, true);\r\n\r\n        const cleanup = () => {\r\n          signal.removeEventListener('abort', wrapped, true);\r\n        };\r\n        cleanupFns.push(cleanup);\r\n        return cleanup;\r\n      };\r\n\r\n      // Enhance resolve and reject functions with cleanup and controller abortion.\r\n      const resolve = withCleanup((result: Result) => {\r\n        res(result);\r\n        abort(withResolved(result));\r\n      }) as PromiseResolveFn<Result>;\r\n      reject = withCleanup(reason => {\r\n        rej(reason);\r\n        abort(reason);\r\n      });\r\n\r\n      //#region Process abortSignal option.\r\n      options ||= {};\r\n      const { abortSignal, rejectOnAbort = true } = options;\r\n      if (abortSignal) {\r\n        if (abortSignal.aborted) {\r\n          const { reason } = abortSignal;\r\n          if (rejectOnAbort) {\r\n            return reject(reason);\r\n          }\r\n          abort(reason);\r\n        } else {\r\n          // When the passed abort signal aborts, we are also aborting our locally created signal.\r\n          const listener = () => {\r\n            abort(abortSignal.reason);\r\n          };\r\n          abortSignal.addEventListener('abort', listener);\r\n          cleanupFns.push(() => {\r\n            abortSignal.removeEventListener('abort', listener);\r\n          });\r\n        }\r\n      }\r\n      //#endregion\r\n\r\n      //#region Process rejectOnAbort option.\r\n      rejectOnAbort && onAborted(rej);\r\n      //#endregion\r\n\r\n      //#region Process timeout option.\r\n      const { timeout } = options;\r\n      if (timeout) {\r\n        const timeoutId = setTimeout(() => {\r\n          abort(new TimeoutError(timeout));\r\n        }, timeout);\r\n\r\n        cleanupFns.push(() => {\r\n          clearTimeout(timeoutId);\r\n        });\r\n      }\r\n      //#endregion\r\n\r\n      const isAborted = () => signal.aborted;\r\n      const isResolved = () => isPromiseResolveResult(abortReason());\r\n      const resolved = () => {\r\n        const reason = abortReason();\r\n        return isPromiseResolveResult(reason) ? reason[1] as Result : undefined;\r\n      };\r\n      try {\r\n        const result = executor && executor(resolve, reject, {\r\n          abortReason,\r\n          abortSignal: signal,\r\n          isAborted,\r\n          isResolved,\r\n          onAborted,\r\n          onResolved: listener => onAborted(() => {\r\n            isResolved() && listener(resolved() as Result);\r\n          }),\r\n          resolved,\r\n          throwIfAborted() {\r\n            if (isAborted()) {\r\n              throw abortReason();\r\n            }\r\n          },\r\n        });\r\n\r\n        // If a promise was returned, we want to handle its rejection because the JS Promise\r\n        // will not do it for us. Not catching the promise rejection this way, an unhandled promise\r\n        // rejection error will be thrown. We also need to perform reject properly cleaning up\r\n        // all effects.\r\n        if (result instanceof Promise) {\r\n          result.catch(reject);\r\n        }\r\n      } catch (e) {\r\n        // The wrapped executor may throw an error. Here we are following the same logic described\r\n        // in result.catch() line above.\r\n        reject(e);\r\n      }\r\n    });\r\n\r\n    this.abort = abort;\r\n    this.reject = reject;\r\n  }\r\n\r\n  /**\r\n   * Aborts the promise execution using the specified reason.\r\n   *\r\n   * Not that this method doesn't reject the promise but notifies the executor using its context.\r\n   * To perform the same operation but also reject the promise, use the `reject()` method.\r\n   * @param reason - abort reason.\r\n   * @see reject\r\n   */\r\n  abort: (reason?: unknown) => void;\r\n\r\n  /**\r\n   * Aborts the promise with the cancel error.\r\n   */\r\n  cancel(): void {\r\n    this.abort(new CancelledError())\r\n  }\r\n\r\n  /**\r\n   * @see Promise.catch\r\n   */\r\n  override catch<CatchResult = never>(\r\n    onRejected?: Maybe<PromiseOnRejectedFn<CatchResult>>,\r\n  ): AbortablePromise<Result | CatchResult> {\r\n    return this.then(undefined, onRejected);\r\n  }\r\n\r\n  /**\r\n   * @see Promise.finally\r\n   */\r\n  override finally(onFinally?: Maybe<() => void>): AbortablePromise<Result> {\r\n    // Here we follow the same logic described in the \"then\" method.\r\n    return reassignProps(super.finally(onFinally) as AbortablePromise<Result>, this);\r\n  }\r\n\r\n  /**\r\n   * Rejects the initially created promise.\r\n   *\r\n   * This method not only aborts the signal passed to the executor, but also rejects the\r\n   * promise itself calling all chained listeners.\r\n   *\r\n   * The reason passed to the method is being passed as-is to the executor's context.\r\n   */\r\n  reject: PromiseRejectFn;\r\n\r\n  /**\r\n   * @see Promise.then\r\n   */\r\n  override then<A = Result, B = never>(\r\n    onFulfilled?: Maybe<PromiseOnFulfilledFn<Result, A>>,\r\n    onRejected?: Maybe<PromiseOnRejectedFn<B>>,\r\n  ): AbortablePromise<A | B> {\r\n    // Use the original promise \"then\" method because in fact, it creates an AbortablePromise\r\n    // instance.\r\n    // Then, reassign the promise \"reject\" method, because not doing it and rejecting the promise\r\n    // it will lead to an unhandled promise rejection.\r\n    //\r\n    // Here is an example:\r\n    // const myPromise = new AbortablePromise(...)\r\n    //   .catch(() => console.log('Catched'));\r\n    //\r\n    // If we don't reassign myPromise's \"reject\" method here, it will reject the promise, returned\r\n    // from the \"catch\" method, which is unexpected. So, even using several catches in a row,\r\n    // a developer will not be able to catch the error, thrown using the \"reject\" method.\r\n    //\r\n    // The expected behavior here is the \"reject\" method rejecting the initially created promise.\r\n    // Then, this error will be handled via the \"catch\" method.\r\n    return reassignProps(super.then(onFulfilled, onRejected) as AbortablePromise<A | B>, this);\r\n  }\r\n}\r\n", "import { AbortablePromise } from './AbortablePromise.js';\r\nimport type {\r\n  PromiseExecutorFn,\r\n  PromiseOnRejectedFn,\r\n  PromiseOnFulfilledFn,\r\n  PromiseResolveFn,\r\n  PromiseOptions,\r\n  Maybe,\r\n  WithFnFunction,\r\n} from './types.js';\r\n\r\nfunction assignResolve<P extends ManualPromise<any>>(\r\n  childPromise: P,\r\n  parentPromise: ManualPromise<any>,\r\n): P {\r\n  childPromise.resolve = parentPromise.resolve;\r\n  return childPromise;\r\n}\r\n\r\nexport class ManualPromise<T> extends AbortablePromise<T> {\r\n  /**\r\n   * Creates a new ManualPromise instance using an executor, resolving the promise when a result\r\n   * was returned.\r\n   * @param fn - function returning promise result.\r\n   * @param options - additional options.\r\n   */\r\n  static fn<T>(fn: WithFnFunction<T>, options?: PromiseOptions): ManualPromise<T> {\r\n    return new ManualPromise((res, rej, signal) => {\r\n      try {\r\n        Promise.resolve(fn(signal)).then(res, rej);\r\n      } catch (e) {\r\n        rej(e);\r\n      }\r\n    }, options);\r\n  }\r\n\r\n  /**\r\n   * @see Promise.resolve\r\n   */\r\n  static override resolve(): ManualPromise<void>;\r\n  /**\r\n   * @see Promise.resolve\r\n   */\r\n  static override resolve<T>(value: T | PromiseLike<T>): ManualPromise<Awaited<T>>;\r\n  static override resolve<T>(value?: T | PromiseLike<T>): ManualPromise<Awaited<T>> {\r\n    return this.fn(() => value) as ManualPromise<Awaited<T>>;\r\n  }\r\n\r\n  /**\r\n   * @see Promise.reject\r\n   */\r\n  static override reject<T = never>(reason?: any,): ManualPromise<T> {\r\n    return new ManualPromise((_, rej) => {\r\n      rej(reason);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Creates a new ManualPromise instance using only options.\r\n   * @param options - additional options.\r\n   */\r\n  constructor(options?: PromiseOptions);\r\n  /**\r\n   * Creates a new ManualPromise instance using specified executor and additional options.\r\n   * @param executor - promise executor.\r\n   * @param options - additional options.\r\n   */\r\n  constructor(executor?: PromiseExecutorFn<T>, options?: PromiseOptions);\r\n  constructor(\r\n    executorOrOptions?: PromiseExecutorFn<T> | PromiseOptions,\r\n    maybeOptions?: PromiseOptions,\r\n  ) {\r\n    let executor: PromiseExecutorFn<T> | undefined;\r\n    let options: PromiseOptions | undefined;\r\n\r\n    if (typeof executorOrOptions === 'function') {\r\n      executor = executorOrOptions;\r\n      options = maybeOptions;\r\n    } else {\r\n      options = executorOrOptions;\r\n    }\r\n\r\n    let resolve!: PromiseResolveFn<T>;\r\n    super((res, rej, context) => {\r\n      resolve = res;\r\n      executor && executor(res, rej, context);\r\n    }, options);\r\n    this.resolve = resolve;\r\n  }\r\n\r\n  /**\r\n   * @see Promise.catch\r\n   */\r\n  override catch<CatchResult = never>(\r\n    onRejected?: Maybe<PromiseOnRejectedFn<CatchResult>>,\r\n  ): ManualPromise<T | CatchResult> {\r\n    return this.then(undefined, onRejected);\r\n  }\r\n\r\n  /**\r\n   * @see Promise.finally\r\n   */\r\n  override finally(onFinally?: Maybe<() => void>): ManualPromise<T> {\r\n    // Here, we are completely following the logic, described in the AbortablePromise.finally.\r\n    return assignResolve(super.finally(onFinally) as ManualPromise<T>, this);\r\n  }\r\n\r\n  /**\r\n   * Resolves the promise.\r\n   */\r\n  resolve: PromiseResolveFn<T>;\r\n\r\n  /**\r\n   * @see Promise.then\r\n   */\r\n  override then<A = T, B = never>(\r\n    onFulfilled?: Maybe<PromiseOnFulfilledFn<T, A>>,\r\n    onRejected?: Maybe<PromiseOnRejectedFn<B>>,\r\n  ): ManualPromise<A | B> {\r\n    // Here, we are completely following the logic, described in the AbortablePromise.then.\r\n    return assignResolve(super.then(onFulfilled, onRejected) as ManualPromise<A | B>, this);\r\n  }\r\n}", "/**\n * Converts string value from camel case to kebab case.\n * @param value - value to convert.\n */\nexport function camelToKebab(value: string): string {\n  return value.replace(/[A-Z]/g, (match) => `-${match.toLowerCase()}`);\n}\n", "export type CamelToSnakeCase<T extends string> = T extends `${infer First}${infer Rest}`\n  ? `${First extends Capitalize<First> ? '_' : ''}${Lowercase<First>}${CamelToSnakeCase<Rest>}`\n  : T;\n\n/**\n * Converts string value from camel case to snake case.\n * @param value - value to convert.\n */\nexport function camelToSnake<T extends string>(value: T): CamelToSnakeCase<T> {\n  return value.replace(/[A-Z]/g, (match) => `_${match.toLowerCase()}`) as CamelToSnakeCase<T>;\n}", "import { camelToSnake, type CamelToSnakeCase } from '@/casing/camelToSnake.js';\n\nexport type ConvertCamelKeysToSnakeCase<T> = {\n  [K in keyof T as CamelToSnakeCase<string & K>]: T[K];\n};\n\n/**\n * Converts object keys from snake to camel case.\n * @param value - value to convert.\n */\nexport function camelToSnakeObjKeys<T extends object>(value: T): ConvertCamelKeysToSnakeCase<T> {\n  return Object.entries(value).reduce<ConvertCamelKeysToSnakeCase<T>>((acc, [k, v]) => {\n    acc[camelToSnake(k) as keyof ConvertCamelKeysToSnakeCase<T>] = v;\n    return acc;\n  }, {} as ConvertCamelKeysToSnakeCase<T>);\n}", "export type SnakeToCamelCase<S extends string> =\n  S extends `${infer Head}_${infer Tail}`\n    ? `${Head}${Capitalize<SnakeToCamelCase<Tail>>}`\n    : S;\n\n/**\n * Converts string value from snake case to camel case.\n * @param value - value to convert.\n */\nexport function snakeToCamel<T extends string>(value: T): SnakeToCamelCase<T> {\n  return value.replace(/_[a-z]/g, (m) => m[1].toUpperCase()) as SnakeToCamelCase<T>;\n}", "import { snakeToCamel, type SnakeToCamelCase } from '@/casing/snakeToCamel.js';\n\nexport type ConvertSnakeKeysToCamelCase<T> = {\n  [K in keyof T as SnakeToCamelCase<string & K>]: T[K];\n};\n\n/**\n * Converts object keys from snake to camel case.\n * @param value - value to convert.\n */\nexport function snakeToCamelObjKeys<T extends object>(value: T): ConvertSnakeKeysToCamelCase<T> {\n  return Object.entries(value).reduce<ConvertSnakeKeysToCamelCase<T>>((acc, [k, v]) => {\n    acc[snakeToCamel(k) as keyof ConvertSnakeKeysToCamelCase<T>] = v;\n    return acc;\n  }, {} as ConvertSnakeKeysToCamelCase<T>);\n}", "import { snakeToCamelObjKeys } from '@/casing/snakeToCamelObjKeys.js';\nimport type { SnakeToCamelCase } from '@/casing/snakeToCamel.js';\n\nexport type DeepConvertSnakeKeysToCamelCase<T> = T extends infer U\n    ? U extends object\n      ? U extends Date\n        ? U\n        : U extends (infer Item)[]\n          ? DeepConvertSnakeKeysToCamelCase<Item>[]\n          : {\n            [K in keyof U as SnakeToCamelCase<string & K>]: DeepConvertSnakeKeysToCamelCase<U[K]>\n          } & {}\n      : U\n    : T;\n\n/**\n * Deeply converts object keys from snake to camel case.\n * @param value - value to convert.\n */\nexport function deepSnakeToCamelObjKeys<T extends object>(\n  value: T,\n): DeepConvertSnakeKeysToCamelCase<T> {\n  const camelCased = snakeToCamelObjKeys(value);\n  for (const key in camelCased) {\n    const value = camelCased[key];\n    if (value && typeof value === 'object' && !(value instanceof Date)) {\n      (camelCased as any)[key] = Array.isArray(value)\n        ? value.map(deepSnakeToCamelObjKeys)\n        : deepSnakeToCamelObjKeys(value);\n    }\n  }\n  return camelCased as DeepConvertSnakeKeysToCamelCase<T>;\n}", "/**\n * Converts string value from snake case to kebab case.\n * @param value - value to convert.\n */\nexport function snakeToKebab(value: string): string {\n  return value.replace(/_([a-z])/g, (_, letter) => `-${letter.toLowerCase()}`);\n}\n", "/**\n * Converts a passed storage key to the formatted state.\n * @param key - storage key.\n */\nfunction formatKey(key: string): string {\n  return `tapps/${key}`;\n}\n\n/**\n * Saves value in the storage.\n * @param key - storage key.\n * @param value - storage value.\n */\nexport function setStorageValue<T>(key: string, value: T): void {\n  sessionStorage.setItem(formatKey(key), JSON.stringify(value));\n}\n\n/**\n * Extracts value from the storage.\n * @param key - storage key.\n */\nexport function getStorageValue<R>(key: string): R | undefined {\n  const value = sessionStorage.getItem(formatKey(key));\n  try {\n    return value ? JSON.parse(value) as R : undefined;\n  } catch {\n  }\n}\n", "export type CallbackFn = () => void;\n\n/**\n * Returns a tuple, containing function to add cleanup, call cleanup, and flag showing whether\n * cleanup was called. Cleanup will not be performed in case, it was done before.\n */\nexport function createCbCollector(...cbs: (CallbackFn | CallbackFn[])[]): [\n  add: (...fns: CallbackFn[]) => void,\n  call: () => void,\n] {\n  const callbacks = cbs.flat(1);\n\n  return [\n    callbacks.push.bind(callbacks),\n    () => {\n      callbacks.forEach(cb => {\n        cb();\n      });\n    },\n  ];\n}", "/**\n * Message log level.\n */\nexport type LogLevel = 'log' | 'error' | 'warn';\n\nexport interface LoggerOptions {\n  bgColor?: string;\n  textColor?: string;\n  /**\n   * True if logs are enabled.\n   * @default true\n   */\n  shouldLog?: boolean | (() => boolean);\n}\n\nexport type LoggerFn = (...args: any[]) => void;\nexport type LoggerForceFn = (...args: any[]) => void;\n\nexport interface Logger {\n  /**\n   * Prints an error message into the console.\n   * @param args - items to log.\n   */\n  error: LoggerFn;\n  /**\n   * Prints an error message into the console ignoring the `shouldLog`\n   * constructor option.\n   * @param args - items to log.\n   */\n  forceError: LoggerForceFn;\n  /**\n   * Prints a log message into the console ignoring the `shouldLog` constructor\n   * option.\n   * @param args - items to log.\n   */\n  forceLog: LoggerForceFn;\n  /**\n   * Prints a warning message into the console ignoring the `shouldLog`\n   * constructor option.\n   * @param args - items to log.\n   */\n  forceWarn: LoggerForceFn;\n  /**\n   * Prints a log message into the console.\n   * @param args - items to log.\n   */\n  log: LoggerFn;\n  /**\n   * Prints a warning message into the console.\n   * @param args - items to log.\n   */\n  warn: LoggerFn;\n}\n\n/*@__NO_SIDE_EFFECTS__*/\nexport function createLogger(scope: string, options?: LoggerOptions): Logger {\n  options ||= {};\n  const {\n    textColor,\n    bgColor,\n    shouldLog: optionsShouldLog,\n  } = options;\n  const shouldLogValue = optionsShouldLog === undefined ? true : optionsShouldLog;\n  const shouldLog = typeof shouldLogValue === 'boolean'\n    ? () => shouldLogValue\n    : shouldLogValue;\n\n  /**\n   * Prints a message into the console.\n   * @param level - log level.\n   * @param force - should `shouldLog` value be ignored.\n   * @param args - arguments.\n   */\n  const print = (level: LogLevel, force: boolean, ...args: any[]): void => {\n    if (force || shouldLog()) {\n      const commonCss = 'font-weight:bold;padding:0 5px;border-radius:100px';\n      const [timeBgColor, timeTextColor, prefix] = {\n        log: ['#0089c3', 'white', 'INFO'],\n        error: ['#ff0000F0', 'white', 'ERR'],\n        warn: ['#D38E15', 'white', 'WARN'],\n      }[level];\n      console[level](\n        `%c${prefix} ${\n          Intl\n            .DateTimeFormat('en-GB', {\n              hour: '2-digit',\n              minute: '2-digit',\n              second: '2-digit',\n              fractionalSecondDigits: 3,\n              timeZone: 'UTC',\n            })\n            .format(new Date())\n        }%c %c${scope}`,\n        `${commonCss};background-color:${timeBgColor};color:${timeTextColor}`,\n        '',\n        `${commonCss};${textColor ? `color:${textColor};` : ''}${bgColor ? `background-color:${bgColor}` : ''}`,\n        ...args,\n      );\n    }\n  };\n\n  return ([\n    ['log', 'forceLog'],\n    ['warn', 'forceWarn'],\n    ['error', 'forceError'],\n  ] as const).reduce<Logger>((acc, [level, forceMethod]) => {\n    acc[level] = print.bind(undefined, level, false);\n    acc[forceMethod] = print.bind(undefined, level, true);\n    return acc;\n  }, {} as Logger);\n}", "// src/storages/globalConfig/globalConfig.ts\nvar store;\nfunction setGlobalConfig(config2) {\n  store = { ...store, ...config2 };\n}\n// @__NO_SIDE_EFFECTS__\nfunction getGlobalConfig(config2) {\n  return {\n    lang: config2?.lang ?? store?.lang,\n    message: config2?.message,\n    abortEarly: config2?.abortEarly ?? store?.abortEarly,\n    abortPipeEarly: config2?.abortPipeEarly ?? store?.abortPipeEarly\n  };\n}\nfunction deleteGlobalConfig() {\n  store = void 0;\n}\n\n// src/storages/globalMessage/globalMessage.ts\nvar store2;\nfunction setGlobalMessage(message, lang) {\n  if (!store2) store2 = /* @__PURE__ */ new Map();\n  store2.set(lang, message);\n}\n// @__NO_SIDE_EFFECTS__\nfunction getGlobalMessage(lang) {\n  return store2?.get(lang);\n}\nfunction deleteGlobalMessage(lang) {\n  store2?.delete(lang);\n}\n\n// src/storages/schemaMessage/schemaMessage.ts\nvar store3;\nfunction setSchemaMessage(message, lang) {\n  if (!store3) store3 = /* @__PURE__ */ new Map();\n  store3.set(lang, message);\n}\n// @__NO_SIDE_EFFECTS__\nfunction getSchemaMessage(lang) {\n  return store3?.get(lang);\n}\nfunction deleteSchemaMessage(lang) {\n  store3?.delete(lang);\n}\n\n// src/storages/specificMessage/specificMessage.ts\nvar store4;\nfunction setSpecificMessage(reference, message, lang) {\n  if (!store4) store4 = /* @__PURE__ */ new Map();\n  if (!store4.get(reference)) store4.set(reference, /* @__PURE__ */ new Map());\n  store4.get(reference).set(lang, message);\n}\n// @__NO_SIDE_EFFECTS__\nfunction getSpecificMessage(reference, lang) {\n  return store4?.get(reference)?.get(lang);\n}\nfunction deleteSpecificMessage(reference, lang) {\n  store4?.get(reference)?.delete(lang);\n}\n\n// src/utils/_stringify/_stringify.ts\n// @__NO_SIDE_EFFECTS__\nfunction _stringify(input) {\n  const type = typeof input;\n  if (type === \"string\") {\n    return `\"${input}\"`;\n  }\n  if (type === \"number\" || type === \"bigint\" || type === \"boolean\") {\n    return `${input}`;\n  }\n  if (type === \"object\" || type === \"function\") {\n    return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? \"null\";\n  }\n  return type;\n}\n\n// src/utils/_addIssue/_addIssue.ts\nfunction _addIssue(context, label, dataset, config2, other) {\n  const input = other && \"input\" in other ? other.input : dataset.value;\n  const expected = other?.expected ?? context.expects ?? null;\n  const received = other?.received ?? _stringify(input);\n  const issue = {\n    kind: context.kind,\n    type: context.type,\n    input,\n    expected,\n    received,\n    message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : \"R\"}eceived ${received}`,\n    requirement: context.requirement,\n    path: other?.path,\n    issues: other?.issues,\n    lang: config2.lang,\n    abortEarly: config2.abortEarly,\n    abortPipeEarly: config2.abortPipeEarly\n  };\n  const isSchema = context.kind === \"schema\";\n  const message = other?.message ?? context.message ?? getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? getSchemaMessage(issue.lang) : null) ?? config2.message ?? getGlobalMessage(issue.lang);\n  if (message) {\n    issue.message = typeof message === \"function\" ? (\n      // @ts-expect-error\n      message(issue)\n    ) : message;\n  }\n  if (isSchema) {\n    dataset.typed = false;\n  }\n  if (dataset.issues) {\n    dataset.issues.push(issue);\n  } else {\n    dataset.issues = [issue];\n  }\n}\n\n// src/utils/_getByteCount/_getByteCount.ts\nvar textEncoder;\n// @__NO_SIDE_EFFECTS__\nfunction _getByteCount(input) {\n  if (!textEncoder) {\n    textEncoder = new TextEncoder();\n  }\n  return textEncoder.encode(input).length;\n}\n\n// src/utils/_getGraphemeCount/_getGraphemeCount.ts\nvar segmenter;\n// @__NO_SIDE_EFFECTS__\nfunction _getGraphemeCount(input) {\n  if (!segmenter) {\n    segmenter = new Intl.Segmenter();\n  }\n  const segments = segmenter.segment(input);\n  let count = 0;\n  for (const _ of segments) {\n    count++;\n  }\n  return count;\n}\n\n// src/utils/_getStandardProps/_getStandardProps.ts\n// @__NO_SIDE_EFFECTS__\nfunction _getStandardProps(context) {\n  return {\n    version: 1,\n    vendor: \"valibot\",\n    validate(value2) {\n      return context[\"~run\"]({ value: value2 }, getGlobalConfig());\n    }\n  };\n}\n\n// src/utils/_getWordCount/_getWordCount.ts\nvar store5;\n// @__NO_SIDE_EFFECTS__\nfunction _getWordCount(locales, input) {\n  if (!store5) {\n    store5 = /* @__PURE__ */ new Map();\n  }\n  if (!store5.get(locales)) {\n    store5.set(locales, new Intl.Segmenter(locales, { granularity: \"word\" }));\n  }\n  const segments = store5.get(locales).segment(input);\n  let count = 0;\n  for (const segment of segments) {\n    if (segment.isWordLike) {\n      count++;\n    }\n  }\n  return count;\n}\n\n// src/utils/_isLuhnAlgo/_isLuhnAlgo.ts\nvar NON_DIGIT_REGEX = /\\D/gu;\n// @__NO_SIDE_EFFECTS__\nfunction _isLuhnAlgo(input) {\n  const number2 = input.replace(NON_DIGIT_REGEX, \"\");\n  let length2 = number2.length;\n  let bit = 1;\n  let sum = 0;\n  while (length2) {\n    const value2 = +number2[--length2];\n    bit ^= 1;\n    sum += bit ? [0, 2, 4, 6, 8, 1, 3, 5, 7, 9][value2] : value2;\n  }\n  return sum % 10 === 0;\n}\n\n// src/utils/_isValidObjectKey/_isValidObjectKey.ts\n// @__NO_SIDE_EFFECTS__\nfunction _isValidObjectKey(object2, key) {\n  return Object.hasOwn(object2, key) && key !== \"__proto__\" && key !== \"prototype\" && key !== \"constructor\";\n}\n\n// src/utils/_joinExpects/_joinExpects.ts\n// @__NO_SIDE_EFFECTS__\nfunction _joinExpects(values, separator) {\n  const list = [...new Set(values)];\n  if (list.length > 1) {\n    return `(${list.join(` ${separator} `)})`;\n  }\n  return list[0] ?? \"never\";\n}\n\n// src/utils/entriesFromList/entriesFromList.ts\n// @__NO_SIDE_EFFECTS__\nfunction entriesFromList(list, schema) {\n  const entries = {};\n  for (const key of list) {\n    entries[key] = schema;\n  }\n  return entries;\n}\n\n// src/utils/getDotPath/getDotPath.ts\n// @__NO_SIDE_EFFECTS__\nfunction getDotPath(issue) {\n  if (issue.path) {\n    let key = \"\";\n    for (const item of issue.path) {\n      if (typeof item.key === \"string\" || typeof item.key === \"number\") {\n        if (key) {\n          key += `.${item.key}`;\n        } else {\n          key += item.key;\n        }\n      } else {\n        return null;\n      }\n    }\n    return key;\n  }\n  return null;\n}\n\n// src/utils/isOfKind/isOfKind.ts\n// @__NO_SIDE_EFFECTS__\nfunction isOfKind(kind, object2) {\n  return object2.kind === kind;\n}\n\n// src/utils/isOfType/isOfType.ts\n// @__NO_SIDE_EFFECTS__\nfunction isOfType(type, object2) {\n  return object2.type === type;\n}\n\n// src/utils/isValiError/isValiError.ts\n// @__NO_SIDE_EFFECTS__\nfunction isValiError(error) {\n  return error instanceof ValiError;\n}\n\n// src/utils/ValiError/ValiError.ts\nvar ValiError = class extends Error {\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(issues) {\n    super(issues[0].message);\n    this.name = \"ValiError\";\n    this.issues = issues;\n  }\n};\n\n// src/actions/args/args.ts\n// @__NO_SIDE_EFFECTS__\nfunction args(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"args\",\n    reference: args,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = (...args_) => {\n        const argsDataset = this.schema[\"~run\"]({ value: args_ }, config2);\n        if (argsDataset.issues) {\n          throw new ValiError(argsDataset.issues);\n        }\n        return func(...argsDataset.value);\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/args/argsAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction argsAsync(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"args\",\n    reference: argsAsync,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = async (...args2) => {\n        const argsDataset = await schema[\"~run\"]({ value: args2 }, config2);\n        if (argsDataset.issues) {\n          throw new ValiError(argsDataset.issues);\n        }\n        return func(...argsDataset.value);\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/await/awaitAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction awaitAsync() {\n  return {\n    kind: \"transformation\",\n    type: \"await\",\n    reference: awaitAsync,\n    async: true,\n    async \"~run\"(dataset) {\n      dataset.value = await dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/regex.ts\nvar BASE64_REGEX = /^(?:[\\da-z+/]{4})*(?:[\\da-z+/]{2}==|[\\da-z+/]{3}=)?$/iu;\nvar BIC_REGEX = /^[A-Z]{6}(?!00)[\\dA-Z]{2}(?:[\\dA-Z]{3})?$/u;\nvar CUID2_REGEX = /^[a-z][\\da-z]*$/u;\nvar DECIMAL_REGEX = /^[+-]?\\d+(?:\\.\\d+)?$/u;\nvar DIGITS_REGEX = /^\\d+$/u;\nvar EMAIL_REGEX = /^[\\w+-]+(?:\\.[\\w+-]+)*@[\\da-z]+(?:[.-][\\da-z]+)*\\.[a-z]{2,}$/iu;\nvar EMOJI_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex, regexp/no-dupe-disjunctions -- false positives\n  /^(?:[\\u{1F1E6}-\\u{1F1FF}]{2}|\\u{1F3F4}[\\u{E0061}-\\u{E007A}]{2}[\\u{E0030}-\\u{E0039}\\u{E0061}-\\u{E007A}]{1,3}\\u{E007F}|(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation})(?:\\u200D(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation}))*)+$/u\n);\nvar HEXADECIMAL_REGEX = /^(?:0[hx])?[\\da-fA-F]+$/u;\nvar HEX_COLOR_REGEX = /^#(?:[\\da-fA-F]{3,4}|[\\da-fA-F]{6}|[\\da-fA-F]{8})$/u;\nvar IMEI_REGEX = /^\\d{15}$|^\\d{2}-\\d{6}-\\d{6}-\\d$/u;\nvar IPV4_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive\n  /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$/u\n);\nvar IPV6_REGEX = /^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar IP_REGEX = /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$|^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar ISO_DATE_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])$/u;\nvar ISO_DATE_TIME_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_REGEX = /^(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_SECOND_REGEX = /^(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}$/u;\nvar ISO_TIMESTAMP_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}(?:\\.\\d{1,9})?(?:Z|[+-](?:0\\d|1\\d|2[0-3])(?::?[0-5]\\d)?)$/u;\nvar ISO_WEEK_REGEX = /^\\d{4}-W(?:0[1-9]|[1-4]\\d|5[0-3])$/u;\nvar MAC48_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$/iu;\nvar MAC64_REGEX = /^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar MAC_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$|^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar NANO_ID_REGEX = /^[\\w-]+$/u;\nvar OCTAL_REGEX = /^(?:0o)?[0-7]+$/u;\nvar RFC_EMAIL_REGEX = /^[\\w.!#$%&'*+/=?^`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/iu;\nvar ULID_REGEX = /^[\\da-hjkmnp-tv-zA-HJKMNP-TV-Z]{26}$/u;\nvar UUID_REGEX = /^[\\da-f]{8}(?:-[\\da-f]{4}){3}-[\\da-f]{12}$/iu;\n\n// src/actions/base64/base64.ts\n// @__NO_SIDE_EFFECTS__\nfunction base64(message) {\n  return {\n    kind: \"validation\",\n    type: \"base64\",\n    reference: base64,\n    async: false,\n    expects: null,\n    requirement: BASE64_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Base64\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/bic/bic.ts\n// @__NO_SIDE_EFFECTS__\nfunction bic(message) {\n  return {\n    kind: \"validation\",\n    type: \"bic\",\n    reference: bic,\n    async: false,\n    expects: null,\n    requirement: BIC_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"BIC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/brand/brand.ts\n// @__NO_SIDE_EFFECTS__\nfunction brand(name) {\n  return {\n    kind: \"transformation\",\n    type: \"brand\",\n    reference: brand,\n    async: false,\n    name,\n    \"~run\"(dataset) {\n      return dataset;\n    }\n  };\n}\n\n// src/actions/bytes/bytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction bytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"bytes\",\n    reference: bytes,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 !== this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/check/check.ts\n// @__NO_SIDE_EFFECTS__\nfunction check(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: check,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/check/checkAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction checkAsync(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: checkAsync,\n    async: true,\n    expects: null,\n    requirement,\n    message,\n    async \"~run\"(dataset, config2) {\n      if (dataset.typed && !await this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/checkItems/checkItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction checkItems(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check_items\",\n    reference: checkItems,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        for (let index = 0; index < dataset.value.length; index++) {\n          const item = dataset.value[index];\n          if (!this.requirement(item, index, dataset.value)) {\n            _addIssue(this, \"item\", dataset, config2, {\n              input: item,\n              path: [\n                {\n                  type: \"array\",\n                  origin: \"value\",\n                  input: dataset.value,\n                  key: index,\n                  value: item\n                }\n              ]\n            });\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/checkItems/checkItemsAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction checkItemsAsync(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check_items\",\n    reference: checkItemsAsync,\n    async: true,\n    expects: null,\n    requirement,\n    message,\n    async \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const requirementResults = await Promise.all(\n          dataset.value.map(this.requirement)\n        );\n        for (let index = 0; index < dataset.value.length; index++) {\n          if (!requirementResults[index]) {\n            const item = dataset.value[index];\n            _addIssue(this, \"item\", dataset, config2, {\n              input: item,\n              path: [\n                {\n                  type: \"array\",\n                  origin: \"value\",\n                  input: dataset.value,\n                  key: index,\n                  value: item\n                }\n              ]\n            });\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/creditCard/creditCard.ts\nvar CREDIT_CARD_REGEX = /^(?:\\d{14,19}|\\d{4}(?: \\d{3,6}){2,4}|\\d{4}(?:-\\d{3,6}){2,4})$/u;\nvar SANITIZE_REGEX = /[- ]/gu;\nvar PROVIDER_REGEX_LIST = [\n  // American Express\n  /^3[47]\\d{13}$/u,\n  // Diners Club\n  /^3(?:0[0-5]|[68]\\d)\\d{11,13}$/u,\n  // Discover\n  /^6(?:011|5\\d{2})\\d{12,15}$/u,\n  // JCB\n  /^(?:2131|1800|35\\d{3})\\d{11}$/u,\n  // Mastercard\n  // eslint-disable-next-line redos-detector/no-unsafe-regex\n  /^5[1-5]\\d{2}|(?:222\\d|22[3-9]\\d|2[3-6]\\d{2}|27[01]\\d|2720)\\d{12}$/u,\n  // UnionPay\n  /^(?:6[27]\\d{14,17}|81\\d{14,17})$/u,\n  // Visa\n  /^4\\d{12}(?:\\d{3,6})?$/u\n];\n// @__NO_SIDE_EFFECTS__\nfunction creditCard(message) {\n  return {\n    kind: \"validation\",\n    type: \"credit_card\",\n    reference: creditCard,\n    async: false,\n    expects: null,\n    requirement(input) {\n      let sanitized;\n      return CREDIT_CARD_REGEX.test(input) && // Remove any hyphens and blanks\n      (sanitized = input.replace(SANITIZE_REGEX, \"\")) && // Check if it matches a provider\n      PROVIDER_REGEX_LIST.some((regex2) => regex2.test(sanitized)) && // Check if passes luhn algorithm\n      _isLuhnAlgo(sanitized);\n    },\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"credit card\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/cuid2/cuid2.ts\n// @__NO_SIDE_EFFECTS__\nfunction cuid2(message) {\n  return {\n    kind: \"validation\",\n    type: \"cuid2\",\n    reference: cuid2,\n    async: false,\n    expects: null,\n    requirement: CUID2_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Cuid2\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/decimal/decimal.ts\n// @__NO_SIDE_EFFECTS__\nfunction decimal(message) {\n  return {\n    kind: \"validation\",\n    type: \"decimal\",\n    reference: decimal,\n    async: false,\n    expects: null,\n    requirement: DECIMAL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"decimal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/description/description.ts\n// @__NO_SIDE_EFFECTS__\nfunction description(description_) {\n  return {\n    kind: \"metadata\",\n    type: \"description\",\n    reference: description,\n    description: description_\n  };\n}\n\n// src/actions/digits/digits.ts\n// @__NO_SIDE_EFFECTS__\nfunction digits(message) {\n  return {\n    kind: \"validation\",\n    type: \"digits\",\n    reference: digits,\n    async: false,\n    expects: null,\n    requirement: DIGITS_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"digits\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/email/email.ts\n// @__NO_SIDE_EFFECTS__\nfunction email(message) {\n  return {\n    kind: \"validation\",\n    type: \"email\",\n    reference: email,\n    expects: null,\n    async: false,\n    requirement: EMAIL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"email\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/emoji/emoji.ts\n// @__NO_SIDE_EFFECTS__\nfunction emoji(message) {\n  return {\n    kind: \"validation\",\n    type: \"emoji\",\n    reference: emoji,\n    async: false,\n    expects: null,\n    requirement: EMOJI_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"emoji\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/empty/empty.ts\n// @__NO_SIDE_EFFECTS__\nfunction empty(message) {\n  return {\n    kind: \"validation\",\n    type: \"empty\",\n    reference: empty,\n    async: false,\n    expects: \"0\",\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length > 0) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/endsWith/endsWith.ts\n// @__NO_SIDE_EFFECTS__\nfunction endsWith(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"ends_with\",\n    reference: endsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.endsWith(this.requirement)) {\n        _addIssue(this, \"end\", dataset, config2, {\n          received: `\"${dataset.value.slice(-this.requirement.length)}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/everyItem/everyItem.ts\n// @__NO_SIDE_EFFECTS__\nfunction everyItem(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"every_item\",\n    reference: everyItem,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.every(this.requirement)) {\n        _addIssue(this, \"item\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/excludes/excludes.ts\n// @__NO_SIDE_EFFECTS__\nfunction excludes(requirement, message) {\n  const received = _stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"excludes\",\n    reference: excludes,\n    async: false,\n    expects: `!${received}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.includes(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2, { received });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/filterItems/filterItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction filterItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"filter_items\",\n    reference: filterItems,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.filter(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/findItem/findItem.ts\n// @__NO_SIDE_EFFECTS__\nfunction findItem(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"find_item\",\n    reference: findItem,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.find(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/finite/finite.ts\n// @__NO_SIDE_EFFECTS__\nfunction finite(message) {\n  return {\n    kind: \"validation\",\n    type: \"finite\",\n    reference: finite,\n    async: false,\n    expects: null,\n    requirement: Number.isFinite,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"finite\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/graphemes/graphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction graphemes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"graphemes\",\n    reference: graphemes,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count !== this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hash/hash.ts\nvar HASH_LENGTHS = {\n  md4: 32,\n  md5: 32,\n  sha1: 40,\n  sha256: 64,\n  sha384: 96,\n  sha512: 128,\n  ripemd128: 32,\n  ripemd160: 40,\n  tiger128: 32,\n  tiger160: 40,\n  tiger192: 48,\n  crc32: 8,\n  crc32b: 8,\n  adler32: 8\n};\n// @__NO_SIDE_EFFECTS__\nfunction hash(types, message) {\n  return {\n    kind: \"validation\",\n    type: \"hash\",\n    reference: hash,\n    expects: null,\n    async: false,\n    requirement: RegExp(\n      types.map((type) => `^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join(\"|\"),\n      \"iu\"\n    ),\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hash\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hexadecimal/hexadecimal.ts\n// @__NO_SIDE_EFFECTS__\nfunction hexadecimal(message) {\n  return {\n    kind: \"validation\",\n    type: \"hexadecimal\",\n    reference: hexadecimal,\n    async: false,\n    expects: null,\n    requirement: HEXADECIMAL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hexadecimal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hexColor/hexColor.ts\n// @__NO_SIDE_EFFECTS__\nfunction hexColor(message) {\n  return {\n    kind: \"validation\",\n    type: \"hex_color\",\n    reference: hexColor,\n    async: false,\n    expects: null,\n    requirement: HEX_COLOR_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hex color\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/imei/imei.ts\n// @__NO_SIDE_EFFECTS__\nfunction imei(message) {\n  return {\n    kind: \"validation\",\n    type: \"imei\",\n    reference: imei,\n    async: false,\n    expects: null,\n    requirement(input) {\n      return IMEI_REGEX.test(input) && _isLuhnAlgo(input);\n    },\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"IMEI\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/includes/includes.ts\n// @__NO_SIDE_EFFECTS__\nfunction includes(requirement, message) {\n  const expects = _stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"includes\",\n    reference: includes,\n    async: false,\n    expects,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.includes(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2, {\n          received: `!${expects}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/integer/integer.ts\n// @__NO_SIDE_EFFECTS__\nfunction integer(message) {\n  return {\n    kind: \"validation\",\n    type: \"integer\",\n    reference: integer,\n    async: false,\n    expects: null,\n    requirement: Number.isInteger,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"integer\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ip/ip.ts\n// @__NO_SIDE_EFFECTS__\nfunction ip(message) {\n  return {\n    kind: \"validation\",\n    type: \"ip\",\n    reference: ip,\n    async: false,\n    expects: null,\n    requirement: IP_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IP\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ipv4/ipv4.ts\n// @__NO_SIDE_EFFECTS__\nfunction ipv4(message) {\n  return {\n    kind: \"validation\",\n    type: \"ipv4\",\n    reference: ipv4,\n    async: false,\n    expects: null,\n    requirement: IPV4_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IPv4\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ipv6/ipv6.ts\n// @__NO_SIDE_EFFECTS__\nfunction ipv6(message) {\n  return {\n    kind: \"validation\",\n    type: \"ipv6\",\n    reference: ipv6,\n    async: false,\n    expects: null,\n    requirement: IPV6_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IPv6\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoDate/isoDate.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoDate(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date\",\n    reference: isoDate,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"date\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoDateTime/isoDateTime.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoDateTime(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date_time\",\n    reference: isoDateTime,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_TIME_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"date-time\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTime/isoTime.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoTime(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time\",\n    reference: isoTime,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"time\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTimeSecond/isoTimeSecond.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoTimeSecond(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time_second\",\n    reference: isoTimeSecond,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_SECOND_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"time-second\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTimestamp/isoTimestamp.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoTimestamp(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_timestamp\",\n    reference: isoTimestamp,\n    async: false,\n    expects: null,\n    requirement: ISO_TIMESTAMP_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"timestamp\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoWeek/isoWeek.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoWeek(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_week\",\n    reference: isoWeek,\n    async: false,\n    expects: null,\n    requirement: ISO_WEEK_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"week\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/length/length.ts\n// @__NO_SIDE_EFFECTS__\nfunction length(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"length\",\n    reference: length,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length !== this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac/mac.ts\n// @__NO_SIDE_EFFECTS__\nfunction mac(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac\",\n    reference: mac,\n    async: false,\n    expects: null,\n    requirement: MAC_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac48/mac48.ts\n// @__NO_SIDE_EFFECTS__\nfunction mac48(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac48\",\n    reference: mac48,\n    async: false,\n    expects: null,\n    requirement: MAC48_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"48-bit MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac64/mac64.ts\n// @__NO_SIDE_EFFECTS__\nfunction mac64(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac64\",\n    reference: mac64,\n    async: false,\n    expects: null,\n    requirement: MAC64_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"64-bit MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mapItems/mapItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction mapItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"map_items\",\n    reference: mapItems,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.map(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxBytes/maxBytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_bytes\",\n    reference: maxBytes,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 > this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxGraphemes/maxGraphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxGraphemes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_graphemes\",\n    reference: maxGraphemes,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count > this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxLength/maxLength.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_length\",\n    reference: maxLength,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length > this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxSize/maxSize.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_size\",\n    reference: maxSize,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size > this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxValue/maxValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_value\",\n    reference: maxValue,\n    async: false,\n    expects: `<=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(dataset.value <= this.requirement)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxWords/maxWords.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxWords(locales, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_words\",\n    reference: maxWords,\n    async: false,\n    expects: `<=${requirement}`,\n    locales,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count > this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/metadata/metadata.ts\n// @__NO_SIDE_EFFECTS__\nfunction metadata(metadata_) {\n  return {\n    kind: \"metadata\",\n    type: \"metadata\",\n    reference: metadata,\n    metadata: metadata_\n  };\n}\n\n// src/actions/mimeType/mimeType.ts\n// @__NO_SIDE_EFFECTS__\nfunction mimeType(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"mime_type\",\n    reference: mimeType,\n    async: false,\n    expects: _joinExpects(\n      requirement.map((option) => `\"${option}\"`),\n      \"|\"\n    ),\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.includes(dataset.value.type)) {\n        _addIssue(this, \"MIME type\", dataset, config2, {\n          received: `\"${dataset.value.type}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minBytes/minBytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction minBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_bytes\",\n    reference: minBytes,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 < this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minGraphemes/minGraphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction minGraphemes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_graphemes\",\n    reference: minGraphemes,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count < this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minLength/minLength.ts\n// @__NO_SIDE_EFFECTS__\nfunction minLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_length\",\n    reference: minLength,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length < this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minSize/minSize.ts\n// @__NO_SIDE_EFFECTS__\nfunction minSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_size\",\n    reference: minSize,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size < this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minValue/minValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction minValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_value\",\n    reference: minValue,\n    async: false,\n    expects: `>=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(dataset.value >= this.requirement)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minWords/minWords.ts\n// @__NO_SIDE_EFFECTS__\nfunction minWords(locales, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_words\",\n    reference: minWords,\n    async: false,\n    expects: `>=${requirement}`,\n    locales,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count < this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/multipleOf/multipleOf.ts\n// @__NO_SIDE_EFFECTS__\nfunction multipleOf(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"multiple_of\",\n    reference: multipleOf,\n    async: false,\n    expects: `%${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value % this.requirement !== 0) {\n        _addIssue(this, \"multiple\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/nanoid/nanoid.ts\n// @__NO_SIDE_EFFECTS__\nfunction nanoid(message) {\n  return {\n    kind: \"validation\",\n    type: \"nanoid\",\n    reference: nanoid,\n    async: false,\n    expects: null,\n    requirement: NANO_ID_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Nano ID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/nonEmpty/nonEmpty.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonEmpty(message) {\n  return {\n    kind: \"validation\",\n    type: \"non_empty\",\n    reference: nonEmpty,\n    async: false,\n    expects: \"!0\",\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length === 0) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: \"0\"\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/normalize/normalize.ts\n// @__NO_SIDE_EFFECTS__\nfunction normalize(form) {\n  return {\n    kind: \"transformation\",\n    type: \"normalize\",\n    reference: normalize,\n    async: false,\n    form,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.normalize(this.form);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notBytes/notBytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction notBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_bytes\",\n    reference: notBytes,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 === this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notGraphemes/notGraphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction notGraphemes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_graphemes\",\n    reference: notGraphemes,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count === this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notLength/notLength.ts\n// @__NO_SIDE_EFFECTS__\nfunction notLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_length\",\n    reference: notLength,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length === this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notSize/notSize.ts\n// @__NO_SIDE_EFFECTS__\nfunction notSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_size\",\n    reference: notSize,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size === this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notValue/notValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction notValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_value\",\n    reference: notValue,\n    async: false,\n    expects: requirement instanceof Date ? `!${requirement.toJSON()}` : `!${_stringify(requirement)}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notWords/notWords.ts\n// @__NO_SIDE_EFFECTS__\nfunction notWords(locales, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_words\",\n    reference: notWords,\n    async: false,\n    expects: `!${requirement}`,\n    locales,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count === this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/octal/octal.ts\n// @__NO_SIDE_EFFECTS__\nfunction octal(message) {\n  return {\n    kind: \"validation\",\n    type: \"octal\",\n    reference: octal,\n    async: false,\n    expects: null,\n    requirement: OCTAL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"octal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/partialCheck/utils/_isPartiallyTyped/_isPartiallyTyped.ts\n// @__NO_SIDE_EFFECTS__\nfunction _isPartiallyTyped(dataset, pathList) {\n  if (dataset.issues) {\n    for (const path of pathList) {\n      for (const issue of dataset.issues) {\n        let typed = false;\n        const bound = Math.min(path.length, issue.path?.length ?? 0);\n        for (let index = 0; index < bound; index++) {\n          if (path[index] !== issue.path[index].key) {\n            typed = true;\n            break;\n          }\n        }\n        if (!typed) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\n// src/actions/partialCheck/partialCheck.ts\n// @__NO_SIDE_EFFECTS__\nfunction partialCheck(pathList, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"partial_check\",\n    reference: partialCheck,\n    async: false,\n    expects: null,\n    pathList,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (_isPartiallyTyped(dataset, pathList) && // @ts-expect-error\n      !this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/partialCheck/partialCheckAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction partialCheckAsync(pathList, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"partial_check\",\n    reference: partialCheckAsync,\n    async: true,\n    expects: null,\n    pathList,\n    requirement,\n    message,\n    async \"~run\"(dataset, config2) {\n      if (_isPartiallyTyped(dataset, pathList) && // @ts-expect-error\n      !await this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawCheck/rawCheck.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawCheck(action) {\n  return {\n    kind: \"validation\",\n    type: \"raw_check\",\n    reference: rawCheck,\n    async: false,\n    expects: null,\n    \"~run\"(dataset, config2) {\n      action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info)\n      });\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawCheck/rawCheckAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawCheckAsync(action) {\n  return {\n    kind: \"validation\",\n    type: \"raw_check\",\n    reference: rawCheckAsync,\n    async: true,\n    expects: null,\n    async \"~run\"(dataset, config2) {\n      await action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info)\n      });\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawTransform/rawTransform.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawTransform(action) {\n  return {\n    kind: \"transformation\",\n    type: \"raw_transform\",\n    reference: rawTransform,\n    async: false,\n    \"~run\"(dataset, config2) {\n      const output = action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info),\n        NEVER: null\n      });\n      if (dataset.issues) {\n        dataset.typed = false;\n      } else {\n        dataset.value = output;\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawTransform/rawTransformAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawTransformAsync(action) {\n  return {\n    kind: \"transformation\",\n    type: \"raw_transform\",\n    reference: rawTransformAsync,\n    async: true,\n    async \"~run\"(dataset, config2) {\n      const output = await action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info),\n        NEVER: null\n      });\n      if (dataset.issues) {\n        dataset.typed = false;\n      } else {\n        dataset.value = output;\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/readonly/readonly.ts\n// @__NO_SIDE_EFFECTS__\nfunction readonly() {\n  return {\n    kind: \"transformation\",\n    type: \"readonly\",\n    reference: readonly,\n    async: false,\n    \"~run\"(dataset) {\n      return dataset;\n    }\n  };\n}\n\n// src/actions/reduceItems/reduceItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction reduceItems(operation, initial) {\n  return {\n    kind: \"transformation\",\n    type: \"reduce_items\",\n    reference: reduceItems,\n    async: false,\n    operation,\n    initial,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.reduce(this.operation, this.initial);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/regex/regex.ts\n// @__NO_SIDE_EFFECTS__\nfunction regex(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"regex\",\n    reference: regex,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"format\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/returns/returns.ts\n// @__NO_SIDE_EFFECTS__\nfunction returns(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"returns\",\n    reference: returns,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = (...args_) => {\n        const returnsDataset = this.schema[\"~run\"](\n          { value: func(...args_) },\n          config2\n        );\n        if (returnsDataset.issues) {\n          throw new ValiError(returnsDataset.issues);\n        }\n        return returnsDataset.value;\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/returns/returnsAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction returnsAsync(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"returns\",\n    reference: returnsAsync,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = async (...args_) => {\n        const returnsDataset = await this.schema[\"~run\"](\n          { value: await func(...args_) },\n          config2\n        );\n        if (returnsDataset.issues) {\n          throw new ValiError(returnsDataset.issues);\n        }\n        return returnsDataset.value;\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rfcEmail/rfcEmail.ts\n// @__NO_SIDE_EFFECTS__\nfunction rfcEmail(message) {\n  return {\n    kind: \"validation\",\n    type: \"rfc_email\",\n    reference: rfcEmail,\n    expects: null,\n    async: false,\n    requirement: RFC_EMAIL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"email\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/safeInteger/safeInteger.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeInteger(message) {\n  return {\n    kind: \"validation\",\n    type: \"safe_integer\",\n    reference: safeInteger,\n    async: false,\n    expects: null,\n    requirement: Number.isSafeInteger,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"safe integer\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/size/size.ts\n// @__NO_SIDE_EFFECTS__\nfunction size(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"size\",\n    reference: size,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size !== this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/someItem/someItem.ts\n// @__NO_SIDE_EFFECTS__\nfunction someItem(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"some_item\",\n    reference: someItem,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.some(this.requirement)) {\n        _addIssue(this, \"item\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/sortItems/sortItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction sortItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"sort_items\",\n    reference: sortItems,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.sort(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/startsWith/startsWith.ts\n// @__NO_SIDE_EFFECTS__\nfunction startsWith(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"starts_with\",\n    reference: startsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.startsWith(this.requirement)) {\n        _addIssue(this, \"start\", dataset, config2, {\n          received: `\"${dataset.value.slice(0, this.requirement.length)}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/title/title.ts\n// @__NO_SIDE_EFFECTS__\nfunction title(title_) {\n  return {\n    kind: \"metadata\",\n    type: \"title\",\n    reference: title,\n    title: title_\n  };\n}\n\n// src/actions/toLowerCase/toLowerCase.ts\n// @__NO_SIDE_EFFECTS__\nfunction toLowerCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_lower_case\",\n    reference: toLowerCase,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.toLowerCase();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toMaxValue/toMaxValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction toMaxValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_max_value\",\n    reference: toMaxValue,\n    async: false,\n    requirement,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toMinValue/toMinValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction toMinValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_min_value\",\n    reference: toMinValue,\n    async: false,\n    requirement,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toUpperCase/toUpperCase.ts\n// @__NO_SIDE_EFFECTS__\nfunction toUpperCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_upper_case\",\n    reference: toUpperCase,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.toUpperCase();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/transform/transform.ts\n// @__NO_SIDE_EFFECTS__\nfunction transform(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transform,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = this.operation(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/transform/transformAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction transformAsync(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transformAsync,\n    async: true,\n    operation,\n    async \"~run\"(dataset) {\n      dataset.value = await this.operation(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trim/trim.ts\n// @__NO_SIDE_EFFECTS__\nfunction trim() {\n  return {\n    kind: \"transformation\",\n    type: \"trim\",\n    reference: trim,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.trim();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trimEnd/trimEnd.ts\n// @__NO_SIDE_EFFECTS__\nfunction trimEnd() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_end\",\n    reference: trimEnd,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.trimEnd();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trimStart/trimStart.ts\n// @__NO_SIDE_EFFECTS__\nfunction trimStart() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_start\",\n    reference: trimStart,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.trimStart();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ulid/ulid.ts\n// @__NO_SIDE_EFFECTS__\nfunction ulid(message) {\n  return {\n    kind: \"validation\",\n    type: \"ulid\",\n    reference: ulid,\n    async: false,\n    expects: null,\n    requirement: ULID_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"ULID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/url/url.ts\n// @__NO_SIDE_EFFECTS__\nfunction url(message) {\n  return {\n    kind: \"validation\",\n    type: \"url\",\n    reference: url,\n    async: false,\n    expects: null,\n    requirement(input) {\n      try {\n        new URL(input);\n        return true;\n      } catch {\n        return false;\n      }\n    },\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"URL\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/uuid/uuid.ts\n// @__NO_SIDE_EFFECTS__\nfunction uuid(message) {\n  return {\n    kind: \"validation\",\n    type: \"uuid\",\n    reference: uuid,\n    async: false,\n    expects: null,\n    requirement: UUID_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"UUID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/value/value.ts\n// @__NO_SIDE_EFFECTS__\nfunction value(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"value\",\n    reference: value,\n    async: false,\n    expects: requirement instanceof Date ? requirement.toJSON() : _stringify(requirement),\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/words/words.ts\n// @__NO_SIDE_EFFECTS__\nfunction words(locales, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"words\",\n    reference: words,\n    async: false,\n    expects: `${requirement}`,\n    locales,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count !== this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/assert/assert.ts\nfunction assert(schema, input) {\n  const issues = schema[\"~run\"]({ value: input }, { abortEarly: true }).issues;\n  if (issues) {\n    throw new ValiError(issues);\n  }\n}\n\n// src/methods/config/config.ts\n// @__NO_SIDE_EFFECTS__\nfunction config(schema, config2) {\n  return {\n    ...schema,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config_) {\n      return schema[\"~run\"](dataset, { ...config_, ...config2 });\n    }\n  };\n}\n\n// src/methods/getFallback/getFallback.ts\n// @__NO_SIDE_EFFECTS__\nfunction getFallback(schema, dataset, config2) {\n  return typeof schema.fallback === \"function\" ? (\n    // @ts-expect-error\n    schema.fallback(dataset, config2)\n  ) : (\n    // @ts-expect-error\n    schema.fallback\n  );\n}\n\n// src/methods/fallback/fallback.ts\n// @__NO_SIDE_EFFECTS__\nfunction fallback(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const outputDataset = schema[\"~run\"](dataset, config2);\n      return outputDataset.issues ? { typed: true, value: getFallback(this, outputDataset, config2) } : outputDataset;\n    }\n  };\n}\n\n// src/methods/fallback/fallbackAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction fallbackAsync(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    async: true,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const outputDataset = await schema[\"~run\"](dataset, config2);\n      return outputDataset.issues ? {\n        typed: true,\n        value: await getFallback(this, outputDataset, config2)\n      } : outputDataset;\n    }\n  };\n}\n\n// src/methods/flatten/flatten.ts\n// @__NO_SIDE_EFFECTS__\nfunction flatten(issues) {\n  const flatErrors = {};\n  for (const issue of issues) {\n    if (issue.path) {\n      const dotPath = getDotPath(issue);\n      if (dotPath) {\n        if (!flatErrors.nested) {\n          flatErrors.nested = {};\n        }\n        if (flatErrors.nested[dotPath]) {\n          flatErrors.nested[dotPath].push(issue.message);\n        } else {\n          flatErrors.nested[dotPath] = [issue.message];\n        }\n      } else {\n        if (flatErrors.other) {\n          flatErrors.other.push(issue.message);\n        } else {\n          flatErrors.other = [issue.message];\n        }\n      }\n    } else {\n      if (flatErrors.root) {\n        flatErrors.root.push(issue.message);\n      } else {\n        flatErrors.root = [issue.message];\n      }\n    }\n  }\n  return flatErrors;\n}\n\n// src/methods/forward/forward.ts\n// @__NO_SIDE_EFFECTS__\nfunction forward(action, pathKeys) {\n  return {\n    ...action,\n    \"~run\"(dataset, config2) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      dataset = action[\"~run\"](dataset, config2);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) {\n          if (!prevIssues?.includes(issue)) {\n            let pathInput = dataset.value;\n            for (const key of pathKeys) {\n              const pathValue = pathInput[key];\n              const pathItem = {\n                type: \"unknown\",\n                origin: \"value\",\n                input: pathInput,\n                key,\n                value: pathValue\n              };\n              if (issue.path) {\n                issue.path.push(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              if (!pathValue) {\n                break;\n              }\n              pathInput = pathValue;\n            }\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/forward/forwardAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction forwardAsync(action, pathKeys) {\n  return {\n    ...action,\n    async: true,\n    async \"~run\"(dataset, config2) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      dataset = await action[\"~run\"](dataset, config2);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) {\n          if (!prevIssues?.includes(issue)) {\n            let pathInput = dataset.value;\n            for (const key of pathKeys) {\n              const pathValue = pathInput[key];\n              const pathItem = {\n                type: \"unknown\",\n                origin: \"value\",\n                input: pathInput,\n                key,\n                value: pathValue\n              };\n              if (issue.path) {\n                issue.path.push(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              if (!pathValue) {\n                break;\n              }\n              pathInput = pathValue;\n            }\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/getDefault/getDefault.ts\n// @__NO_SIDE_EFFECTS__\nfunction getDefault(schema, dataset, config2) {\n  return typeof schema.default === \"function\" ? (\n    // @ts-expect-error\n    schema.default(dataset, config2)\n  ) : (\n    // @ts-expect-error\n    schema.default\n  );\n}\n\n// src/methods/getDefaults/getDefaults.ts\n// @__NO_SIDE_EFFECTS__\nfunction getDefaults(schema) {\n  if (\"entries\" in schema) {\n    const object2 = {};\n    for (const key in schema.entries) {\n      object2[key] = /* @__PURE__ */ getDefaults(schema.entries[key]);\n    }\n    return object2;\n  }\n  if (\"items\" in schema) {\n    return schema.items.map(getDefaults);\n  }\n  return getDefault(schema);\n}\n\n// src/methods/getDefaults/getDefaultsAsync.ts\n// @__NO_SIDE_EFFECTS__\nasync function getDefaultsAsync(schema) {\n  if (\"entries\" in schema) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await /* @__PURE__ */ getDefaultsAsync(value2)\n        ])\n      )\n    );\n  }\n  if (\"items\" in schema) {\n    return Promise.all(schema.items.map(getDefaultsAsync));\n  }\n  return getDefault(schema);\n}\n\n// src/methods/getFallbacks/getFallbacks.ts\n// @__NO_SIDE_EFFECTS__\nfunction getFallbacks(schema) {\n  if (\"entries\" in schema) {\n    const object2 = {};\n    for (const key in schema.entries) {\n      object2[key] = /* @__PURE__ */ getFallbacks(schema.entries[key]);\n    }\n    return object2;\n  }\n  if (\"items\" in schema) {\n    return schema.items.map(getFallbacks);\n  }\n  return getFallback(schema);\n}\n\n// src/methods/getFallbacks/getFallbacksAsync.ts\n// @__NO_SIDE_EFFECTS__\nasync function getFallbacksAsync(schema) {\n  if (\"entries\" in schema) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await /* @__PURE__ */ getFallbacksAsync(value2)\n        ])\n      )\n    );\n  }\n  if (\"items\" in schema) {\n    return Promise.all(schema.items.map(getFallbacksAsync));\n  }\n  return getFallback(schema);\n}\n\n// src/methods/is/is.ts\n// @__NO_SIDE_EFFECTS__\nfunction is(schema, input) {\n  return !schema[\"~run\"]({ value: input }, { abortEarly: true }).issues;\n}\n\n// src/schemas/any/any.ts\n// @__NO_SIDE_EFFECTS__\nfunction any() {\n  return {\n    kind: \"schema\",\n    type: \"any\",\n    reference: any,\n    expects: \"any\",\n    async: false,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/array/array.ts\n// @__NO_SIDE_EFFECTS__\nfunction array(item, message) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: array,\n    expects: \"Array\",\n    async: false,\n    item,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < input.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.item[\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/array/arrayAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction arrayAsync(item, message) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: arrayAsync,\n    expects: \"Array\",\n    async: true,\n    item,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          input.map((value2) => this.item[\"~run\"]({ value: value2 }, config2))\n        );\n        for (let key = 0; key < itemDatasets.length; key++) {\n          const itemDataset = itemDatasets[key];\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: input[key]\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/bigint/bigint.ts\n// @__NO_SIDE_EFFECTS__\nfunction bigint(message) {\n  return {\n    kind: \"schema\",\n    type: \"bigint\",\n    reference: bigint,\n    expects: \"bigint\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"bigint\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/blob/blob.ts\n// @__NO_SIDE_EFFECTS__\nfunction blob(message) {\n  return {\n    kind: \"schema\",\n    type: \"blob\",\n    reference: blob,\n    expects: \"Blob\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof Blob) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/boolean/boolean.ts\n// @__NO_SIDE_EFFECTS__\nfunction boolean(message) {\n  return {\n    kind: \"schema\",\n    type: \"boolean\",\n    reference: boolean,\n    expects: \"boolean\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"boolean\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/custom/custom.ts\n// @__NO_SIDE_EFFECTS__\nfunction custom(check2, message) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: custom,\n    expects: \"unknown\",\n    async: false,\n    check: check2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.check(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/custom/customAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction customAsync(check2, message) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: customAsync,\n    expects: \"unknown\",\n    async: true,\n    check: check2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (await this.check(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/date/date.ts\n// @__NO_SIDE_EFFECTS__\nfunction date(message) {\n  return {\n    kind: \"schema\",\n    type: \"date\",\n    reference: date,\n    expects: \"Date\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof Date) {\n        if (!isNaN(dataset.value)) {\n          dataset.typed = true;\n        } else {\n          _addIssue(this, \"type\", dataset, config2, {\n            received: '\"Invalid Date\"'\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/enum/enum.ts\n// @__NO_SIDE_EFFECTS__\nfunction enum_(enum__, message) {\n  const options = [];\n  for (const key in enum__) {\n    if (`${+key}` !== key || typeof enum__[key] !== \"string\" || !Object.is(enum__[enum__[key]], +key)) {\n      options.push(enum__[key]);\n    }\n  }\n  return {\n    kind: \"schema\",\n    type: \"enum\",\n    reference: enum_,\n    expects: _joinExpects(options.map(_stringify), \"|\"),\n    async: false,\n    enum: enum__,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.options.includes(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/exactOptional/exactOptional.ts\n// @__NO_SIDE_EFFECTS__\nfunction exactOptional(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"exact_optional\",\n    reference: exactOptional,\n    expects: wrapped.expects,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/exactOptional/exactOptionalAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction exactOptionalAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"exact_optional\",\n    reference: exactOptionalAsync,\n    expects: wrapped.expects,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/file/file.ts\n// @__NO_SIDE_EFFECTS__\nfunction file(message) {\n  return {\n    kind: \"schema\",\n    type: \"file\",\n    reference: file,\n    expects: \"File\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof File) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/function/function.ts\n// @__NO_SIDE_EFFECTS__\nfunction function_(message) {\n  return {\n    kind: \"schema\",\n    type: \"function\",\n    reference: function_,\n    expects: \"Function\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"function\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/instance/instance.ts\n// @__NO_SIDE_EFFECTS__\nfunction instance(class_, message) {\n  return {\n    kind: \"schema\",\n    type: \"instance\",\n    reference: instance,\n    expects: class_.name,\n    async: false,\n    class: class_,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof this.class) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/intersect/utils/_merge/_merge.ts\n// @__NO_SIDE_EFFECTS__\nfunction _merge(value1, value2) {\n  if (typeof value1 === typeof value2) {\n    if (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) {\n      return { value: value1 };\n    }\n    if (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {\n      for (const key in value2) {\n        if (key in value1) {\n          const dataset = /* @__PURE__ */ _merge(value1[key], value2[key]);\n          if (dataset.issue) {\n            return dataset;\n          }\n          value1[key] = dataset.value;\n        } else {\n          value1[key] = value2[key];\n        }\n      }\n      return { value: value1 };\n    }\n    if (Array.isArray(value1) && Array.isArray(value2)) {\n      if (value1.length === value2.length) {\n        for (let index = 0; index < value1.length; index++) {\n          const dataset = /* @__PURE__ */ _merge(value1[index], value2[index]);\n          if (dataset.issue) {\n            return dataset;\n          }\n          value1[index] = dataset.value;\n        }\n        return { value: value1 };\n      }\n    }\n  }\n  return { issue: true };\n}\n\n// src/schemas/intersect/intersect.ts\n// @__NO_SIDE_EFFECTS__\nfunction intersect(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersect,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"&\"\n    ),\n    async: false,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        for (const schema of this.options) {\n          const optionDataset = schema[\"~run\"]({ value: input }, config2);\n          if (optionDataset.issues) {\n            if (dataset.issues) {\n              dataset.issues.push(...optionDataset.issues);\n            } else {\n              dataset.issues = optionDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) {\n            dataset.typed = false;\n          }\n          if (dataset.typed) {\n            if (outputs) {\n              outputs.push(optionDataset.value);\n            } else {\n              outputs = [optionDataset.value];\n            }\n          }\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = _merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config2, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/intersect/intersectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction intersectAsync(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersectAsync,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"&\"\n    ),\n    async: true,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        const optionDatasets = await Promise.all(\n          this.options.map((schema) => schema[\"~run\"]({ value: input }, config2))\n        );\n        for (const optionDataset of optionDatasets) {\n          if (optionDataset.issues) {\n            if (dataset.issues) {\n              dataset.issues.push(...optionDataset.issues);\n            } else {\n              dataset.issues = optionDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) {\n            dataset.typed = false;\n          }\n          if (dataset.typed) {\n            if (outputs) {\n              outputs.push(optionDataset.value);\n            } else {\n              outputs = [optionDataset.value];\n            }\n          }\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = _merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config2, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/lazy/lazy.ts\n// @__NO_SIDE_EFFECTS__\nfunction lazy(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazy,\n    expects: \"unknown\",\n    async: false,\n    getter,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      return this.getter(dataset.value)[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/lazy/lazyAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction lazyAsync(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazyAsync,\n    expects: \"unknown\",\n    async: true,\n    getter,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      return (await this.getter(dataset.value))[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/literal/literal.ts\n// @__NO_SIDE_EFFECTS__\nfunction literal(literal_, message) {\n  return {\n    kind: \"schema\",\n    type: \"literal\",\n    reference: literal,\n    expects: _stringify(literal_),\n    async: false,\n    literal: literal_,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === this.literal) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseObject/looseObject.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseObject(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObject,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              dataset.value[key] = input[key];\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseObject/looseObjectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseObjectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, valueSchema]) => {\n            if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n            valueSchema.default !== void 0) {\n              const value2 = key in input ? (\n                // @ts-expect-error\n                input[key]\n              ) : await getDefault(valueSchema);\n              return [\n                key,\n                value2,\n                valueSchema,\n                await valueSchema[\"~run\"]({ value: value2 }, config2)\n              ];\n            }\n            return [\n              key,\n              // @ts-expect-error\n              input[key],\n              valueSchema,\n              null\n            ];\n          })\n        );\n        for (const [key, value2, valueSchema, valueDataset] of valueDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              dataset.value[key] = input[key];\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseTuple/looseTuple.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseTuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            dataset.value.push(input[key]);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseTuple/looseTupleAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseTupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [key, value2, await item[\"~run\"]({ value: value2 }, config2)];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            dataset.value.push(input[key]);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/map/map.ts\n// @__NO_SIDE_EFFECTS__\nfunction map(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: map,\n    expects: \"Map\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Map();\n        for (const [inputKey, inputValue] of input) {\n          const keyDataset = this.key[\"~run\"]({ value: inputKey }, config2);\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          const valueDataset = this.value[\"~run\"](\n            { value: inputValue },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/map/mapAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction mapAsync(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: mapAsync,\n    expects: \"Map\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Map();\n        const datasets = await Promise.all(\n          [...input].map(\n            ([inputKey, inputValue]) => Promise.all([\n              inputKey,\n              inputValue,\n              this.key[\"~run\"]({ value: inputKey }, config2),\n              this.value[\"~run\"]({ value: inputValue }, config2)\n            ])\n          )\n        );\n        for (const [\n          inputKey,\n          inputValue,\n          keyDataset,\n          valueDataset\n        ] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nan/nan.ts\n// @__NO_SIDE_EFFECTS__\nfunction nan(message) {\n  return {\n    kind: \"schema\",\n    type: \"nan\",\n    reference: nan,\n    expects: \"NaN\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (Number.isNaN(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/never/never.ts\n// @__NO_SIDE_EFFECTS__\nfunction never(message) {\n  return {\n    kind: \"schema\",\n    type: \"never\",\n    reference: never,\n    expects: \"never\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullable.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullable(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullable,\n    expects: \"!null\",\n    async: false,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value !== null) {\n        dataset = this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullableAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullableAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullableAsync,\n    expects: \"!null\",\n    async: true,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value !== null) {\n        dataset = await this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullish.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullish(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullish,\n    expects: \"(!null & !undefined)\",\n    async: false,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (!(dataset.value === null || dataset.value === void 0)) {\n        dataset = this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null || dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullishAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullishAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullishAsync,\n    expects: \"(!null & !undefined)\",\n    async: true,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (!(dataset.value === null || dataset.value === void 0)) {\n        dataset = await this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null || dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptional.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonOptional(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptional,\n    expects: \"!undefined\",\n    async: false,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value !== void 0) {\n        dataset = this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptionalAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonOptionalAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptionalAsync,\n    expects: \"!undefined\",\n    async: true,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value !== void 0) {\n        dataset = await this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/null/null.ts\n// @__NO_SIDE_EFFECTS__\nfunction null_(message) {\n  return {\n    kind: \"schema\",\n    type: \"null\",\n    reference: null_,\n    expects: \"null\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === null) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nullable/nullable.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullable(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullable,\n    expects: `(${wrapped.expects} | null)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === null) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nullable/nullableAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullableAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullableAsync,\n    expects: `(${wrapped.expects} | null)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === null) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nullish/nullish.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullish(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullish,\n    expects: `(${wrapped.expects} | null | undefined)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nullish/nullishAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullishAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullishAsync,\n    expects: `(${wrapped.expects} | null | undefined)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/number/number.ts\n// @__NO_SIDE_EFFECTS__\nfunction number(message) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: number,\n    expects: \"number\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"number\" && !isNaN(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/object/object.ts\n// @__NO_SIDE_EFFECTS__\nfunction object(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: object,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/object/objectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction objectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: objectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, valueSchema]) => {\n            if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n            valueSchema.default !== void 0) {\n              const value2 = key in input ? (\n                // @ts-expect-error\n                input[key]\n              ) : await getDefault(valueSchema);\n              return [\n                key,\n                value2,\n                valueSchema,\n                await valueSchema[\"~run\"]({ value: value2 }, config2)\n              ];\n            }\n            return [\n              key,\n              // @ts-expect-error\n              input[key],\n              valueSchema,\n              null\n            ];\n          })\n        );\n        for (const [key, value2, valueSchema, valueDataset] of valueDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/objectWithRest/objectWithRest.ts\n// @__NO_SIDE_EFFECTS__\nfunction objectWithRest(entries, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRest,\n    expects: \"Object\",\n    async: false,\n    entries,\n    rest,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              const valueDataset = this.rest[\"~run\"](\n                // @ts-expect-error\n                { value: input[key] },\n                config2\n              );\n              if (valueDataset.issues) {\n                const pathItem = {\n                  type: \"object\",\n                  origin: \"value\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                };\n                for (const issue of valueDataset.issues) {\n                  if (issue.path) {\n                    issue.path.unshift(pathItem);\n                  } else {\n                    issue.path = [pathItem];\n                  }\n                  dataset.issues?.push(issue);\n                }\n                if (!dataset.issues) {\n                  dataset.issues = valueDataset.issues;\n                }\n                if (config2.abortEarly) {\n                  dataset.typed = false;\n                  break;\n                }\n              }\n              if (!valueDataset.typed) {\n                dataset.typed = false;\n              }\n              dataset.value[key] = valueDataset.value;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/objectWithRest/objectWithRestAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction objectWithRestAsync(entries, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRestAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    rest,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const [normalDatasets, restDatasets] = await Promise.all([\n          // If key is present or its an optional schema with a default value,\n          // parse input of key or default value asynchronously\n          Promise.all(\n            Object.entries(this.entries).map(async ([key, valueSchema]) => {\n              if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n              valueSchema.default !== void 0) {\n                const value2 = key in input ? (\n                  // @ts-expect-error\n                  input[key]\n                ) : await getDefault(valueSchema);\n                return [\n                  key,\n                  value2,\n                  valueSchema,\n                  await valueSchema[\"~run\"]({ value: value2 }, config2)\n                ];\n              }\n              return [\n                key,\n                // @ts-expect-error\n                input[key],\n                valueSchema,\n                null\n              ];\n            })\n          ),\n          // Parse other entries with rest schema asynchronously\n          // Hint: We exclude specific keys for security reasons\n          Promise.all(\n            Object.entries(input).filter(\n              ([key]) => _isValidObjectKey(input, key) && !(key in this.entries)\n            ).map(\n              async ([key, value2]) => [\n                key,\n                value2,\n                await this.rest[\"~run\"]({ value: value2 }, config2)\n              ]\n            )\n          )\n        ]);\n        for (const [key, value2, valueSchema, valueDataset] of normalDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const [key, value2, valueDataset] of restDatasets) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/optional/optional.ts\n// @__NO_SIDE_EFFECTS__\nfunction optional(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optional,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/optional/optionalAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction optionalAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optionalAsync,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/picklist/picklist.ts\n// @__NO_SIDE_EFFECTS__\nfunction picklist(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"picklist\",\n    reference: picklist,\n    expects: _joinExpects(options.map(_stringify), \"|\"),\n    async: false,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.options.includes(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/promise/promise.ts\n// @__NO_SIDE_EFFECTS__\nfunction promise(message) {\n  return {\n    kind: \"schema\",\n    type: \"promise\",\n    reference: promise,\n    expects: \"Promise\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof Promise) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/record/record.ts\n// @__NO_SIDE_EFFECTS__\nfunction record(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: record,\n    expects: \"Object\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const entryKey in input) {\n          if (_isValidObjectKey(input, entryKey)) {\n            const entryValue = input[entryKey];\n            const keyDataset = this.key[\"~run\"]({ value: entryKey }, config2);\n            if (keyDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"key\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of keyDataset.issues) {\n                issue.path = [pathItem];\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = keyDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            const valueDataset = this.value[\"~run\"](\n              { value: entryValue },\n              config2\n            );\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!keyDataset.typed || !valueDataset.typed) {\n              dataset.typed = false;\n            }\n            if (keyDataset.typed) {\n              dataset.value[keyDataset.value] = valueDataset.value;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/record/recordAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction recordAsync(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: recordAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const datasets = await Promise.all(\n          Object.entries(input).filter(([key2]) => _isValidObjectKey(input, key2)).map(\n            ([entryKey, entryValue]) => Promise.all([\n              entryKey,\n              entryValue,\n              this.key[\"~run\"]({ value: entryKey }, config2),\n              this.value[\"~run\"]({ value: entryValue }, config2)\n            ])\n          )\n        );\n        for (const [\n          entryKey,\n          entryValue,\n          keyDataset,\n          valueDataset\n        ] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"key\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of keyDataset.issues) {\n              issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (keyDataset.typed) {\n            dataset.value[keyDataset.value] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/set/set.ts\n// @__NO_SIDE_EFFECTS__\nfunction set(value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: set,\n    expects: \"Set\",\n    async: false,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Set();\n        for (const inputValue of input) {\n          const valueDataset = this.value[\"~run\"](\n            { value: inputValue },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              key: null,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.add(valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/set/setAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction setAsync(value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: setAsync,\n    expects: \"Set\",\n    async: true,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Set();\n        const valueDatasets = await Promise.all(\n          [...input].map(\n            async (inputValue) => [\n              inputValue,\n              await this.value[\"~run\"]({ value: inputValue }, config2)\n            ]\n          )\n        );\n        for (const [inputValue, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              key: null,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.add(valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictObject/strictObject.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictObject(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObject,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              _addIssue(this, \"key\", dataset, config2, {\n                input: key,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"key\",\n                    input,\n                    key,\n                    // @ts-expect-error\n                    value: input[key]\n                  }\n                ]\n              });\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictObject/strictObjectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictObjectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, valueSchema]) => {\n            if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n            valueSchema.default !== void 0) {\n              const value2 = key in input ? (\n                // @ts-expect-error\n                input[key]\n              ) : await getDefault(valueSchema);\n              return [\n                key,\n                value2,\n                valueSchema,\n                await valueSchema[\"~run\"]({ value: value2 }, config2)\n              ];\n            }\n            return [\n              key,\n              // @ts-expect-error\n              input[key],\n              valueSchema,\n              null\n            ];\n          })\n        );\n        for (const [key, value2, valueSchema, valueDataset] of valueDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              _addIssue(this, \"key\", dataset, config2, {\n                input: key,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"key\",\n                    input,\n                    key,\n                    // @ts-expect-error\n                    value: input[key]\n                  }\n                ]\n              });\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictTuple/strictTuple.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictTuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\n          _addIssue(this, \"type\", dataset, config2, {\n            input: input[this.items.length],\n            expected: \"never\",\n            path: [\n              {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key: this.items.length,\n                value: input[this.items.length]\n              }\n            ]\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictTuple/strictTupleAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictTupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [key, value2, await item[\"~run\"]({ value: value2 }, config2)];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\n          _addIssue(this, \"type\", dataset, config2, {\n            input: input[this.items.length],\n            expected: \"never\",\n            path: [\n              {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key: this.items.length,\n                value: input[this.items.length]\n              }\n            ]\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/string/string.ts\n// @__NO_SIDE_EFFECTS__\nfunction string(message) {\n  return {\n    kind: \"schema\",\n    type: \"string\",\n    reference: string,\n    expects: \"string\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"string\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/symbol/symbol.ts\n// @__NO_SIDE_EFFECTS__\nfunction symbol(message) {\n  return {\n    kind: \"schema\",\n    type: \"symbol\",\n    reference: symbol,\n    expects: \"symbol\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"symbol\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tuple/tuple.ts\n// @__NO_SIDE_EFFECTS__\nfunction tuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tuple/tupleAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction tupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [key, value2, await item[\"~run\"]({ value: value2 }, config2)];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tupleWithRest/tupleWithRest.ts\n// @__NO_SIDE_EFFECTS__\nfunction tupleWithRest(items, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRest,\n    expects: \"Array\",\n    async: false,\n    items,\n    rest,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            const value2 = input[key];\n            const itemDataset = this.rest[\"~run\"]({ value: value2 }, config2);\n            if (itemDataset.issues) {\n              const pathItem = {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of itemDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = itemDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!itemDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value.push(itemDataset.value);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tupleWithRest/tupleWithRestAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction tupleWithRestAsync(items, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRestAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    rest,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const [normalDatasets, restDatasets] = await Promise.all([\n          // Parse schema of each normal item\n          Promise.all(\n            this.items.map(async (item, key) => {\n              const value2 = input[key];\n              return [\n                key,\n                value2,\n                await item[\"~run\"]({ value: value2 }, config2)\n              ];\n            })\n          ),\n          // Parse other items with rest schema\n          Promise.all(\n            input.slice(this.items.length).map(async (value2, key) => {\n              return [\n                key + this.items.length,\n                value2,\n                await this.rest[\"~run\"]({ value: value2 }, config2)\n              ];\n            })\n          )\n        ]);\n        for (const [key, value2, itemDataset] of normalDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const [key, value2, itemDataset] of restDatasets) {\n            if (itemDataset.issues) {\n              const pathItem = {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of itemDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = itemDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!itemDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value.push(itemDataset.value);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/undefined/undefined.ts\n// @__NO_SIDE_EFFECTS__\nfunction undefined_(message) {\n  return {\n    kind: \"schema\",\n    type: \"undefined\",\n    reference: undefined_,\n    expects: \"undefined\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/undefinedable/undefinedable.ts\n// @__NO_SIDE_EFFECTS__\nfunction undefinedable(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"undefinedable\",\n    reference: undefinedable,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/undefinedable/undefinedableAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction undefinedableAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"undefinedable\",\n    reference: undefinedableAsync,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/union/utils/_subIssues/_subIssues.ts\n// @__NO_SIDE_EFFECTS__\nfunction _subIssues(datasets) {\n  let issues;\n  if (datasets) {\n    for (const dataset of datasets) {\n      if (issues) {\n        issues.push(...dataset.issues);\n      } else {\n        issues = dataset.issues;\n      }\n    }\n  }\n  return issues;\n}\n\n// src/schemas/union/union.ts\n// @__NO_SIDE_EFFECTS__\nfunction union(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: union,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"|\"\n    ),\n    async: false,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = schema[\"~run\"]({ value: dataset.value }, config2);\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) {\n              typedDatasets.push(optionDataset);\n            } else {\n              typedDatasets = [optionDataset];\n            }\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else {\n          if (untypedDatasets) {\n            untypedDatasets.push(optionDataset);\n          } else {\n            untypedDatasets = [optionDataset];\n          }\n        }\n      }\n      if (validDataset) {\n        return validDataset;\n      }\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) {\n          return typedDatasets[0];\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) {\n        return untypedDatasets[0];\n      } else {\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(untypedDatasets)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/union/unionAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction unionAsync(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: unionAsync,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"|\"\n    ),\n    async: true,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = await schema[\"~run\"](\n          { value: dataset.value },\n          config2\n        );\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) {\n              typedDatasets.push(optionDataset);\n            } else {\n              typedDatasets = [optionDataset];\n            }\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else {\n          if (untypedDatasets) {\n            untypedDatasets.push(optionDataset);\n          } else {\n            untypedDatasets = [optionDataset];\n          }\n        }\n      }\n      if (validDataset) {\n        return validDataset;\n      }\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) {\n          return typedDatasets[0];\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) {\n        return untypedDatasets[0];\n      } else {\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(untypedDatasets)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/unknown/unknown.ts\n// @__NO_SIDE_EFFECTS__\nfunction unknown() {\n  return {\n    kind: \"schema\",\n    type: \"unknown\",\n    reference: unknown,\n    expects: \"unknown\",\n    async: false,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/variant/variant.ts\n// @__NO_SIDE_EFFECTS__\nfunction variant(key, options, message) {\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variant,\n    expects: \"Object\",\n    async: false,\n    key,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        let outputDataset;\n        let maxDiscriminatorPriority = 0;\n        let invalidDiscriminatorKey = this.key;\n        let expectedDiscriminators = [];\n        const parseOptions = (variant2, allKeys) => {\n          for (const schema of variant2.options) {\n            if (schema.type === \"variant\") {\n              parseOptions(schema, new Set(allKeys).add(schema.key));\n            } else {\n              let keysAreValid = true;\n              let currentPriority = 0;\n              for (const currentKey of allKeys) {\n                if (schema.entries[currentKey][\"~run\"](\n                  // @ts-expect-error\n                  { typed: false, value: input[currentKey] },\n                  config2\n                ).issues) {\n                  keysAreValid = false;\n                  if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {\n                    maxDiscriminatorPriority = currentPriority;\n                    invalidDiscriminatorKey = currentKey;\n                    expectedDiscriminators = [];\n                  }\n                  if (invalidDiscriminatorKey === currentKey) {\n                    expectedDiscriminators.push(\n                      schema.entries[currentKey].expects\n                    );\n                  }\n                  break;\n                }\n                currentPriority++;\n              }\n              if (keysAreValid) {\n                const optionDataset = schema[\"~run\"]({ value: input }, config2);\n                if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                  outputDataset = optionDataset;\n                }\n              }\n            }\n            if (outputDataset && !outputDataset.issues) {\n              break;\n            }\n          }\n        };\n        parseOptions(this, /* @__PURE__ */ new Set([this.key]));\n        if (outputDataset) {\n          return outputDataset;\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          // @ts-expect-error\n          input: input[invalidDiscriminatorKey],\n          expected: _joinExpects(expectedDiscriminators, \"|\"),\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: invalidDiscriminatorKey,\n              // @ts-expect-error\n              value: input[invalidDiscriminatorKey]\n            }\n          ]\n        });\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/variant/variantAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction variantAsync(key, options, message) {\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variantAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        let outputDataset;\n        let maxDiscriminatorPriority = 0;\n        let invalidDiscriminatorKey = this.key;\n        let expectedDiscriminators = [];\n        const parseOptions = async (variant2, allKeys) => {\n          for (const schema of variant2.options) {\n            if (schema.type === \"variant\") {\n              await parseOptions(schema, new Set(allKeys).add(schema.key));\n            } else {\n              let keysAreValid = true;\n              let currentPriority = 0;\n              for (const currentKey of allKeys) {\n                if ((await schema.entries[currentKey][\"~run\"](\n                  // @ts-expect-error\n                  { typed: false, value: input[currentKey] },\n                  config2\n                )).issues) {\n                  keysAreValid = false;\n                  if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {\n                    maxDiscriminatorPriority = currentPriority;\n                    invalidDiscriminatorKey = currentKey;\n                    expectedDiscriminators = [];\n                  }\n                  if (invalidDiscriminatorKey === currentKey) {\n                    expectedDiscriminators.push(\n                      schema.entries[currentKey].expects\n                    );\n                  }\n                  break;\n                }\n                currentPriority++;\n              }\n              if (keysAreValid) {\n                const optionDataset = await schema[\"~run\"](\n                  { value: input },\n                  config2\n                );\n                if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                  outputDataset = optionDataset;\n                }\n              }\n            }\n            if (outputDataset && !outputDataset.issues) {\n              break;\n            }\n          }\n        };\n        await parseOptions(this, /* @__PURE__ */ new Set([this.key]));\n        if (outputDataset) {\n          return outputDataset;\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          // @ts-expect-error\n          input: input[invalidDiscriminatorKey],\n          expected: _joinExpects(expectedDiscriminators, \"|\"),\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: invalidDiscriminatorKey,\n              // @ts-expect-error\n              value: input[invalidDiscriminatorKey]\n            }\n          ]\n        });\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/void/void.ts\n// @__NO_SIDE_EFFECTS__\nfunction void_(message) {\n  return {\n    kind: \"schema\",\n    type: \"void\",\n    reference: void_,\n    expects: \"void\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/keyof/keyof.ts\n// @__NO_SIDE_EFFECTS__\nfunction keyof(schema, message) {\n  return picklist(Object.keys(schema.entries), message);\n}\n\n// src/methods/omit/omit.ts\n// @__NO_SIDE_EFFECTS__\nfunction omit(schema, keys) {\n  const entries = {\n    ...schema.entries\n  };\n  for (const key of keys) {\n    delete entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/parse/parse.ts\nfunction parse(schema, input, config2) {\n  const dataset = schema[\"~run\"]({ value: input }, getGlobalConfig(config2));\n  if (dataset.issues) {\n    throw new ValiError(dataset.issues);\n  }\n  return dataset.value;\n}\n\n// src/methods/parse/parseAsync.ts\nasync function parseAsync(schema, input, config2) {\n  const dataset = await schema[\"~run\"](\n    { value: input },\n    getGlobalConfig(config2)\n  );\n  if (dataset.issues) {\n    throw new ValiError(dataset.issues);\n  }\n  return dataset.value;\n}\n\n// src/methods/parser/parser.ts\n// @__NO_SIDE_EFFECTS__\nfunction parser(schema, config2) {\n  const func = (input) => parse(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/parser/parserAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction parserAsync(schema, config2) {\n  const func = (input) => parseAsync(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/partial/partial.ts\n// @__NO_SIDE_EFFECTS__\nfunction partial(schema, keys) {\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? optional(schema.entries[key]) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/partial/partialAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction partialAsync(schema, keys) {\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? optionalAsync(schema.entries[key]) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/pick/pick.ts\n// @__NO_SIDE_EFFECTS__\nfunction pick(schema, keys) {\n  const entries = {};\n  for (const key of keys) {\n    entries[key] = schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/pipe/pipe.ts\n// @__NO_SIDE_EFFECTS__\nfunction pipe(...pipe2) {\n  return {\n    ...pipe2[0],\n    pipe: pipe2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      for (const item of pipe2) {\n        if (item.kind !== \"metadata\") {\n          if (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n            dataset.typed = false;\n            break;\n          }\n          if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\n            dataset = item[\"~run\"](dataset, config2);\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/pipe/pipeAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction pipeAsync(...pipe2) {\n  return {\n    ...pipe2[0],\n    pipe: pipe2,\n    async: true,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      for (const item of pipe2) {\n        if (item.kind !== \"metadata\") {\n          if (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n            dataset.typed = false;\n            break;\n          }\n          if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\n            dataset = await item[\"~run\"](dataset, config2);\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/required/required.ts\n// @__NO_SIDE_EFFECTS__\nfunction required(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message = Array.isArray(arg2) ? arg3 : arg2;\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? nonOptional(schema.entries[key], message) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/required/requiredAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction requiredAsync(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message = Array.isArray(arg2) ? arg3 : arg2;\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? nonOptionalAsync(schema.entries[key], message) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/safeParse/safeParse.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeParse(schema, input, config2) {\n  const dataset = schema[\"~run\"]({ value: input }, getGlobalConfig(config2));\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n// src/methods/safeParse/safeParseAsync.ts\n// @__NO_SIDE_EFFECTS__\nasync function safeParseAsync(schema, input, config2) {\n  const dataset = await schema[\"~run\"](\n    { value: input },\n    getGlobalConfig(config2)\n  );\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n// src/methods/safeParser/safeParser.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeParser(schema, config2) {\n  const func = (input) => safeParse(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/safeParser/safeParserAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeParserAsync(schema, config2) {\n  const func = (input) => safeParseAsync(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/unwrap/unwrap.ts\n// @__NO_SIDE_EFFECTS__\nfunction unwrap(schema) {\n  return schema.wrapped;\n}\nexport {\n  BASE64_REGEX,\n  BIC_REGEX,\n  CUID2_REGEX,\n  DECIMAL_REGEX,\n  DIGITS_REGEX,\n  EMAIL_REGEX,\n  EMOJI_REGEX,\n  HEXADECIMAL_REGEX,\n  HEX_COLOR_REGEX,\n  IMEI_REGEX,\n  IPV4_REGEX,\n  IPV6_REGEX,\n  IP_REGEX,\n  ISO_DATE_REGEX,\n  ISO_DATE_TIME_REGEX,\n  ISO_TIMESTAMP_REGEX,\n  ISO_TIME_REGEX,\n  ISO_TIME_SECOND_REGEX,\n  ISO_WEEK_REGEX,\n  MAC48_REGEX,\n  MAC64_REGEX,\n  MAC_REGEX,\n  NANO_ID_REGEX,\n  OCTAL_REGEX,\n  RFC_EMAIL_REGEX,\n  ULID_REGEX,\n  UUID_REGEX,\n  ValiError,\n  _addIssue,\n  _getByteCount,\n  _getGraphemeCount,\n  _getStandardProps,\n  _getWordCount,\n  _isLuhnAlgo,\n  _isValidObjectKey,\n  _joinExpects,\n  _stringify,\n  any,\n  args,\n  argsAsync,\n  array,\n  arrayAsync,\n  assert,\n  awaitAsync,\n  base64,\n  bic,\n  bigint,\n  blob,\n  boolean,\n  brand,\n  bytes,\n  check,\n  checkAsync,\n  checkItems,\n  checkItemsAsync,\n  config,\n  creditCard,\n  cuid2,\n  custom,\n  customAsync,\n  date,\n  decimal,\n  deleteGlobalConfig,\n  deleteGlobalMessage,\n  deleteSchemaMessage,\n  deleteSpecificMessage,\n  description,\n  digits,\n  email,\n  emoji,\n  empty,\n  endsWith,\n  entriesFromList,\n  enum_ as enum,\n  enum_,\n  everyItem,\n  exactOptional,\n  exactOptionalAsync,\n  excludes,\n  fallback,\n  fallbackAsync,\n  file,\n  filterItems,\n  findItem,\n  finite,\n  flatten,\n  forward,\n  forwardAsync,\n  function_ as function,\n  function_,\n  getDefault,\n  getDefaults,\n  getDefaultsAsync,\n  getDotPath,\n  getFallback,\n  getFallbacks,\n  getFallbacksAsync,\n  getGlobalConfig,\n  getGlobalMessage,\n  getSchemaMessage,\n  getSpecificMessage,\n  graphemes,\n  hash,\n  hexColor,\n  hexadecimal,\n  imei,\n  includes,\n  instance,\n  integer,\n  intersect,\n  intersectAsync,\n  ip,\n  ipv4,\n  ipv6,\n  is,\n  isOfKind,\n  isOfType,\n  isValiError,\n  isoDate,\n  isoDateTime,\n  isoTime,\n  isoTimeSecond,\n  isoTimestamp,\n  isoWeek,\n  keyof,\n  lazy,\n  lazyAsync,\n  length,\n  literal,\n  looseObject,\n  looseObjectAsync,\n  looseTuple,\n  looseTupleAsync,\n  mac,\n  mac48,\n  mac64,\n  map,\n  mapAsync,\n  mapItems,\n  maxBytes,\n  maxGraphemes,\n  maxLength,\n  maxSize,\n  maxValue,\n  maxWords,\n  metadata,\n  mimeType,\n  minBytes,\n  minGraphemes,\n  minLength,\n  minSize,\n  minValue,\n  minWords,\n  multipleOf,\n  nan,\n  nanoid,\n  never,\n  nonEmpty,\n  nonNullable,\n  nonNullableAsync,\n  nonNullish,\n  nonNullishAsync,\n  nonOptional,\n  nonOptionalAsync,\n  normalize,\n  notBytes,\n  notGraphemes,\n  notLength,\n  notSize,\n  notValue,\n  notWords,\n  null_ as null,\n  null_,\n  nullable,\n  nullableAsync,\n  nullish,\n  nullishAsync,\n  number,\n  object,\n  objectAsync,\n  objectWithRest,\n  objectWithRestAsync,\n  octal,\n  omit,\n  optional,\n  optionalAsync,\n  parse,\n  parseAsync,\n  parser,\n  parserAsync,\n  partial,\n  partialAsync,\n  partialCheck,\n  partialCheckAsync,\n  pick,\n  picklist,\n  pipe,\n  pipeAsync,\n  promise,\n  rawCheck,\n  rawCheckAsync,\n  rawTransform,\n  rawTransformAsync,\n  readonly,\n  record,\n  recordAsync,\n  reduceItems,\n  regex,\n  required,\n  requiredAsync,\n  returns,\n  returnsAsync,\n  rfcEmail,\n  safeInteger,\n  safeParse,\n  safeParseAsync,\n  safeParser,\n  safeParserAsync,\n  set,\n  setAsync,\n  setGlobalConfig,\n  setGlobalMessage,\n  setSchemaMessage,\n  setSpecificMessage,\n  size,\n  someItem,\n  sortItems,\n  startsWith,\n  strictObject,\n  strictObjectAsync,\n  strictTuple,\n  strictTupleAsync,\n  string,\n  symbol,\n  title,\n  toLowerCase,\n  toMaxValue,\n  toMinValue,\n  toUpperCase,\n  transform,\n  transformAsync,\n  trim,\n  trimEnd,\n  trimStart,\n  tuple,\n  tupleAsync,\n  tupleWithRest,\n  tupleWithRestAsync,\n  ulid,\n  undefined_ as undefined,\n  undefined_,\n  undefinedable,\n  undefinedableAsync,\n  union,\n  unionAsync,\n  unknown,\n  unwrap,\n  url,\n  uuid,\n  value,\n  variant,\n  variantAsync,\n  void_ as void,\n  void_,\n  words\n};\n", "function y(o) {\n  return o.replace(/[A-Z]/g, (e) => `-${e.toLowerCase()}`);\n}\nfunction C(o) {\n  return o.replace(/[A-Z]/g, (e) => `_${e.toLowerCase()}`);\n}\nfunction S(o) {\n  return Object.entries(o).reduce((e, [r, t]) => (e[C(r)] = t, e), {});\n}\nfunction $(o) {\n  return o.replace(/_[a-z]/g, (e) => e[1].toUpperCase());\n}\nfunction h(o) {\n  return Object.entries(o).reduce((e, [r, t]) => (e[$(r)] = t, e), {});\n}\nfunction f(o) {\n  const e = h(o);\n  for (const r in e) {\n    const t = e[r];\n    t && typeof t == \"object\" && !(t instanceof Date) && (e[r] = Array.isArray(t) ? t.map(f) : f(t));\n  }\n  return e;\n}\nfunction k(o) {\n  return o.replace(/_([a-z])/g, (e, r) => `-${r.toLowerCase()}`);\n}\nfunction g(o) {\n  return `tapps/${o}`;\n}\nfunction w(o, e) {\n  sessionStorage.setItem(g(o), JSON.stringify(e));\n}\nfunction T(o) {\n  const e = sessionStorage.getItem(g(o));\n  try {\n    return e ? JSON.parse(e) : void 0;\n  } catch {\n  }\n}\nfunction L(...o) {\n  const e = o.flat(1);\n  return [\n    e.push.bind(e),\n    () => {\n      e.forEach((r) => {\n        r();\n      });\n    }\n  ];\n}\n// @__NO_SIDE_EFFECTS__\nfunction O(o, e) {\n  e || (e = {});\n  const {\n    textColor: r,\n    bgColor: t,\n    shouldLog: s\n  } = e, c = s === void 0 ? !0 : s, d = typeof c == \"boolean\" ? () => c : c, u = (n, a, ...i) => {\n    if (a || d()) {\n      const l = \"font-weight:bold;padding:0 5px;border-radius:100px\", [b, m, p] = {\n        log: [\"#0089c3\", \"white\", \"INFO\"],\n        error: [\"#ff0000F0\", \"white\", \"ERR\"],\n        warn: [\"#D38E15\", \"white\", \"WARN\"]\n      }[n];\n      console[n](\n        `%c${p} ${Intl.DateTimeFormat(\"en-GB\", {\n          hour: \"2-digit\",\n          minute: \"2-digit\",\n          second: \"2-digit\",\n          fractionalSecondDigits: 3,\n          timeZone: \"UTC\"\n        }).format(/* @__PURE__ */ new Date())}%c %c${o}`,\n        `${l};background-color:${b};color:${m}`,\n        \"\",\n        `${l};${r ? `color:${r};` : \"\"}${t ? `background-color:${t}` : \"\"}`,\n        ...i\n      );\n    }\n  };\n  return [\n    [\"log\", \"forceLog\"],\n    [\"warn\", \"forceWarn\"],\n    [\"error\", \"forceError\"]\n  ].reduce((n, [a, i]) => (n[a] = u.bind(void 0, a, !1), n[i] = u.bind(void 0, a, !0), n), {});\n}\nexport {\n  y as camelToKebab,\n  C as camelToSnake,\n  S as camelToSnakeObjKeys,\n  L as createCbCollector,\n  O as createLogger,\n  f as deepSnakeToCamelObjKeys,\n  T as getStorageValue,\n  w as setStorageValue,\n  $ as snakeToCamel,\n  h as snakeToCamelObjKeys,\n  k as snakeToKebab\n};\n//# sourceMappingURL=index.js.map\n", "import { transform, type TransformAction } from 'valibot';\nimport {\n  type DeepConvertSnakeKeysToCamelCase,\n  deepSnakeToCamelObjKeys,\n  type If,\n} from '@telegram-apps/toolkit';\n\nexport type ConditionalSnakeKeysAction<Input extends object, CamelCase extends boolean> =\n  TransformAction<\n    Input,\n    If<CamelCase, DeepConvertSnakeKeysToCamelCase<Input>, Input>\n  >;\n\n/**\n * Conditionally applies `deepSnakeToCamelObjKeys` to the input.\n * @param camelCase - true if the camel-casing must be applied.\n */\nexport function conditionalSnakeKeys<Input extends object>(\n  camelCase?: boolean,\n): ConditionalSnakeKeysAction<Input, false>;\n\n/**\n * Conditionally applies `deepSnakeToCamelObjKeys` to the input.\n * @param camelCase - true if the camel-casing must be applied.\n */\nexport function conditionalSnakeKeys<Input extends object>(\n  camelCase: true,\n): ConditionalSnakeKeysAction<Input, true>;\n\n/**\n * Conditionally applies `deepSnakeToCamelObjKeys` to the input.\n * @param camelCase - true if the camel-casing must be applied.\n */\nexport function conditionalSnakeKeys(camelCase?: boolean): ConditionalSnakeKeysAction<object, boolean> {\n  return transform(input => {\n    return camelCase ? deepSnakeToCamelObjKeys(input) : input;\n  });\n}", "import {\n  type BaseIssue,\n  type BaseSchema,\n  type InferOutput,\n  pipe,\n  type SchemaWithPipe,\n} from 'valibot';\n\nimport {\n  conditionalSnakeKeys,\n  type ConditionalSnakeKeysAction,\n} from '@/camel-casing/conditionalSnakeKeys.js';\nimport type { CamelCaseTransformerFn } from '@/camel-casing/types.js';\n\ntype RequiredSchema = BaseSchema<unknown, object, BaseIssue<unknown>>;\n\nexport type CamelCaseTransformerPipe<Schema extends RequiredSchema, CamelCase extends boolean> =\n  SchemaWithPipe<[\n    Schema,\n    ConditionalSnakeKeysAction<InferOutput<Schema>, CamelCase>\n  ]>;\n\nexport type CamelCaseTransformer<Schema extends RequiredSchema> = CamelCaseTransformerFn<\n  CamelCaseTransformerPipe<Schema, false>,\n  CamelCaseTransformerPipe<Schema, true>\n>;\n\n/**\n * Creates a function that generates schemas deeply camel-casing output keys if needed.\n * @param schema - base schema used to validate the input.\n */\nexport function createCamelCaseGen<Schema extends RequiredSchema>(\n  schema: Schema,\n): CamelCaseTransformer<Schema> {\n  return ((camelCase?) => pipe(\n    schema,\n    conditionalSnakeKeys(camelCase as any),\n  )) as CamelCaseTransformer<Schema>;\n}\n", "import { type BaseIssue, type BaseSchema, InferOutput, parse, pipe } from 'valibot';\nimport type { DeepConvertSnakeKeysToCamelCase } from '@telegram-apps/toolkit';\nimport { conditionalSnakeKeys } from '@/camel-casing/conditionalSnakeKeys.js';\n\nexport interface CamelCaseSchemaParser<Input, Output extends object> {\n  (input: Input, camelCase?: false): Output;\n  (input: Input, camelCase: true): DeepConvertSnakeKeysToCamelCase<Output>;\n}\n\nexport function createCamelCaseSchemaParserGen<\n  Input,\n  Schema extends BaseSchema<Input, object, BaseIssue<unknown>>\n>(schema: Schema): CamelCaseSchemaParser<Input, InferOutput<Schema>> {\n  return ((input, camelCase?) => parse(\n    pipe(schema, conditionalSnakeKeys(camelCase)),\n    input\n  )) as CamelCaseSchemaParser<Input, InferOutput<Schema>>;\n}", "import { transform, TransformAction } from 'valibot';\n\nexport type JsonParseAction = TransformAction<string, unknown>;\n\n/**\n * @returns A transformer applying `JSON.parse` to the input.\n */\nexport function jsonParse(): JsonParseAction {\n  return transform(JSON.parse);\n}\n", "import {\n  type BaseIssue,\n  type BaseSchema,\n  pipe,\n  type SchemaWithPipe,\n  string,\n  type StringSchema,\n  type TransformAction,\n} from 'valibot';\n\nimport {\n  type CamelCaseTransformerPipe,\n  createCamelCaseGen,\n} from '@/camel-casing/createCamelCaseGen.js';\nimport type { CamelCaseTransformerFn } from '@/camel-casing/types.js';\nimport { jsonParse } from '@/transformers/jsonParse.js';\n\ntype RequiredSchema = BaseSchema<unknown, object, BaseIssue<unknown>>;\n\nexport type CamelCaseJsonTransformerPipe<\n  Schema extends RequiredSchema,\n  CamelCase extends boolean\n> = SchemaWithPipe<[\n  StringSchema<undefined>,\n  TransformAction<string, unknown>,\n  CamelCaseTransformerPipe<Schema, CamelCase>,\n]>;\n\nexport type CamelCaseJsonTransformer<Schema extends RequiredSchema> = CamelCaseTransformerFn<\n  CamelCaseJsonTransformerPipe<Schema, false>,\n  CamelCaseJsonTransformerPipe<Schema, true>\n>;\n\n/**\n * Creates a transformer accepting a JSON object presented as string and returning a value based\n * on the passed schema.\n * @param schema - schema to use to transform the output\n */\nexport function createJsonCamelCaseGen<Schema extends RequiredSchema>(\n  schema: Schema,\n): CamelCaseJsonTransformer<Schema> {\n  const cc = createCamelCaseGen(schema);\n\n  return ((camelCase?) => pipe(\n    string(),\n    jsonParse(),\n    cc(camelCase as any),\n  )) as CamelCaseJsonTransformer<Schema>;\n}", "import {\n  type BaseIssue,\n  type BaseSchema,\n  type InferOutput,\n  parse,\n  transform,\n  type TransformAction,\n} from 'valibot';\n\nexport type TransformQueryUsingAction<Schema extends BaseSchema<unknown, unknown, BaseIssue<unknown>>>\n  = TransformAction<string | URLSearchParams, InferOutput<Schema>>\n\nexport function transformQueryUsing<Schema extends BaseSchema<unknown, unknown, BaseIssue<unknown>>>(\n  schema: Schema,\n): TransformQueryUsingAction<Schema> {\n  return transform(input => {\n    const result: Record<string, string | string[]> = {};\n\n    new URLSearchParams(input).forEach((value, key) => {\n      const accValue = result[key];\n      if (Array.isArray(accValue)) {\n        accValue.push(value);\n      } else if (accValue === undefined) {\n        result[key] = value;\n      } else {\n        result[key] = [accValue, value];\n      }\n    });\n\n    return parse(schema, result);\n  });\n}", "import {\n  type BaseIssue,\n  type BaseSchema,\n  type InferOutput,\n  instance,\n  type InstanceSchema,\n  pipe,\n  type SchemaWithPipe,\n  string,\n  type StringSchema,\n  union,\n  type UnionSchema,\n} from 'valibot';\n\nimport {\n  conditionalSnakeKeys,\n  type ConditionalSnakeKeysAction,\n} from '@/camel-casing/conditionalSnakeKeys.js';\nimport type { CamelCaseTransformerFn } from '@/camel-casing/types.js';\nimport {\n  transformQueryUsing,\n  type TransformQueryUsingAction,\n} from '@/transformers/transformQueryUsing.js';\n\ntype RequiredSchema = BaseSchema<object, object, BaseIssue<unknown>>;\n\nexport type CamelCaseQueryTransformerPipe<\n  Schema extends RequiredSchema,\n  CamelCase extends boolean\n> = SchemaWithPipe<[\n  UnionSchema<[\n    StringSchema<undefined>,\n    InstanceSchema<typeof URLSearchParams, undefined>\n  ], undefined>,\n  TransformQueryUsingAction<Schema>,\n  ConditionalSnakeKeysAction<InferOutput<Schema>, CamelCase>\n]>;\n\nexport type CamelCaseQueryTransformer<Schema extends RequiredSchema> = CamelCaseTransformerFn<\n  CamelCaseQueryTransformerPipe<Schema, false>,\n  CamelCaseQueryTransformerPipe<Schema, true>\n>;\n\n/**\n * Creates a transformer accepting query parameters as string and returning a value based\n * on the passed schema.\n * @param schema - schema to use to transform the output\n */\nexport function createQueryCamelCaseGen<Schema extends RequiredSchema>(\n  schema: Schema,\n): CamelCaseQueryTransformer<Schema> {\n  return ((camelCase?) => pipe(\n    union([string(), instance(URLSearchParams)]),\n    transformQueryUsing(schema),\n    conditionalSnakeKeys<any>(camelCase),\n  )) as CamelCaseQueryTransformer<Schema>;\n}", "import {\n  type BaseSchema, boolean,\n  date, integer, lazy,\n  looseObject,\n  number,\n  optional,\n  pipe,\n  string,\n  transform,\n} from 'valibot';\nimport type { Chat, InitData, User } from '@telegram-apps/types';\n\nimport { initDataChatJson, initDataUserJson } from '@/generators/init-data.js';\n\nconst lazyUser = optional(lazy(() => initDataUserJson()));\n\nexport const InitDataChatSchema = looseObject({\n  id: number(),\n  photo_url: optional(string()),\n  type: string(),\n  title: string(),\n  username: optional(string()),\n} satisfies { [K in keyof Chat]-?: BaseSchema<unknown, Chat[K], any> });\n\nexport const InitDataUserSchema = looseObject({\n  added_to_attachment_menu: optional(boolean()),\n  allows_write_to_pm: optional(boolean()),\n  first_name: string(),\n  id: number(),\n  is_bot: optional(boolean()),\n  is_premium: optional(boolean()),\n  last_name: optional(string()),\n  language_code: optional(string()),\n  photo_url: optional(string()),\n  username: optional(string()),\n} satisfies { [K in keyof User]-?: BaseSchema<unknown, User[K], any> });\n\nexport const InitDataQuerySchema = looseObject({\n  auth_date: pipe(\n    string(),\n    transform(input => new Date(Number(input) * 1000)),\n    date(),\n  ),\n  can_send_after: optional(pipe(string(), transform(Number), integer())),\n  chat: optional(lazy(() => initDataChatJson())),\n  chat_type: optional(string()),\n  chat_instance: optional(string()),\n  hash: string(),\n  query_id: optional(string()),\n  receiver: lazyUser,\n  start_param: optional(string()),\n  signature: string(),\n  user: lazyUser,\n} satisfies { [K in keyof InitData]-?: unknown });", "import { createJsonCamelCaseGen } from '@/camel-casing/createJsonCamelCaseGen.js';\nimport {\n  InitDataChatSchema,\n  InitDataQuerySchema,\n  InitDataUserSchema,\n} from '@/schemas/init-data.js';\nimport { createQueryCamelCaseGen } from '@/camel-casing/createQueryCamelCaseGen.js';\n\nexport const initDataChatJson = createJsonCamelCaseGen(InitDataChatSchema);\n\nexport const initDataUserJson = createJsonCamelCaseGen(InitDataUserSchema);\n\nexport const initDataQuery = createQueryCamelCaseGen(InitDataQuerySchema);", "import type { RGB, RGBShort } from '@telegram-apps/types';\n\n/**\n * Returns true in case, passed value has #RRGGBB format.\n * @param value - value to check.\n */\nexport function isRGB(value: string): value is RGB {\n  return /^#[\\da-f]{6}$/i.test(value);\n}\n\n/**\n * Returns true in case, passed value has #RGB format.\n * @param value - value to check.\n */\nexport function isRGBShort(value: string): value is RGBShort {\n  return /^#[\\da-f]{3}$/i.test(value);\n}\n\n/**\n * Converts passed value to #RRGGBB format. Accepts following color formats:\n * - `#RGB`\n * - `#RRGGBB`\n * - `rgb(1,2,3)`\n * - `rgba(1,2,3,4)`\n * @param value - value to convert.\n * @throws {Error} Passed value does not satisfy any of known RGB formats.\n */\nexport function toRGB(value: string): RGB {\n  const clean = value.replace(/\\s/g, '').toLowerCase();\n  if (isRGB(clean)) {\n    return clean;\n  }\n\n  if (isRGBShort(clean)) {\n    let color: RGB = '#';\n    for (let i = 0; i < 3; i += 1) {\n      color += clean[1 + i].repeat(2);\n    }\n    return color;\n  }\n\n  // Example valid values: rgb(0,3,10) rgba(32,114,8,0)\n  const match = clean.match(/^rgb\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3})\\)$/)\n    || clean.match(/^rgba\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3}),\\d{1,3}\\)$/);\n\n  // If this didn't work as well, we can't extract RGB color from passed text.\n  if (!match) {\n    throw new Error(`Value \"${value}\" does not satisfy any of known RGB formats.`);\n  }\n\n  // Otherwise, take R, G and B components, convert to hex and create #RRGGBB string.\n  return match.slice(1).reduce((acc, component) => {\n    return acc + parseInt(component, 10).toString(16).padStart(2, '0');\n  }, '#') as RGB;\n}\n", "import {\n  check,\n  type CheckAction,\n  number,\n  type NumberSchema,\n  pipe,\n  record,\n  type RecordSchema,\n  type SchemaWithPipe,\n  string,\n  type StringSchema,\n  transform,\n  type TransformAction,\n  union,\n  type UnionSchema,\n} from 'valibot';\nimport type { RGB, KnownThemeParamsKey } from '@telegram-apps/types';\n\nimport {\n  type CamelCaseTransformer,\n  createCamelCaseGen,\n} from '@/camel-casing/createCamelCaseGen.js';\nimport { isRGB } from '@/validation/rgb.js';\n\nexport const themeParams = createCamelCaseGen(\n  record(\n    string(),\n    pipe(\n      union([string(), number()]),\n      transform(value => {\n        return typeof value === 'number'\n          ? `#${(value & 0x00FFFFFF).toString(16).padStart(6, '0')}`\n          : value;\n      }),\n      check(isRGB),\n    ),\n  ),\n) as CamelCaseTransformer<\n  RecordSchema<\n    SchemaWithPipe<[\n      StringSchema<undefined>,\n      TransformAction<string, KnownThemeParamsKey>,\n    ]>,\n    SchemaWithPipe<[\n      UnionSchema<[StringSchema<undefined>, NumberSchema<undefined>], any>,\n      TransformAction<string | number, string>,\n      CheckAction<RGB, undefined>\n    ]>,\n    undefined\n  >\n>;", "import { type BaseSchema, looseObject, optional, pipe, string, transform } from 'valibot';\nimport type { LaunchParams } from '@telegram-apps/types';\n\nimport { themeParams } from '@/generators/themeParams.js';\nimport { initDataQuery } from '@/generators/init-data.js';\nimport { createJsonCamelCaseGen } from '@/camel-casing/createJsonCamelCaseGen.js';\n\nconst OptionalBoolean = optional(\n  pipe(string(), transform(v => v === '1')),\n);\nconst themeParamsJson = createJsonCamelCaseGen(themeParams());\n\nexport const LaunchParamsSchema = looseObject({\n  tgWebAppBotInline: OptionalBoolean,\n  tgWebAppData: optional(initDataQuery()),\n  tgWebAppDefaultColors: optional(themeParamsJson()),\n  tgWebAppFullscreen: OptionalBoolean,\n  tgWebAppPlatform: string(),\n  tgWebAppShowSettings: OptionalBoolean,\n  tgWebAppStartParam: optional(string()),\n  tgWebAppThemeParams: themeParamsJson(),\n  tgWebAppVersion: string(),\n} satisfies { [K in keyof LaunchParams]-?: BaseSchema<unknown, LaunchParams[K], any> });", "import { createQueryCamelCaseGen } from '@/camel-casing/createQueryCamelCaseGen.js';\nimport { LaunchParamsSchema } from '@/schemas/LaunchParamsSchema.js';\n\nexport const launchParamsQuery = createQueryCamelCaseGen(LaunchParamsSchema);\n", "import { InitDataQuerySchema } from '@/schemas/init-data.js';\nimport type { CamelCaseQueryTransformerPipe } from '@/camel-casing/createQueryCamelCaseGen.js';\nimport { createCamelCaseSchemaParserGen } from '@/camel-casing/createCamelCaseSchemaParserGen.js';\nimport { initDataQuery } from '@/generators/init-data.js';\n\nexport const parseInitDataQuery = createCamelCaseSchemaParserGen<\n  string | URLSearchParams,\n  CamelCaseQueryTransformerPipe<typeof InitDataQuerySchema, false>\n>(initDataQuery());\n", "import { createCamelCaseSchemaParserGen } from '@/camel-casing/createCamelCaseSchemaParserGen.js';\nimport type { CamelCaseQueryTransformerPipe } from '@/camel-casing/createQueryCamelCaseGen.js';\nimport { LaunchParamsSchema } from '@/schemas/LaunchParamsSchema.js';\nimport { launchParamsQuery } from '@/generators/launchParamsQuery.js';\n\nexport const parseLaunchParamsQuery = createCamelCaseSchemaParserGen<\n  string | URLSearchParams,\n  CamelCaseQueryTransformerPipe<typeof LaunchParamsSchema, false>\n>(launchParamsQuery());", "import { string, looseObject, unknown, optional } from 'valibot';\n\nexport const MiniAppsMessageSchema = looseObject({\n  eventType: string(),\n  eventData: optional(unknown()),\n});\n", "/**\n * Converts the passed object to query parameters.\n * @param value - value to serialize.\n * @param onObject - function returning serialized object value.\n */\nexport function serializeToQuery(\n  value: object,\n  onObject?: (key: string, value: object) => string,\n): string {\n  onObject ||= (_, value) => JSON.stringify(value);\n\n  return new URLSearchParams(\n    Object\n      .entries(value)\n      .reduce<[string, string][]>((acc, [key, value]) => {\n        if (Array.isArray(value)) {\n          acc.push(...value.map(v => [key, String(v)] as [string, string]));\n        } else {\n          if (value !== null && value !== undefined) {\n            acc.push([\n              key,\n              value instanceof Date\n                ? (value.getTime() / 1000 | 0).toString()\n                : typeof value === 'string' || typeof value === 'number'\n                  ? String(value)\n                  : typeof value === 'boolean'\n                    ? value ? '1' : '0'\n                    : onObject(key, value),\n            ]);\n          }\n        }\n        return acc;\n      }, []),\n  ).toString();\n}", "import { InferOutput } from 'valibot';\nimport { InitData } from '@telegram-apps/types';\n\nimport type { InitDataQuerySchema } from '@/schemas/init-data.js';\nimport { serializeToQuery } from '@/serializers/serializeToQuery.js';\n\nexport type InitDataLike = InferOutput<typeof InitDataQuerySchema> | InitData;\n\n/**\n * Serializes the InitDataQuery shape.\n * @param value - value to serialize.\n */\nexport function serializeInitDataQuery(value: InitDataLike): string {\n  return serializeToQuery(value);\n}", "import type { LaunchParams } from '@telegram-apps/types';\nimport type { InferOutput } from 'valibot';\n\nimport type { LaunchParamsSchema } from '@/schemas/LaunchParamsSchema.js';\nimport { serializeToQuery } from '@/serializers/serializeToQuery.js';\nimport { serializeInitDataQuery } from '@/serializers/serializeInitDataQuery.js';\n\nexport type LaunchParamsLike = InferOutput<typeof LaunchParamsSchema> | LaunchParams;\n\n/**\n * Serializes the LaunchParamsQuery shape.\n * @param value - value to serialize.\n */\nexport function serializeLaunchParamsQuery(value: LaunchParamsLike): string {\n  return serializeToQuery(value, (k, v) => {\n    return k === 'tgWebAppData' ? serializeInitDataQuery(v as any) : JSON.stringify(v);\n  });\n}", "import { is } from 'valibot';\n\nimport { launchParamsQuery } from '@/generators/launchParamsQuery.js';\n\n/**\n * @returns True if the passed value contains valid launch parameters query.\n */\nexport function isLaunchParamsQuery(value: string | URLSearchParams): boolean {\n  try {\n    return is(launchParamsQuery(), value);\n  } catch {\n    return false;\n  }\n}", "export type EventType = string | symbol;\n\n// An event handler can take an optional event argument\n// and should not return a value\nexport type Handler<T = unknown> = (event: T) => void;\nexport type WildcardHandler<T = Record<string, unknown>> = (\n\ttype: keyof T,\n\tevent: T[keyof T]\n) => void;\n\n// An array of all currently registered event handlers for a type\nexport type EventHandlerList<T = unknown> = Array<Handler<T>>;\nexport type WildCardEventHandlerList<T = Record<string, unknown>> = Array<\n\tWildcardHandler<T>\n>;\n\n// A map of event types and their corresponding event handlers.\nexport type EventHandlerMap<Events extends Record<EventType, unknown>> = Map<\n\tkeyof Events | '*',\n\tEventHandlerList<Events[keyof Events]> | WildCardEventHandlerList<Events>\n>;\n\nexport interface Emitter<Events extends Record<EventType, unknown>> {\n\tall: EventHandlerMap<Events>;\n\n\ton<Key extends keyof Events>(type: Key, handler: Handler<Events[Key]>): void;\n\ton(type: '*', handler: WildcardHandler<Events>): void;\n\n\toff<Key extends keyof Events>(\n\t\ttype: Key,\n\t\thandler?: Handler<Events[Key]>\n\t): void;\n\toff(type: '*', handler: WildcardHandler<Events>): void;\n\n\temit<Key extends keyof Events>(type: Key, event: Events[Key]): void;\n\temit<Key extends keyof Events>(\n\t\ttype: undefined extends Events[Key] ? Key : never\n\t): void;\n}\n\n/**\n * Mitt: Tiny (~200b) functional event emitter / pubsub.\n * @name mitt\n * @returns {Mitt}\n */\nexport default function mitt<Events extends Record<EventType, unknown>>(\n\tall?: EventHandlerMap<Events>\n): Emitter<Events> {\n\ttype GenericEventHandler =\n\t\t| Handler<Events[keyof Events]>\n\t\t| WildcardHandler<Events>;\n\tall = all || new Map();\n\n\treturn {\n\t\t/**\n\t\t * A Map of event names to registered handler functions.\n\t\t */\n\t\tall,\n\n\t\t/**\n\t\t * Register an event handler for the given type.\n\t\t * @param {string|symbol} type Type of event to listen for, or `'*'` for all events\n\t\t * @param {Function} handler Function to call in response to given event\n\t\t * @memberOf mitt\n\t\t */\n\t\ton<Key extends keyof Events>(type: Key, handler: GenericEventHandler) {\n\t\t\tconst handlers: Array<GenericEventHandler> | undefined = all!.get(type);\n\t\t\tif (handlers) {\n\t\t\t\thandlers.push(handler);\n\t\t\t} else {\n\t\t\t\tall!.set(type, [handler] as EventHandlerList<Events[keyof Events]>);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Remove an event handler for the given type.\n\t\t * If `handler` is omitted, all handlers of the given type are removed.\n\t\t * @param {string|symbol} type Type of event to unregister `handler` from (`'*'` to remove a wildcard handler)\n\t\t * @param {Function} [handler] Handler function to remove\n\t\t * @memberOf mitt\n\t\t */\n\t\toff<Key extends keyof Events>(type: Key, handler?: GenericEventHandler) {\n\t\t\tconst handlers: Array<GenericEventHandler> | undefined = all!.get(type);\n\t\t\tif (handlers) {\n\t\t\t\tif (handler) {\n\t\t\t\t\thandlers.splice(handlers.indexOf(handler) >>> 0, 1);\n\t\t\t\t} else {\n\t\t\t\t\tall!.set(type, []);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Invoke all handlers for the given type.\n\t\t * If present, `'*'` handlers are invoked after type-matched handlers.\n\t\t *\n\t\t * Note: Manually firing '*' handlers is not supported.\n\t\t *\n\t\t * @param {string|symbol} type The event type to invoke\n\t\t * @param {Any} [evt] Any value (object is recommended and powerful), passed to each handler\n\t\t * @memberOf mitt\n\t\t */\n\t\temit<Key extends keyof Events>(type: Key, evt?: Events[Key]) {\n\t\t\tlet handlers = all!.get(type);\n\t\t\tif (handlers) {\n\t\t\t\t(handlers as EventHandlerList<Events[keyof Events]>)\n\t\t\t\t\t.slice()\n\t\t\t\t\t.map((handler) => {\n\t\t\t\t\t\thandler(evt!);\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\thandlers = all!.get('*');\n\t\t\tif (handlers) {\n\t\t\t\t(handlers as WildCardEventHandlerList<Events>)\n\t\t\t\t\t.slice()\n\t\t\t\t\t.map((handler) => {\n\t\t\t\t\t\thandler(type, evt!);\n\t\t\t\t\t});\n\t\t\t}\n\t\t}\n\t};\n}\n", "import { Signal } from './signal.js';\n\nlet callbacks: Map<Signal<any>, () => void> | undefined;\n\nexport function runInBatchMode(signal: Signal<any>, fn: () => void): void {\n  callbacks && callbacks.set(signal, fn) || fn();\n}\n\n/**\n * Runs the specified function in the batch mode.\n *\n * It makes all signals' subscribers to be called only after signals changes inside the specified\n * function were applied.\n * @param fn - function to run in the batch mode.\n * @example\n * const a = signal(1);\n * const b = signal(1);\n * const c = computed(() => a() + b());\n *\n * function subscriber(value) {\n *   console.log(value);\n * }\n *\n * c.sub(subscriber);\n *\n * batch(() => {\n *   a.set(2);\n *   a.set(3);\n *   b.set(2);\n *   b.set(3);\n * });\n *\n * // Despite the fact that we called signals setters four times, the `subscriber` function will\n * // be called only once. Removing the `batch` function usage will lead to calling the `subscriber`\n * // function four times.\n */\nexport function batch(fn: () => void): void {\n  // There could be a case when a batch is called inside other batches.\n  // In this case, we should just ignore the current call.\n  if (callbacks) {\n    return fn();\n  }\n  callbacks = new Map();\n\n  try {\n    fn();\n  } finally {\n    callbacks.forEach(cb => cb());\n    callbacks = undefined;\n    // TODO: What if something went wrong in fn or its callbacks?\n  }\n}\n", "import { collectSignal } from './computed.js';\nimport { runInBatchMode } from './batch.js';\n\nexport type SubscribeListenerFn<T> = (current: T, previous: T) => void;\nexport type RemoveListenerFn = () => void;\n\nexport interface SignalOptions<T> {\n  /**\n   * Previous and next values comparator.\n   *\n   * This function is used during the actual and incoming values comparison in the `set` method.\n   * If values are considered the same, no subscribers will be called.\n   *\n   * @default Object.is\n   * @param current - the actual value.\n   * @param next - an incoming value.\n   * @returns True if values are considered the same.\n   */\n  equals?: (current: T, next: T) => boolean;\n}\n\nexport interface SubOptions {\n  /**\n   * Should the listener be called only once.\n   */\n  once?: boolean;\n  /**\n   * True if the subscriber was added by another signal.\n   */\n  signal?: boolean;\n}\n\nexport interface Signal<T> {\n  /**\n   * @returns An underlying signal value.\n   */\n  (): T;\n  /**\n   * Destroys the signal removing all bound listeners.\n   *\n   * We usually use this method when the signal is not needed anymore.\n   *\n   * Take note that as long as call of this method removes all bound listeners, computed signals\n   * based on the current one will stop listening to its changes, possibly making it work\n   * improperly.\n   */\n  destroy: () => void;\n  /**\n   * Resets the signal to its initial value.\n   */\n  reset: () => void;\n  /**\n   * Updates the signal notifying all subscribers about changes.\n   * @param value - value to set.\n   */\n  set: (value: T) => void;\n  /**\n   * Adds a new listener, tracking the signal changes.\n   * @param fn - event listener.\n   * @param onceOrOptions - was this listener added for a single call, or additional\n   * options.\n   * @returns A function to remove the bound listener.\n   */\n  sub: (fn: SubscribeListenerFn<T>, onceOrOptions?: boolean | SubOptions) => RemoveListenerFn;\n  /**\n   * Removes a listener, tracking the signal changes.\n   * @param fn - event listener.\n   * @param onceOrOptions - was this listener added for a single call, or additional\n   * options. Default: false\n   */\n  unsub: (fn: SubscribeListenerFn<T>, onceOrOptions?: boolean | SubOptions) => void;\n  /**\n   * Remove all non-signal listeners.\n   */\n  unsubAll: () => void;\n}\n\n/**\n * Creates a new signal with initial value.\n * @param initialValue - initial value.\n * @param options - additional options.\n */\nexport function signal<T>(\n  initialValue: T,\n  options?: SignalOptions<T>,\n): Signal<T>;\n\n/**\n * Creates a new signal without initial value.\n * @param initialValue\n * @param options - additional options.\n */\nexport function signal<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): Signal<T | undefined>;\n\n// #__NO_SIDE_EFFECTS__\nexport function signal<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): Signal<T | undefined> {\n  type CurrentSignal = Signal<T | undefined>;\n\n  options ||= {};\n  const equals = options.equals || Object.is;\n\n  let listeners: [\n    listener: SubscribeListenerFn<T | undefined>,\n    options: Required<SubOptions>\n  ][] = [];\n  let value: ReturnType<CurrentSignal> = initialValue;\n\n  const set: CurrentSignal['set'] = v => {\n    if (!equals(value, v)) {\n      const prev = value;\n      value = v;\n\n      // We are making a copy of listeners as long as they may mutate the listeners' array,\n      // leading to an unexpected behavior.\n      //\n      // We want the setter to make sure that all listeners will be called in predefined\n      // order within a single update frame.\n      runInBatchMode(s, () => {\n        [...listeners].forEach(([fn, once]) => {\n          fn(v, prev);\n\n          // Remove \"once\" listeners.\n          if (once) {\n            unsub(fn, true);\n          }\n        });\n      });\n    }\n  };\n\n  function formatSubOptions(onceOrOptions: boolean | SubOptions | undefined): Required<SubOptions> {\n    const options = typeof onceOrOptions !== 'object'\n      ? { once: onceOrOptions }\n      : onceOrOptions;\n    return {\n      once: options.once || false,\n      signal: options.signal || false,\n    };\n  }\n\n  const unsub: CurrentSignal['unsub'] = (fn, onceOrOptions) => {\n    const options = formatSubOptions(onceOrOptions);\n    const idx = listeners.findIndex(([listener, lOptions]) => {\n      return listener === fn\n        && lOptions.once === options.once\n        && lOptions.signal === options.signal;\n    });\n    if (idx >= 0) {\n      listeners.splice(idx, 1);\n    }\n  };\n\n  const s = Object.assign(\n    function get() {\n      collectSignal(s);\n      return value;\n    },\n    {\n      destroy() {\n        listeners = [];\n      },\n      set,\n      reset() {\n        set(initialValue);\n      },\n      sub(fn, onceOrOptions) {\n        listeners.push([fn, formatSubOptions(onceOrOptions)]);\n        return () => unsub(fn, onceOrOptions);\n      },\n      unsub,\n      unsubAll() {\n        listeners = listeners.filter(l => l[1].signal);\n      },\n    } satisfies Pick<CurrentSignal, 'destroy' | 'set' | 'reset' | 'sub' | 'unsub' | 'unsubAll'>,\n  );\n\n  return s;\n}\n", "import { signal, type Signal, type SignalOptions } from './signal.js';\n\nexport interface Computed<T> extends Omit<Signal<T>, 'set' | 'reset'> {\n  /**\n   * @returns An underlying signal value.\n   */\n  (): T;\n}\n\nconst collectContexts: Set<Signal<unknown>>[] = [];\n\nexport function collectSignal(signal: Signal<any>): void {\n  collectContexts.length && collectContexts[collectContexts.length - 1].add(signal);\n}\n\n/**\n * Creates a signal, which wil be automatically updated if some of its dependant signals were\n * modified.\n * @param fn - computation function.\n * @param options - additional functions.\n */\n// #__NO_SIDE_EFFECTS__\nexport function computed<T>(\n  fn: (prev?: T) => T,\n  options?: SignalOptions<T>,\n): Computed<T> {\n  let deps = new Set<Signal<unknown>>();\n\n  // An underlying signal.\n  let $signal: Signal<T> | undefined;\n\n  function s(): Signal<T> {\n    return $signal || ($signal = signal<T>(compute(), options));\n  }\n\n  function update() {\n    s().set(compute());\n  }\n\n  function compute(): T {\n    // As long as in this iteration, we may receive new signals as dependencies, we stop\n    // listening to the previous signals.\n    deps.forEach(s => {\n      s.unsub(update, { signal: true });\n    });\n\n    // Signals we collected during current computation.\n    const collectedSignals = new Set<Signal<unknown>>();\n    let result: T;\n\n    // Add this set to the global variable, so dependant signals will be catched.\n    collectContexts.push(collectedSignals);\n\n    try {\n      // Run the function and collect all called signals.\n      result = fn();\n    } finally {\n      // Remember to untrack the reactive context.\n      collectContexts.pop();\n    }\n\n    // Start tracking for all dependencies' changes and re-compute the computed value.\n    collectedSignals.forEach(s => {\n      s.sub(update, { signal: true });\n    });\n    deps = collectedSignals;\n\n    return result;\n  }\n\n  return Object.assign(function computed(): T {\n    return s()();\n  }, {\n    destroy() {\n      s().destroy();\n    },\n    sub(...args) {\n      return s().sub(...args);\n    },\n    unsub(...args) {\n      s().unsub(...args);\n    },\n    unsubAll(...args) {\n      s().unsubAll(...args);\n    },\n  } satisfies Pick<Computed<T>, 'destroy' | 'sub' | 'unsub' | 'unsubAll'>);\n}\n", "export type IsErrorOfKindFn<Err> = (value: unknown) => value is Err;\r\n\r\n/**\r\n * Creates a predicate function returning true if the passed value is an instance of the\r\n * specified class.\r\n * @param ErrorClass\r\n * @param type\r\n */\r\nexport function isErrorOfKind<Err extends { type: symbol }>(\r\n  ErrorClass: { new(...args: any[]): Err },\r\n  type: symbol,\r\n): IsErrorOfKindFn<Err> {\r\n  return (value): value is Err => {\r\n    return value instanceof ErrorClass && value.type === type;\r\n  };\r\n}", "import { isErrorOfKind, type IsErrorOfKindFn } from './isErrorOfKind.js';\r\n\r\nexport type ToSuperFn<ConstructorArgs extends any[]> =\r\n  (...args: ConstructorArgs) => Parameters<ErrorConstructor>;\r\n\r\nexport type ToSuperType<ConstructorArgs extends any[]> =\r\n  | ToSuperFn<ConstructorArgs>\r\n  | string\r\n  | Parameters<ErrorConstructor>;\r\n\r\nexport interface CustomErrorWithoutData extends Error {\r\n  type: symbol;\r\n}\r\n\r\nexport interface ErrorClass<ConstructorArgs extends any[]> {\r\n  name: string;\r\n  new(...args: ConstructorArgs): CustomErrorWithoutData;\r\n}\r\n\r\n/**\r\n * @return A new error class with a predefined name.\r\n * @param name - error class name\r\n * @param toSuper - a function converting passed arguments to a list of arguments passed to\r\n * the `Error` constructor. It can also be a message or a list of arguments passed to the\r\n * super constructor.\r\n */\r\nexport function errorClass<ConstructorArgs extends any[] = []>(\r\n  name: string,\r\n  toSuper?: ToSuperType<ConstructorArgs>,\r\n): [\r\n  ErrorClass: ErrorClass<ConstructorArgs>,\r\n  isInstanceOfErrorClass: IsErrorOfKindFn<CustomErrorWithoutData>,\r\n] {\r\n  toSuper ||= [];\r\n  const type = Symbol(name);\r\n\r\n  class CustomError extends Error implements CustomErrorWithoutData {\r\n    type = type;\r\n\r\n    constructor(...args: ConstructorArgs) {\r\n      const params = typeof toSuper === 'function'\r\n        ? toSuper(...args)\r\n        : typeof toSuper === 'string'\r\n          ? [toSuper] as [string]\r\n          : toSuper || [];\r\n      super(...params);\r\n      this.name = name;\r\n    }\r\n  }\r\n\r\n  Object.defineProperty(CustomError, 'name', { value: name });\r\n\r\n  return [CustomError, isErrorOfKind(CustomError, type)];\r\n}\r\n", "import { errorClass, type ToSuperType } from './errorClass.js';\r\nimport { isErrorOfKind, type IsErrorOfKindFn } from './isErrorOfKind.js';\r\n\r\nexport type ToDataFn<ConstructorArgs extends any[], Data> = (...args: ConstructorArgs) => Data;\r\n\r\nexport interface CustomErrorWithData<Data> extends Error {\r\n  type: symbol;\r\n  data: Data;\r\n}\r\n\r\nexport interface ErrorClassWithData<Data, ConstructorArgs extends any[]> {\r\n  name: string;\r\n  new(...args: ConstructorArgs): CustomErrorWithData<Data>;\r\n}\r\n\r\n/**\r\n * @returns A new error class with a predefined name and data type.\r\n * @param name - error name\r\n * @param toData - function converting constructor arguments to data\r\n * @param toSuper - a function converting passed arguments to a list of arguments passed to\r\n * the `Error` constructor. It can also be a message or a list of arguments passed to the\r\n * super constructor.\r\n */\r\nexport function errorClassWithData<Data, ConstructorArgs extends any[] = []>(\r\n  name: string,\r\n  toData: ToDataFn<ConstructorArgs, Data>,\r\n  toSuper?: ToSuperType<ConstructorArgs>,\r\n): [\r\n  ErrorClass: ErrorClassWithData<Data, ConstructorArgs>,\r\n  isInstanceOfErrorClass: IsErrorOfKindFn<CustomErrorWithData<Data>>,\r\n] {\r\n  const type = Symbol(name);\r\n\r\n  class CustomError extends errorClass(name, toSuper)[0] {\r\n    data: Data;\r\n    type = type;\r\n\r\n    constructor(...args: ConstructorArgs) {\r\n      super(...args);\r\n      this.data = toData(...args);\r\n    }\r\n  }\r\n\r\n  Object.defineProperty(CustomError, 'name', { value: name });\r\n\r\n  return [CustomError, isErrorOfKind(CustomError, type)];\r\n}\r\n", "/**\n * Creates a base-64-url encoded ASCII string from the passed value.\n * @param value - the value to encode.\n * @see Learn more about base64url:\n * https://herongyang.com/Encoding/Base64URL-Encoding-Algorithm.html\n * @see Source:\n * https://developer.mozilla.org/ru/docs/Glossary/Base64#solution_1_–_escaping_the_string_before_encoding_it\n */\nexport function encodeBase64Url(value: string): string {\n  // first we use encodeURIComponent to get percent-encoded UTF-8,\n  // then we convert the percent encodings into raw bytes which\n  // can be fed into btoa.\n  return btoa(\n    encodeURIComponent(value).replace(/%([0-9A-F]{2})/g, (_, p1) => {\n      return String.fromCharCode(parseInt(`0x${p1}`));\n    }),\n  )\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_');\n}", "/**\n * Decodes a base-64-url ASCII string.\n * @param value - the value to decode.\n * @throws {DOMException} If the passed value is an invalid base64url string.\n * @see Learn more about base64url:\n * https://herongyang.com/Encoding/Base64URL-Encoding-Algorithm.html\n * @see Source:\n * https://developer.mozilla.org/ru/docs/Glossary/Base64#solution_1_–_escaping_the_string_before_encoding_it\n */\nexport function decodeBase64Url(value: string): string {\n  return decodeURIComponent(\n    atob(value)\n      .replace(/-/g, '+')\n      .replace(/_/g, '/')\n      .split('')\n      .map((c) => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))\n      .join(''),\n  );\n}", "import { looseObject, function as fn, is } from 'valibot';\n\n/**\n * Returns true in case, passed value contains path `TelegramWebviewProxy.postEvent` property and\n * `postEvent` is a function.\n * @param value - value to check.\n */\nexport function hasWebviewProxy<T>(value: T): value is T & {\n  TelegramWebviewProxy: {\n    postEvent: (...args: unknown[]) => unknown;\n  };\n} {\n  return is(\n    looseObject({ TelegramWebviewProxy: looseObject({ postEvent: fn() }) }),\n    value,\n  );\n}\n", "/**\n * @see https://stackoverflow.com/a/326076\n * @returns True, if current environment is iframe.\n */\nexport function isIframe(): boolean {\n  try {\n    return window.self !== window.top;\n  } catch {\n    return true;\n  }\n}\n", "import mitt, {\n  type Emitter,\n  type EventHandlerMap,\n  type EventType,\n  type Handler,\n} from 'mitt';\nimport type { If, IsNever, IsUndefined, Or } from '@telegram-apps/toolkit';\n\nexport type WildcardHandler<E> = Handler<{\n  [K in keyof E]: [K, If<Or<IsNever<E[K]>, IsUndefined<E[K]>>, void, E[K]>]\n}[keyof E]>;\n\nexport interface OnFn<E> {\n  /**\n   * Adds a new listener for the specified event.\n   * @param type - event name.\n   * @param handler - event listener.\n   * @param once - should listener be called only once.\n   * @returns Function to remove bound event listener.\n   */<K extends keyof E>(type: K, handler: Handler<E[K]>, once?: boolean): VoidFunction;\n  /**\n   * Adds a listener for all events.\n   * @param type - event name.\n   * @param handler - event listener.\n   * @param once - should listener be called only once.\n   * @returns Function to remove bound event listener.\n   */\n  (type: '*', handler: WildcardHandler<E>, once?: boolean): VoidFunction;\n}\n\nexport interface OffFn<E> {\n  /**\n   * Removes a listener for the specified event.\n   * @param type - event to listen.\n   * @param handler - event listener to remove.\n   * @param once - had this listener to be called only once.\n   */<K extends keyof E>(type: K, handler: Handler<E[K]>, once?: boolean): void;\n  /**\n   * Removes a listener for all events.\n   * @param type - event to stop listening.\n   * @param handler - event listener to remove.\n   * @param once - had this listener to be called only once.\n   */\n  (type: '*', handler: WildcardHandler<E>, once?: boolean): void;\n}\n\nexport interface EmitFn<E> {\n  <K extends keyof E>(type: K, event: E[K]): void;\n  <K extends keyof E>(type: undefined extends E[K] ? K : never): void;\n}\n\n/**\n * Creates a new enhanced event emitter.\n * @param onFirst - will be called when the first event was added.\n * @param onEmpty - will be called when emitter's listeners' map was emptied.\n */\nexport function createEmitter<E extends object>(\n  onFirst: VoidFunction,\n  onEmpty: VoidFunction,\n): [\n  on: OnFn<E>,\n  off: OffFn<E>,\n  emit: EmitFn<E>,\n  clear: VoidFunction\n] {\n  // To understand the event handlers concept here, let's tell the underlying idea.\n  //\n  // We use a Map, where key is an event name, and the value is a Map we call HandlersMap.\n  //\n  // The HandlersMap is a Map, where the key is an event handler, added by the developer.\n  // The corresponding value is a list of tuples, with an internally generated function and a\n  // boolean value responsible for determining if the handler must be called only once. So, you\n  // can imagine the following map as:\n  //\n  // HandlersMap {\n  //   { developer_handler }: Array<[ internally_created_handler, once ]>;\n  // }\n  //\n  // The value for the key represents an array of tuples, as long as a single handler may be added\n  // many times, and for each addition we add a new tuple entry.\n  //\n  // The handler may also be added to be called only once. Trying to remove such kind of handler\n  // using a different value of the \"once\" argument will lead to nothing. The developer must\n  // specify the same argument value to avoid confusions.\n  //\n  // Here is the final EventToHandlersMap definition:\n  //\n  // EventToHandlersMap {\n  //   { event_name }: HandlersMap {\n  //     { developer_handler }: Array<[ internally_created_handler, once ]>;\n  //   }\n  // }\n  type HandlersMap = Map<\n    (...args: any) => void,\n    [handler: (...args: any) => void, once: boolean][]\n  >;\n\n  const eventToHandlersMap = new Map<keyof E | '*', HandlersMap>();\n\n  const emitter = (mitt as any as {\n    <E extends Record<EventType, unknown>>(all?: EventHandlerMap<E>): Emitter<E>;\n  })<E & Record<string | symbol, unknown>>();\n\n  const off: OffFn<E> = (event: keyof E | '*', handler: (...args: any) => void, once?: boolean) => {\n    once ||= false;\n\n    const handlersMap: HandlersMap = eventToHandlersMap.get(event) || new Map();\n    eventToHandlersMap.set(event, handlersMap);\n\n    const handlers = handlersMap.get(handler) || [];\n    handlersMap.set(handler, handlers);\n\n    const index = handlers.findIndex(item => item[1] === once);\n    if (index >= 0) {\n      // Remove the related handler.\n      emitter.off(event, handlers[index][0]);\n\n      // Remove the handler from the cache array.\n      handlers.splice(index, 1);\n\n      // If after removal, there are no handlers left, we should remove the entry from the cache.\n      if (!handlers.length) {\n        handlersMap.delete(handler);\n        if (!handlersMap.size) {\n          const prevSize = eventToHandlersMap.size;\n          eventToHandlersMap.delete(event);\n          prevSize && !eventToHandlersMap.size && onEmpty();\n        }\n      }\n    }\n  };\n\n  return [\n    function on(event: keyof E | '*', handler: (...args: any[]) => any, once?: boolean) {\n      // The events' map became non-empty. Call the onFirst callback.\n      !eventToHandlersMap.size && onFirst();\n\n      const cleanup = () => {\n        off(event as any, handler, once);\n      };\n\n      const internalHandler = (...args: any[]) => {\n        once && cleanup();\n        if (event === '*') {\n          handler(args);\n        } else {\n          handler(...args);\n        }\n      };\n\n      emitter.on(event, internalHandler);\n\n      // Add this handler to the cache, so we could remove it using the passed listener.\n      const handlersMap: HandlersMap = eventToHandlersMap.get(event) || new Map();\n      eventToHandlersMap.set(event, handlersMap);\n\n      const handlers = handlersMap.get(handler) || [];\n      handlersMap.set(handler, handlers);\n      handlers.push([internalHandler, once || false]);\n\n      return cleanup;\n    },\n    off,\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    emitter.emit,\n    function offAll() {\n      const prevSize = eventToHandlersMap.size;\n      emitter.all.clear();\n      eventToHandlersMap.clear();\n      prevSize && onEmpty();\n    },\n  ];\n}\n", "import type { EventWithoutPayload, EventWithPayload, EventPayload } from '@/events/types/index.js';\n\n/**\n * Emits an event without payload sent from the Telegram native application like it was sent in\n * a default web environment between two iframes.\n *\n * It dispatches a new MessageEvent and expects it to be handled via\n * the `window.addEventListener('message', ...)` call, as a developer would do it to handle\n * messages sent from the parent iframe.\n * @param eventType - event name.\n */\nexport function emitEvent<E extends EventWithoutPayload>(eventType: E): void;\n\n/**\n * Emits an event with payload sent from the Telegram native application like it was sent in\n * a default web environment between two iframes.\n *\n * It dispatches a new MessageEvent and expects it to be handled via\n * the `window.addEventListener('message', ...)` call, as a developer would do it to handle\n * messages sent from the parent iframe.\n * @param eventType - event name.\n * @param eventData - event payload.\n */\nexport function emitEvent<E extends EventWithPayload>(\n  eventType: E,\n  eventData: EventPayload<E>,\n): void;\n\n/**\n * Emits an unknown event sent from the Telegram native application like it was sent in a default\n * web environment between two iframes.\n *\n * It dispatches a new MessageEvent and expects it to be handled via\n * the `window.addEventListener('message', ...)` call, as a developer would do it to handle\n * messages sent from the parent iframe.\n * @param eventType - event name.\n * @param eventData - event payload.\n */\nexport function emitEvent<E extends string>(\n  eventType: E,\n  eventData: E extends EventWithoutPayload\n    ? never\n    : E extends EventWithPayload\n      ? EventPayload<E>\n      : unknown,\n): void;\n\n/**\n * Emits an event sent from the Telegram native application like it was sent in a default web\n * environment between two iframes.\n *\n * It dispatches a new MessageEvent and expects it to be handled via\n * the `window.addEventListener('message', ...)` call, as a developer would do it to handle\n * messages sent from the parent iframe.\n * @param eventType - event name.\n * @param eventData - event payload.\n */\nexport function emitEvent(eventType: string, eventData?: unknown): void {\n  window.dispatchEvent(new MessageEvent('message', {\n    data: JSON.stringify({ eventType, eventData }),\n    // We specify window.parent to imitate the case, the parent iframe sent us this event.\n    source: window.parent,\n  }));\n}\n", "import type { SubscribeListener } from '@/events/types/index.js';\nimport { off, on } from '@/events/emitter.js';\nimport { logger } from '@/logger.js';\n\n/**\n * The package debug mode.\n *\n * Enabling debug mode leads to printing additional messages in the console related to the\n * processes inside the package.\n */\nexport let debug = false;\n\nconst listener: SubscribeListener = event => {\n  logger().log('Event received:', event);\n};\n\n/**\n * Sets the package debug mode.\n *\n * Enabling debug mode leads to printing additional messages in the console related to the\n * processes inside the package.\n * @param value - enable debug mode.\n */\nexport function setDebug(value: boolean): void {\n  if (value !== debug) {\n    debug = value;\n    debug ? on('*', listener) : off('*', listener);\n  }\n}\n", "import { createLogger, type Logger } from '@telegram-apps/toolkit';\nimport { signal } from '@telegram-apps/signals';\n\nimport { debug } from '@/debug.js';\n\nexport const logger = signal<Logger>(createLogger('Bridge', {\n  bgColor: '#9147ff',\n  textColor: 'white',\n  shouldLog() {\n    return debug;\n  },\n}));\n", "/**\n * Defines an enumerable and configurable property with a getter and setter.\n * @param obj - object.\n * @param prop - object property name.\n * @param get - getter to use.\n * @param set - setter to use.\n */\nexport function defineWithAccessors(\n  obj: any,\n  prop: string,\n  get: () => unknown,\n  set: (v: any) => void,\n) {\n  Object.defineProperty(obj, prop, {\n    enumerable: true,\n    configurable: true,\n    get,\n    set,\n  });\n}", "import { defineWithAccessors } from '@/helpers/defineWithAccessors.js';\n\n/**\n * Wires the specified property in the object preventing it from being overwritten. Instead, it\n * enhances the previous value by merging the current one with the passed one.\n * @param obj - object.\n * @param prop - object property to rewire.\n */\nexport function defineEnhanceableProperty(obj: any, prop: string): void {\n  const value = obj[prop];\n  defineWithAccessors(obj, prop, () => value, v => {\n    Object.entries(v).forEach(([objKey, objValue]) => {\n      value[objKey] = objValue;\n    });\n  });\n}", "/**\n * Defines an enumerable, configurable and writable property with initial value.\n * @param obj - object.\n * @param prop - object property name.\n * @param value - value to set.\n */\nexport function defineDefaultProperty(obj: any, prop: string, value: any): void {\n  Object.defineProperty(obj, prop, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value,\n  });\n}", "import { defineWithAccessors } from '@/helpers/defineWithAccessors.js';\nimport { defineDefaultProperty } from '@/helpers/defineDefaultProperty.js';\n\n/**\n * Defines a property, that is a functions compose. Trying to set a value in this property\n * will lead to adding it to a function's pool. The property value will always be equal to a\n * function, calling all collected functions in the pool.\n *\n * Returned function performs a cleanup. It does one of the following:\n * 1. Removes the property if no functions were to the pool added other than the initial one.\n * 2. Sets the value equal to the first added function to the pool after the initial one if\n * the only one additional function was added at all. In other words, if the pool length is equal\n * to 2, the second item will be selected as the property value.\n * 3. Leaves the value equal to a function calling all pool functions, but removes the initially\n * added one.\n * @param obj - object.\n * @param prop - object property.\n * @param initialFn - an initial function to set.\n */\nexport function defineFnComposer(\n  obj: any,\n  prop: string,\n  initialFn: (...args: any) => any,\n): void {\n  const objProp = obj[prop];\n  const pool: any[] = [initialFn];\n\n  // Add the function to the pool.\n  typeof objProp === 'function' && pool.push(objProp);\n\n  // Calls all functions specified in the pool.\n  const callPool = (...args: any) => {\n    pool.forEach(fn => {\n      fn(...args);\n    });\n  };\n\n  // Wrap the callPool function and add \"unwrap\" method to it.\n  const callPoolWrapped = Object.assign((...args: any) => {\n    callPool(...args);\n  }, {\n    // Unwraps the composer.\n    unwrap() {\n      const { length: poolSize } = pool;\n      if (poolSize === 1) {\n        // Only the initial handler is in the pool. In this case we just remove the property.\n        delete obj[prop];\n        return;\n      }\n      if (poolSize === 2) {\n        // Only one additional handler was added. We set it as a value for the property.\n        defineDefaultProperty(obj, prop, pool[1]);\n        return;\n      }\n      // Many additional handlers were added. In this case we remove the initially added function\n      // from the pool and leave the property value almost as is - only \"unwrap\" method will be\n      // removed.\n      pool.unshift(1);\n      defineDefaultProperty(obj, prop, callPool);\n    }\n  });\n\n  // Define the composer.\n  defineWithAccessors(\n    obj,\n    prop,\n    () => callPoolWrapped,\n    value => {\n      pool.push(value);\n    },\n  );\n  return;\n}", "import {\n  type InferOutput,\n  parse,\n  pipe,\n  string,\n  looseObject,\n  optional,\n  unknown,\n  number,\n  boolean,\n  nullish,\n  type BaseSchema,\n} from 'valibot';\nimport { jsonParse, MiniAppsMessageSchema, themeParams } from '@telegram-apps/transformers';\n\nimport { createEmitter } from '@/events/createEmitter.js';\nimport type { EventName, EventPayload, Events } from '@/events/types/index.js';\nimport { emitEvent } from '@/events/emitEvent.js';\nimport { logger } from '@/logger.js';\nimport { defineEnhanceableProperty } from '@/helpers/defineEnhanceableProperty.js';\nimport { defineFnComposer } from '@/helpers/defineFnComposer.js';\n\n/**\n * Transformers for problematic Mini Apps events.\n */\nconst transformers = {\n  clipboard_text_received: looseObject({\n    req_id: string(),\n    data: nullish(string()),\n  }),\n  custom_method_invoked: looseObject({\n    req_id: string(),\n    result: optional(unknown()),\n    error: optional(string()),\n  }),\n  popup_closed: nullish(\n    looseObject({ button_id: nullish(string(), () => undefined) }),\n    {},\n  ),\n  viewport_changed: looseObject({\n    height: number(),\n    width: nullish(number(), () => window.innerWidth),\n    is_state_stable: boolean(),\n    is_expanded: boolean(),\n  }),\n  theme_changed: looseObject({\n    theme_params: themeParams(),\n  }),\n} as const satisfies { [E in EventName]?: BaseSchema<unknown, EventPayload<E>, any> };\n\nfunction listener(event: MessageEvent): void {\n  // Ignore non-parent window messages.\n  if (event.source !== window.parent) {\n    return;\n  }\n\n  // Parse incoming event data.\n  let message: InferOutput<typeof MiniAppsMessageSchema>;\n  try {\n    message = parse(pipe(string(), jsonParse(), MiniAppsMessageSchema), event.data);\n  } catch {\n    // We ignore incorrect messages as they could be generated by any other code.\n    return;\n  }\n\n  const { eventType, eventData } = message;\n  const schema = transformers[eventType as keyof typeof transformers];\n\n  let data: unknown;\n  try {\n    data = schema ? parse(schema, eventData) : eventData;\n  } catch (cause) {\n    return logger().forceError(\n      [\n        `An error occurred processing the \"${eventType}\" event from the Telegram application.`,\n        'Please, file an issue here:',\n        'https://github.com/Telegram-Mini-Apps/telegram-apps/issues/new/choose',\n      ].join('\\n'),\n      message,\n      cause,\n    );\n  }\n  emit(eventType as any, data);\n}\n\nexport const [\n  on,\n  off,\n  emit,\n  offAll,\n] = createEmitter<Events>(\n  () => {\n    const wnd = window as any;\n\n    // Define all functions responsible for receiving an event from the Telegram client.\n    // All these \"ports\" should narrow the communication way to a single specific one - the way\n    // accepted by the web version of Telegram between iframes.\n    //\n    // Here we consider 2 cases:\n    // 1. When the Telegram SDK is already connected. In this case the Telegram SDK already\n    // installed its own ports, and we should rewire them. The cleanup function should also work\n    // properly in this context, removing @telegram-apps/bridge handler only, not\n    // the Telegram SDK one.\n    // 2. When the Telegram SDK is not connected, but probably will be. We know, that\n    // the Telegram SDK is going to overwrite our own handlers. Due to this reason, we should\n    // protect them from being overwritten, but still support handlers defined by the Telegram SDK.\n\n    // TelegramGameProxy.receiveEvent\n    !wnd.TelegramGameProxy && (wnd.TelegramGameProxy = {});\n    defineFnComposer(wnd.TelegramGameProxy, 'receiveEvent', emitEvent);\n    defineEnhanceableProperty(wnd, 'TelegramGameProxy');\n\n    // Telegram.WebView.receiveEvent\n    !wnd.Telegram && (wnd.Telegram = {});\n    !wnd.Telegram.WebView && (wnd.Telegram.WebView = {});\n    defineFnComposer(wnd.Telegram.WebView, 'receiveEvent', emitEvent);\n    defineEnhanceableProperty(wnd.Telegram, 'WebView');\n\n    // TelegramGameProxy_receiveEvent\n    defineFnComposer(wnd, 'TelegramGameProxy_receiveEvent', emitEvent);\n\n    // Add a listener handling events sent from the Telegram web application and also events\n    // generated by the local emitEvent function.\n    // This handler should emit a new event using the library event emitter.\n    window.addEventListener('message', listener);\n  },\n  () => {\n    [\n      ['TelegramGameProxy_receiveEvent'],\n      ['TelegramGameProxy', 'receiveEvent'],\n      ['Telegram', 'WebView', 'receiveEvent'],\n    ].forEach(path => {\n      const wnd = window as any;\n\n      // A tuple, where the first value is the receiveEvent function owner, and the second\n      // value is the receiveEvent itself.\n      let cursor: [any, any] = [undefined, wnd];\n      for (const item of path) {\n        cursor = [cursor[1], cursor[1][item]];\n        if (!cursor[1]) {\n          return;\n        }\n      }\n      const [receiveEventOwner, receiveEvent] = cursor;\n      if ('unwrap' in receiveEvent) {\n        receiveEvent.unwrap();\n        if (\n          receiveEventOwner\n          && receiveEventOwner !== wnd\n          && !Object.keys(receiveEventOwner).length\n        ) {\n          delete wnd[path[0]];\n        }\n      }\n    });\n    window.removeEventListener('message', listener);\n  },\n);\n", "import { errorClass, errorClassWithData } from 'error-kid';\nimport type { Version } from '@telegram-apps/types';\n\nexport const [\n  MethodUnsupportedError,\n  isMethodUnsupportedError,\n] = errorClass<[method: string, version: Version]>(\n  'MethodUnsupportedError',\n  (method, version) => [\n    `Method \"${method}\" is unsupported in Mini Apps version ${version}`,\n  ],\n);\n\nexport const [\n  MethodParameterUnsupportedError,\n  isMethodMethodParameterUnsupportedError,\n] = errorClass<[method: string, param: string, version: Version]>(\n  'MethodParameterUnsupportedError',\n  (method, param, version) => [\n    `Parameter \"${param}\" of \"${method}\" method is unsupported in Mini Apps version ${version}`,\n  ],\n);\n\nexport const [\n  LaunchParamsRetrieveError,\n  isLaunchParamsRetrieveError,\n] = errorClassWithData<\n  { errors: [source: string, error: unknown][] },\n  [[source: string, error: unknown][]]\n>(\n  'LaunchParamsRetrieveError',\n  errors => ({ errors }),\n  errors => [\n    [\n      'Unable to retrieve launch parameters from any known source. Perhaps, you have opened your app outside Telegram?',\n      '📖 Refer to docs for more information:',\n      'https://docs.telegram-mini-apps.com/packages/telegram-apps-bridge/environment',\n      '',\n      'Collected errors:',\n      ...errors.map(([source, error]) => {\n        return `Source: ${source} / ${error instanceof Error ? error.message : String(error)}`;\n      }),\n    ].join('\\n'),\n  ],\n);\n\nexport const [\n  InvalidLaunchParamsError,\n  isInvalidLaunchParamsError,\n] = errorClass<[launchParams: string, cause: unknown]>(\n  'InvalidLaunchParamsError',\n  (launchParams, cause) => [\n    `Invalid value for launch params: ${launchParams}`,\n    { cause },\n  ],\n);\n\nexport const [UnknownEnvError, isUnknownEnvError] = errorClass('UnknownEnvError');\n\nexport const [\n  InvokeCustomMethodError,\n  isInvokeCustomMethodError,\n] = errorClass<[error: string]>(\n  'InvokeCustomMethodError',\n  error => [`Server returned error: ${error}`],\n);", "import { signal } from '@telegram-apps/signals';\n\nimport { logger } from '@/logger.js';\n\nexport type PostMessage = typeof window.parent.postMessage;\n\n/**\n * Signal containing a custom implementation of the method to post a message to the parent\n * window. We usually use it to send a message in web versions of Telegram.\n *\n * Initially, this value contains a function behaving like the `window.parent.postMessage` method.\n */\nexport const postMessageImplementation = signal<PostMessage>((...args: any[]) => {\n  try {\n    window.parent.postMessage(...args as Parameters<PostMessage>);\n  } catch (e) {\n    if (e instanceof SyntaxError) {\n      logger().forceError(\n        'Unable to call window.parent.postMessage due to incorrectly configured target origin. Use the setTargetOrigin method to allow this origin to receive events',\n        e,\n      );\n    } else {\n      logger().forceError(e);\n    }\n  }\n});\n\n/**\n * Posts a message to the parent window. We usually use it to send a message in web versions of\n * Telegram.\n * @param args - `window.parent.postMessage` arguments.\n */\nexport const postMessage: PostMessage = (...args) => {\n  return postMessageImplementation()(...args as unknown as Parameters<PostMessage>);\n};\n", "import { signal } from '@telegram-apps/signals';\n\nimport { logger } from '@/logger.js';\n\n/**\n * Target origin used by the `postEvent` method.\n *\n * You don't need to override this value until you know what you are doing.\n * @default 'https://web.telegram.org'\n */\nexport const targetOrigin = signal('https://web.telegram.org');\n\n/**\n * Sets a new target origin that is being used when calling the `postEvent` function in Telegram\n * web versions.\n * @param origin - allowed target origin value.\n * @see targetOrigin\n */\nexport function setTargetOrigin(origin: string) {\n  targetOrigin.set(origin);\n  logger().log('New target origin set', origin);\n}", "import { is, looseObject, function as fn } from 'valibot';\n\nimport { logger } from '@/logger.js';\nimport { isIframe } from '@/env/isIframe.js';\nimport { hasWebviewProxy } from '@/env/hasWebviewProxy.js';\nimport { UnknownEnvError } from '@/errors.js';\nimport type {\n  MethodName,\n  MethodNameWithOptionalParams,\n  MethodNameWithoutParams,\n  MethodNameWithRequiredParams,\n  MethodParams,\n} from '@/methods/types/index.js';\n\nimport { postMessage } from './postMessage.js';\nimport { targetOrigin } from './targetOrigin.js';\n\nexport type PostEventFn = typeof postEvent;\n\n/**\n * Calls Mini Apps methods requiring parameters.\n * @param method - method name.\n * @param params - options along with params.\n * @throws {UnknownEnvError} The environment is unknown.\n */\nexport function postEvent<Method extends MethodNameWithRequiredParams>(\n  method: Method,\n  params: MethodParams<Method>,\n): void;\n\n/**\n * Calls Mini Apps methods accepting no parameters at all.\n * @param method - method name.\n * @throws {UnknownEnvError} The environment is unknown.\n */\nexport function postEvent(method: MethodNameWithoutParams): void;\n\n/**\n * Calls Mini Apps methods accepting optional parameters.\n * @param method - method name.\n * @param params - options along with params.\n * @throws {UnknownEnvError} The environment is unknown.\n */\nexport function postEvent<Method extends MethodNameWithOptionalParams>(\n  method: Method,\n  params?: MethodParams<Method>,\n): void;\n\nexport function postEvent(\n  eventType: MethodName,\n  eventData?: MethodParams<MethodName>,\n): void {\n  logger().log('Posting event:', eventData ? { eventType, eventData } : { eventType });\n\n  const w = window;\n\n  const message = JSON.stringify({ eventType, eventData });\n\n  // Telegram Web.\n  if (isIframe()) {\n    return postMessage(message, targetOrigin());\n  }\n\n  // Telegram for iOS, macOS, Android and Telegram Desktop.\n  if (hasWebviewProxy(w)) {\n    w.TelegramWebviewProxy.postEvent(eventType, JSON.stringify(eventData));\n    return;\n  }\n\n  // Telegram for Windows Phone or Android.\n  if (is(looseObject({ external: looseObject({ notify: fn() }) }), w)) {\n    w.external.notify(message);\n    return;\n  }\n\n  // Otherwise, the current environment is unknown, and we are not able to send event.\n  throw new UnknownEnvError();\n}\n", "import {\n  createCbCollector,\n  type If,\n  type IsNever,\n} from '@telegram-apps/toolkit';\nimport { AbortablePromise, type PromiseOptions } from 'better-promises';\n\nimport { on } from '@/events/emitter.js';\nimport { postEvent, PostEventFn } from '@/methods/postEvent.js';\nimport type {\n  MethodName,\n  MethodNameWithOptionalParams,\n  MethodNameWithoutParams,\n  MethodNameWithRequiredParams,\n  MethodParams,\n} from '@/methods/types/index.js';\nimport type { EventName, EventPayload } from '@/events/types/events.js';\n\ntype AnyEventName = EventName | EventName[];\n\nexport type RequestCaptureFnEventsPayload<E extends EventName[]> = E extends (infer U extends EventName)[]\n  ? {\n    [K in U]: If<\n      IsNever<EventPayload<K>>,\n      { event: K },\n      { event: K; payload: EventPayload<K> }\n    >\n  }[U]\n  : never;\n\nexport type RequestCaptureEventsFn<E extends EventName[]> = (\n  payload: RequestCaptureFnEventsPayload<E>,\n) => boolean\n\nexport type RequestCaptureEventFn<E extends EventName> = If<\n  IsNever<EventPayload<E>>,\n  () => boolean,\n  (payload: EventPayload<E>) => boolean\n>;\n\nexport type RequestCaptureFn<E extends AnyEventName> = E extends EventName[]\n  ? RequestCaptureEventsFn<E>\n  : E extends EventName\n    ? RequestCaptureEventFn<E>\n    : never;\n\nexport interface RequestOptions<E extends AnyEventName>\n  extends Omit<PromiseOptions, 'rejectOnAbort'> {\n  /**\n   * Should return true if this event should be captured.\n   * The first compatible request will be captured if this property is omitted.\n   */\n  capture?: RequestCaptureFn<E>;\n  /**\n   * Custom function to call mini apps methods.\n   */\n  postEvent?: PostEventFn;\n}\n\nexport type RequestResult<E extends AnyEventName> =\n  E extends (infer U extends EventName)[]\n    ? U extends infer K extends EventName\n      ? If<IsNever<EventPayload<K>>, undefined, EventPayload<K>>\n      : never\n    : E extends EventName\n      ? If<IsNever<EventPayload<E>>, undefined, EventPayload<E>>\n      : never;\n\nexport type RequestFn = typeof request;\n\n/**\n * Performs a request waiting for specified events to occur.\n *\n * This overriding is used for methods, requiring parameters.\n * @param method - method name.\n * @param eventOrEvents - tracked event or events.\n * @param options - additional options.\n */\nexport function request<M extends MethodNameWithRequiredParams, E extends AnyEventName>(\n  method: M,\n  eventOrEvents: E,\n  options: RequestOptions<E> & { params: MethodParams<M> },\n): AbortablePromise<RequestResult<E>>;\n\n/**\n * Performs a request waiting for specified events to occur.\n *\n * This overriding is used for methods with optional parameters.\n * @param method - method name.\n * @param eventOrEvents - tracked event or events.\n * @param options - additional options.\n */\nexport function request<M extends MethodNameWithOptionalParams, E extends AnyEventName>(\n  method: M,\n  eventOrEvents: E,\n  options?: RequestOptions<E> & { params?: MethodParams<M> },\n): AbortablePromise<RequestResult<E>>;\n\n/**\n * Performs a request waiting for specified events to occur.\n *\n * This overriding is used for methods without parameters.\n * @param method - method name.\n * @param eventOrEvents - tracked event or events.\n * @param options - additional options.\n */\nexport function request<M extends MethodNameWithoutParams, E extends AnyEventName>(\n  method: M,\n  eventOrEvents: E,\n  options?: RequestOptions<E>,\n): AbortablePromise<RequestResult<E>>;\n\nexport function request<M extends MethodName, E extends AnyEventName>(\n  method: M,\n  eventOrEvents: E,\n  options?: RequestOptions<E> & { params?: MethodParams<M> },\n): AbortablePromise<RequestResult<E>> {\n  options ||= {};\n  const { capture } = options;\n  const [addCleanup, cleanup] = createCbCollector();\n\n  return new AbortablePromise<RequestResult<E>>((resolve) => {\n    // We need to iterate over all tracked events and create their event listeners.\n    ((Array.isArray(eventOrEvents) ? eventOrEvents : [eventOrEvents])).forEach(event => {\n      // Each event listener waits for the event to occur.\n      // Then, if the capture function was passed, we should check if the event should be captured.\n      // If the function is omitted, we instantly capture the event.\n      addCleanup(\n        on(event, payload => {\n          if (!capture || (\n            Array.isArray(eventOrEvents)\n              ? (capture as RequestCaptureEventsFn<EventName[]>)({\n                event,\n                payload,\n              } as RequestCaptureFnEventsPayload<EventName[]>)\n              : (capture as RequestCaptureEventFn<EventName>)(payload)\n          )) {\n            resolve(payload as RequestResult<E>);\n          }\n        }),\n      );\n    });\n\n    (options.postEvent || postEvent)(method as any, (options as any).params);\n  }, options)\n    .finally(cleanup);\n}\n", "import { isLaunchParamsQuery, parseLaunchParamsQuery } from '@telegram-apps/transformers';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { LaunchParamsRetrieveError } from '@/errors.js';\n\nconst SESSION_STORAGE_KEY = 'launchParams';\n\n/**\n * @param urlString - URL to extract launch parameters from.\n * @returns Launch parameters from the specified URL.\n * @throws Error if function was unable to extract launch parameters from the passed URL.\n */\nfunction fromURL(urlString: string): string {\n  return urlString\n    // Replace everything before this first hashtag or question sign.\n    .replace(/^[^?#]*[?#]/, '')\n    // Replace all hashtags and question signs to make it look like some search params.\n    .replace(/[?#]/g, '&');\n}\n\n/**\n * @returns Launch parameters in a raw format from any known source.\n * @throws {LaunchParamsRetrieveError} Unable to retrieve launch parameters. They are probably\n * invalid.\n */\nexport function retrieveRawLaunchParams(): string {\n  const errors: [source: string, error: unknown][] = [];\n  for (const [retrieve, source] of [\n    // Try to retrieve launch parameters from the current location. This method can return\n    // nothing in case, location was changed, and then the page was reloaded.\n    [() => fromURL(window.location.href), 'window.location.href'],\n    // Then, try using the lower level API - window.performance.\n    [() => {\n      const navigationEntry = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming | undefined;\n      return navigationEntry && fromURL(navigationEntry.name);\n    }, 'performance navigation entries'],\n    [() => getStorageValue<string>(SESSION_STORAGE_KEY), 'local storage'],\n  ] as const) {\n    const v = retrieve();\n    if (!v) {\n      errors.push([source, new Error('Source is empty')]);\n      continue;\n    }\n    if (isLaunchParamsQuery(v)) {\n      setStorageValue(SESSION_STORAGE_KEY, v);\n      return v;\n    }\n    try {\n      parseLaunchParamsQuery(v);\n    } catch (e) {\n      errors.push([source, e]);\n    }\n  }\n  throw new LaunchParamsRetrieveError(errors);\n}", "import { LaunchParamsSchema, parseLaunchParamsQuery } from '@telegram-apps/transformers';\nimport {\n  type DeepConvertSnakeKeysToCamelCase,\n  deepSnakeToCamelObjKeys,\n} from '@telegram-apps/toolkit';\nimport type { InferOutput } from 'valibot';\n\nimport { retrieveRawLaunchParams } from '@/launch-params/retrieveRawLaunchParams.js';\n\nexport type RetrieveLPResult = InferOutput<typeof LaunchParamsSchema>;\nexport type RetrieveLPResultCamelCased =\n  DeepConvertSnakeKeysToCamelCase<InferOutput<typeof LaunchParamsSchema>>;\n\n/**\n * @returns Launch parameters from any known source.\n * @param camelCase - should the output be camel-cased.\n * @throws {LaunchParamsRetrieveError} Unable to retrieve launch parameters. They are probably\n * invalid.\n */\nexport function retrieveLaunchParams(camelCase?: false): RetrieveLPResult;\n\n/**\n * @returns Launch parameters from any known source.\n * @param camelCase - should the output be camel-cased.\n * @throws {LaunchParamsRetrieveError} Unable to retrieve launch parameters. They are probably\n * invalid.\n */\nexport function retrieveLaunchParams(camelCase: true): RetrieveLPResultCamelCased;\n\n/**\n * @returns Launch parameters from any known source.\n * @throws {LaunchParamsRetrieveError} Unable to retrieve launch parameters. They are probably\n * invalid.\n */\nexport function retrieveLaunchParams(camelCase?: boolean):\n  | RetrieveLPResult\n  | RetrieveLPResultCamelCased {\n  const launchParams = parseLaunchParamsQuery(retrieveRawLaunchParams());\n  return camelCase ? deepSnakeToCamelObjKeys(launchParams) : launchParams;\n}\n", "import { AbortablePromise, type PromiseOptions } from 'better-promises';\n\nimport { request } from '@/utils/request.js';\nimport { hasWebviewProxy } from '@/env/hasWebviewProxy.js';\nimport { retrieveLaunchParams } from '@/launch-params/retrieveLaunchParams.js';\n\n/**\n * Returns true if the current environment is Telegram Mini Apps.\n *\n * It uses the `retrieveLaunchParams` function to determine if the environment contains\n * launch parameters. In case it does, true will be returned.\n *\n * In case you need stricter checks, use async override of this function.\n */\nexport function isTMA(): boolean;\n\n/**\n * Returns promise with true if the current environment is Telegram Mini Apps.\n *\n * First of all, it checks if the current environment contains traits specific to the\n * Mini Apps environment.\n * Then, it attempts to call a Mini Apps method and waits for a response to be received.\n *\n * In case you need less strict checks, use sync override of this function.\n */\nexport function isTMA(type: 'complete', options?: PromiseOptions): AbortablePromise<boolean>\n\nexport function isTMA(\n  type?: 'complete',\n  options?: PromiseOptions,\n): boolean | AbortablePromise<boolean> {\n  if (!type) {\n    try {\n      retrieveLaunchParams();\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  return AbortablePromise.fn(async context => {\n    if (hasWebviewProxy(window)) {\n      return true;\n    }\n    try {\n      await request('web_app_request_theme', 'theme_changed', context);\n      return true;\n    } catch {\n      return false;\n    }\n  }, options || { timeout: 100 });\n}\n", "import { is, parse, pipe, string } from 'valibot';\nimport {\n  isLaunchParamsQuery,\n  jsonParse,\n  type LaunchParamsLike,\n  MiniAppsMessageSchema,\n  serializeLaunchParamsQuery,\n  parseLaunchParamsQuery,\n} from '@telegram-apps/transformers';\nimport { If, IsNever, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { logger } from '@/logger.js';\nimport { isIframe } from '@/env/isIframe.js';\nimport type { MethodName, MethodParams } from '@/methods/types/index.js';\nimport { InvalidLaunchParamsError } from '@/errors.js';\nimport { postMessageImplementation } from '@/methods/postMessage.js';\n\n/**\n * Mocks the environment and imitates Telegram Mini Apps behavior.\n *\n * We usually use this function in the following cases:\n * 1. We are developing an application outside the Telegram environment and would like to imitate\n * the Telegram client in order to re-create the same communication behavior.\n * 2. We would like to intercept some Telegram Mini Apps methods' calls in order to enhance them\n * or write a custom behavior. It is extremely useful in some Telegram clients improperly handling\n * Mini Apps methods' calls and not even responding.\n *\n * Note that calling this function in Telegram web clients, the `postMessageImplementation` signal\n * value will be updated with a new one, enhancing previously set signal value to allow wrapping\n * the original `window.parent.postMessage` function. In other words, calling `mockTelegramEnv`\n * function N times, you will effectively wrap previously set implementation N times, so be\n * careful calling this function several times during a single lifecycle of the app. In case you\n * would like to avoid such kind of behavior, use the `resetPostMessage` option.\n */\nexport function mockTelegramEnv({ launchParams, onEvent, resetPostMessage }: {\n  /**\n   * Launch parameters to mock. They will be saved in the storage, so the SDK functions could\n   * retrieve them.\n   *\n   * Note that this value must have `tgWebAppData` presented in a raw format as long as you will\n   * need it when retrieving init data in this format. Otherwise, init data may be broken.\n   */\n  launchParams?:\n    | (Omit<LaunchParamsLike, 'tgWebAppData'> & { tgWebAppData?: string | URLSearchParams })\n    | string\n    | URLSearchParams;\n  /**\n   * Function that will be called if a Mini Apps method call was requested by the mini app.\n   *\n   * It receives a Mini Apps method name along with the passed payload.\n   *\n   * Note that using the `next` function, in non-web environments it uses the\n   * `window.TelegramWebviewProxy.postEvent`.\n   *\n   * Talking about the web versions of Telegram, the value is a bit more complex - it will\n   * equal to the value stored in the `postMessageImplementation` signal set previously. By default,\n   * this value contains a function utilizing the `window.parent.postMessage` method.\n   * @param event - event information.\n   * @param next - function to call the original method used to call a Mini Apps method.\n   */\n  onEvent?: (\n    event: {\n      [M in MethodName]: [M, If<IsNever<MethodParams<M>>, void, MethodParams<M>>]\n    }[MethodName] | [string, unknown],\n    next: () => void,\n  ) => void;\n  /**\n   * Removes all previously set enhancements of the `window.parent.postMessage` function set\n   * by other `mockTelegramEnv` calls.\n   * @default false\n   */\n  resetPostMessage?: boolean;\n} = {}): void {\n  if (launchParams) {\n    // If launch parameters were passed, save them in the session storage, so\n    // the retrieveLaunchParams function would return them.\n    const launchParamsQuery =\n      typeof launchParams === 'string' || launchParams instanceof URLSearchParams\n        ? launchParams.toString()\n        : (\n          // Here we have to trick serializeLaunchParamsQuery into thinking, it serializes a valid\n          // value. We are doing it because we are working with tgWebAppData presented as a\n          // string, not an object as serializeLaunchParamsQuery requires.\n          serializeLaunchParamsQuery({ ...launchParams, tgWebAppData: undefined })\n          // Then, we just append init data.\n          + (launchParams.tgWebAppData ? `&tgWebAppData=${encodeURIComponent(launchParams.tgWebAppData.toString())}` : '')\n        );\n\n    // Remember to check if launch params are valid.\n    if (!isLaunchParamsQuery(launchParamsQuery)) {\n      try {\n        parseLaunchParamsQuery(launchParamsQuery);\n      } catch (e) {\n        throw new InvalidLaunchParamsError(launchParamsQuery, e);\n      }\n    }\n    setStorageValue('launchParams', launchParamsQuery);\n  }\n\n  // Original postEvent firstly checks if the current environment is iframe.\n  // That's why we have a separate branch for this environment here too.\n  if (isIframe()) {\n    if (!onEvent) {\n      return;\n    }\n    const MiniAppsMessageJson = pipe(\n      string(),\n      jsonParse(),\n      MiniAppsMessageSchema,\n    );\n\n    // As long as the postEvent function uses the postMessage method, we should rewire it.\n    resetPostMessage && postMessageImplementation.reset();\n    const original = postMessageImplementation();\n    postMessageImplementation.set((...args) => {\n      const [message] = args;\n      const next = () => {\n        (original as any)(...args);\n      };\n\n      // Pass only Telegram Mini Apps events to the handler. All other calls should be passed\n      // to the original handler (window.parent.postMessage likely).\n      if (is(MiniAppsMessageJson, message)) {\n        const data = parse(MiniAppsMessageJson, message);\n        onEvent([data.eventType, data.eventData], next);\n      } else {\n        next();\n      }\n    });\n\n    return;\n  }\n\n  // In all other environments, it is enough to define window.TelegramWebviewProxy.postEvent.\n  const proxy = (window as any).TelegramWebviewProxy || {};\n  const postEventDefaulted = proxy.postEvent || (() => undefined);\n  (window as any).TelegramWebviewProxy = {\n    ...proxy,\n    postEvent(eventType: string, eventData: string) {\n      const next = () => {\n        postEventDefaulted(eventType, eventData);\n      };\n      onEvent\n        ? onEvent([eventType, eventData ? JSON.parse(eventData) : undefined], next)\n        : next();\n    },\n  };\n\n  logger().log('Environment was mocked by the mockTelegramEnv function');\n}\n", "import { retrieveRawLaunchParams } from '@/launch-params/retrieveRawLaunchParams.js';\n\n/**\n * @returns Raw init data from any known source.\n * @throws {LaunchParamsRetrieveError} Unable to retrieve launch params from any known source.\n */\nexport function retrieveRawInitData(): string | undefined {\n  return new URLSearchParams(retrieveRawLaunchParams()).get('tgWebAppData') || undefined;\n}", "type CaptureSameReqFn = (payload: { req_id: string }) => boolean;\n\n/**\n * Returns a function which can be used in `request` function `capture` property to capture\n * the event with the same request identifier.\n * @param reqId - request identifier.\n */\nexport function captureSameReq(reqId: string): CaptureSameReqFn {\n  return ({ req_id }) => req_id === reqId;\n}\n", "import type { Version } from '@telegram-apps/types';\n\nfunction parts(a: Version): number[] {\n  return a.split('.').map(Number);\n}\n\n/**\n * @param a - first version.\n * @param b - second version.\n * @returns\n * - `1` if the version \"a\" is greater than \"b\".\n * - `0` the version \"a\" is equal to \"b\".\n * - `-1` the version \"a\" is lower than \"b\".\n */\nexport function compareVersions(a: Version, b: Version): number {\n  const aParts = parts(a);\n  const bParts = parts(b);\n  const len = Math.max(aParts.length, bParts.length);\n\n  // Iterate over each part of versions and compare them. In case, part is\n  // missing, assume its value is equal to 0.\n  for (let i = 0; i < len; i += 1) {\n    const aVal = aParts[i] || 0\n    const bVal = bParts[i] || 0;\n\n    if (aVal === bVal) {\n      continue;\n    }\n    return aVal > bVal ? 1 : -1;\n  }\n  return 0;\n}\n", "import type { Version } from '@telegram-apps/types';\n\nimport { compareVersions } from '@/utils/compareVersions.js';\nimport type {\n  MethodName,\n  MethodNameWithVersionedParams,\n  MethodVersionedParams,\n} from '@/methods/types/index.js';\n\n/**\n * Returns true if \"a\" version is less than or equal to \"b\" version.\n * @param a\n * @param b\n */\nfunction versionLessOrEqual(a: Version, b: Version): boolean {\n  return compareVersions(a, b) <= 0;\n}\n\n/**\n * Returns true in case, passed parameter in specified method is supported.\n * @param method - method name\n * @param param - method parameter\n * @param inVersion - platform version.\n */\nexport function supports<M extends MethodNameWithVersionedParams>(\n  method: M,\n  param: MethodVersionedParams<M>,\n  inVersion: Version,\n): boolean;\n\n/**\n * Returns true in case, specified method is supported in a passed version.\n * @param method - method name.\n * @param inVersion - platform version.\n */\nexport function supports(method: MethodName, inVersion: Version): boolean;\n\nexport function supports(\n  method: MethodName,\n  paramOrVersion: Version | string,\n  inVersion?: string,\n): boolean {\n  // Method name, parameter, target version.\n  if (typeof inVersion === 'string') {\n    if (method === 'web_app_open_link') {\n      if (paramOrVersion === 'try_instant_view') {\n        return versionLessOrEqual('6.4', inVersion);\n      }\n      if (paramOrVersion === 'try_browser') {\n        return versionLessOrEqual('7.6', inVersion);\n      }\n    }\n\n    if (method === 'web_app_set_header_color') {\n      if (paramOrVersion === 'color') {\n        return versionLessOrEqual('6.9', inVersion);\n      }\n    }\n\n    if (method === 'web_app_close' && paramOrVersion === 'return_back') {\n      return versionLessOrEqual('7.6', inVersion);\n    }\n\n    if (method === 'web_app_setup_main_button' && paramOrVersion === 'has_shine_effect') {\n      return versionLessOrEqual('7.10', inVersion);\n    }\n  }\n\n  switch (method) {\n    case 'web_app_open_tg_link':\n    case 'web_app_open_invoice':\n    case 'web_app_setup_back_button':\n    case 'web_app_set_background_color':\n    case 'web_app_set_header_color':\n    case 'web_app_trigger_haptic_feedback':\n      return versionLessOrEqual('6.1', paramOrVersion);\n    case 'web_app_open_popup':\n      return versionLessOrEqual('6.2', paramOrVersion);\n    case 'web_app_close_scan_qr_popup':\n    case 'web_app_open_scan_qr_popup':\n    case 'web_app_read_text_from_clipboard':\n      return versionLessOrEqual('6.4', paramOrVersion);\n    case 'web_app_switch_inline_query':\n      return versionLessOrEqual('6.7', paramOrVersion);\n    case 'web_app_invoke_custom_method':\n    case 'web_app_request_write_access':\n    case 'web_app_request_phone':\n      return versionLessOrEqual('6.9', paramOrVersion);\n    case 'web_app_setup_settings_button':\n      return versionLessOrEqual('6.10', paramOrVersion);\n    case 'web_app_biometry_get_info':\n    case 'web_app_biometry_open_settings':\n    case 'web_app_biometry_request_access':\n    case 'web_app_biometry_request_auth':\n    case 'web_app_biometry_update_token':\n      return versionLessOrEqual('7.2', paramOrVersion);\n    case 'web_app_setup_swipe_behavior':\n      return versionLessOrEqual('7.7', paramOrVersion);\n    case 'web_app_share_to_story':\n      return versionLessOrEqual('7.8', paramOrVersion);\n    case 'web_app_setup_secondary_button':\n    case 'web_app_set_bottom_bar_color':\n      return versionLessOrEqual('7.10', paramOrVersion);\n    case 'web_app_request_safe_area':\n    case 'web_app_request_content_safe_area':\n    case 'web_app_request_fullscreen':\n    case 'web_app_exit_fullscreen':\n    case 'web_app_set_emoji_status':\n    case 'web_app_add_to_home_screen':\n    case 'web_app_check_home_screen':\n    case 'web_app_request_emoji_status_access':\n    case 'web_app_check_location':\n    case 'web_app_open_location_settings':\n    case 'web_app_request_file_download':\n    case 'web_app_request_location':\n    case 'web_app_send_prepared_message':\n    case 'web_app_start_accelerometer':\n    case 'web_app_start_device_orientation':\n    case 'web_app_start_gyroscope':\n    case 'web_app_stop_accelerometer':\n    case 'web_app_stop_device_orientation':\n    case 'web_app_stop_gyroscope':\n    case 'web_app_toggle_orientation_lock':\n      return versionLessOrEqual('8.0', paramOrVersion);\n    case 'web_app_device_storage_clear':\n    case 'web_app_device_storage_get_key':\n    case 'web_app_device_storage_save_key':\n    case 'web_app_secure_storage_clear':\n    case 'web_app_secure_storage_get_key':\n    case 'web_app_secure_storage_restore_key':\n    case 'web_app_secure_storage_save_key':\n      return versionLessOrEqual('9.0', paramOrVersion);\n    case 'web_app_hide_keyboard':\n      return versionLessOrEqual('9.1', paramOrVersion);\n    default:\n      return [\n        'iframe_ready',\n        'iframe_will_reload',\n        'web_app_close',\n        'web_app_data_send',\n        'web_app_expand',\n        'web_app_open_link',\n        'web_app_ready',\n        'web_app_request_theme',\n        'web_app_request_viewport',\n        'web_app_setup_main_button',\n        'web_app_setup_closing_behavior',\n      ].includes(method);\n  }\n}\n", "import { any, is, looseObject } from 'valibot';\nimport type { Version } from '@telegram-apps/types';\n\nimport { supports } from '@/methods/supports.js';\nimport { type PostEventFn, postEvent } from '@/methods/postEvent.js';\nimport type {\n  MethodName,\n  MethodNameWithVersionedParams,\n  MethodVersionedParams,\n} from '@/methods/types/index.js';\nimport { MethodParameterUnsupportedError, MethodUnsupportedError } from '@/errors.js';\nimport { logger } from '@/logger.js';\n\nexport type OnUnsupportedFn = (\n  data: { version: Version } & (\n    | { method: MethodName }\n    | {\n    [M in MethodNameWithVersionedParams]: {\n      method: M;\n      param: MethodVersionedParams<M>;\n    };\n  }[MethodNameWithVersionedParams]),\n) => void;\n\nexport type CreatePostEventMode = 'strict' | 'non-strict';\n\n/**\n * Creates a function that checks if the specified method and parameters are supported.\n *\n * If the method or parameters are unsupported, the `onUnsupported` function will be called.\n *\n * If `strict` or `non-strict` value was passed as the second argument, the function\n * will create its own `onUnsupported` function with behavior depending on the value passed.\n *\n * - Passing `strict` will make the function to throw a `MethodParameterUnsupportedError`\n * or a `MethodUnsupportedError` error.\n * - Passing `non-strict` will just warn you about something being unsupported.\n *\n * @param version - Telegram Mini Apps version.\n * @param onUnsupportedOrMode - function or strict mode. Default: `strict`\n */\nexport function createPostEvent(\n  version: Version,\n  onUnsupportedOrMode?: OnUnsupportedFn | CreatePostEventMode,\n): PostEventFn {\n  onUnsupportedOrMode ||= 'strict';\n  const onUnsupported: OnUnsupportedFn = typeof onUnsupportedOrMode === 'function'\n    ? onUnsupportedOrMode\n    : data => {\n      const { method, version } = data;\n      const error = 'param' in data\n        ? new MethodParameterUnsupportedError(method, data.param, version)\n        : new MethodUnsupportedError(method, version);\n\n      if (onUnsupportedOrMode === 'strict') {\n        throw error;\n      }\n      return logger().forceWarn(error.message);\n    };\n\n  return ((method: any, params: any) => {\n    // Firstly, check if the method is supported.\n    if (!supports(method, version)) {\n      return onUnsupported({ version, method });\n    }\n\n    // Method could use parameters, which are supported only in specific versions of Mini Apps.\n    // We are validating only those parameters, which are not backward compatible.\n    if (\n      method === 'web_app_set_header_color'\n      && is(looseObject({ color: any() }), params)\n      && !supports(method, 'color', version)\n    ) {\n      return onUnsupported({ version, method, param: 'color' });\n    }\n\n    return postEvent(method, params);\n  }) as PostEventFn;\n}\n", "import { encodeBase64Url } from '@/base64-url/encodeBase64Url.js';\n\n/**\n * Creates a safe start parameter value. If the value is not a string, the function applies\n * JSON.stringify to it, so make sure you are not passing an object with circular references.\n *\n * @param value - value to create start parameter from.\n * @throws {Error} If the value length is too big for the allowed one.\n * @see Learn more about start parameter:\n * https://docs.telegram-mini-apps.com/platform/start-parameter\n */\nexport function createStartParam(value: unknown): string {\n  const b64 = encodeBase64Url(typeof value === 'string' ? value : JSON.stringify(value));\n  if (b64.length > 512) {\n    throw new Error('Value is too long for start parameter');\n  }\n  return b64;\n}\n", "import { decodeBase64Url } from '@/base64-url/decodeBase64Url.js';\n\n/**\n * Decodes a start parameter using a custom parser.\n * @param value - a start parameter value.\n * @param parse - a custom value parser.\n * @see decodeBase64Url\n */\nexport function decodeStartParam<T>(value: string, parse: (value: string) => T): T;\n/**\n * Decodes a start parameter assuming that the result is a JSON value.\n * @param value - a start parameter value.\n * @param as - result kind.\n * @see decodeBase64Url\n */\nexport function decodeStartParam(value: string, as: 'json'): unknown;\n/**\n * Decodes a start parameter and returns its decoded representation.\n * @param value - a value to decode.\n * @see decodeBase64Url\n */\nexport function decodeStartParam(value: string): string;\nexport function decodeStartParam<T>(\n  value: string,\n  arg2?: 'json' | ((value: string) => T),\n): string | unknown | T {\n  const decoded = decodeBase64Url(value);\n  return arg2 === 'json'\n    ? JSON.parse(decoded)\n    : arg2\n      ? arg2(decoded)\n      : decoded;\n}", "import { encodeBase64Url } from '@/base64-url/encodeBase64Url.js';\n\n/**\n * @returns True if the passed value is safe to be used to create a start parameter value from it.\n * If true is returned, the value can be safely passed to the `createStartParam` function.\n * @param value - value to check.\n * @see createStartParam\n */\nexport function isSafeToCreateStartParam(value: string): boolean {\n  return encodeBase64Url(value).length <= 512;\n}", "import { AbortablePromise } from 'better-promises';\n\nimport { captureSameReq } from '@/methods/captureSameReq.js';\nimport type { CustomMethodName, CustomMethodParams } from '@/methods/types/index.js';\nimport { InvokeCustomMethodError } from '@/errors.js';\n\nimport { request, type RequestOptions } from './request.js';\n\nexport type InvokeCustomMethodOptions = Omit<RequestOptions<'custom_method_invoked'>, 'capture'>;\nexport type InvokeCustomMethodFn = typeof invokeCustomMethod;\n\n/**\n * Invokes known custom method. Returns method execution result.\n * @param method - method name.\n * @param params - method parameters.\n * @param requestId - request identifier.\n * @param options - additional options.\n * @throws {InvokeCustomMethodError} Invocation completed with some error.\n */\nexport function invokeCustomMethod<M extends CustomMethodName>(\n  method: M,\n  params: CustomMethodParams<M>,\n  requestId: string,\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<unknown>;\n\n/**\n * Invokes unknown custom method. Returns method execution result.\n * @param method - method name.\n * @param params - method parameters.\n * @param requestId - request identifier.\n * @param options - additional options.\n * @throws {InvokeCustomMethodError} Invocation completed with some error.\n */\nexport function invokeCustomMethod(\n  method: string,\n  params: object,\n  requestId: string,\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<unknown>;\n\nexport function invokeCustomMethod(\n  method: string,\n  params: object,\n  requestId: string,\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<unknown> {\n  return request('web_app_invoke_custom_method', 'custom_method_invoked', {\n    ...options || {},\n    params: { method, params, req_id: requestId },\n    capture: captureSameReq(requestId),\n  })\n    .then(({ result, error }) => {\n      if (error) {\n        throw new InvokeCustomMethodError(error);\n      }\n      return result;\n    });\n}\n", "/**\n * Applies polyfills required for stable work of the package:\n * - `Object.hasOwn` - used by `valibot`\n */\nexport function applyPolyfills(): void {\n  if (!Object.hasOwn) {\n    Object.hasOwn = function(obj, prop) {\n      return Object.prototype.hasOwnProperty.call(obj, prop);\n    };\n  }\n}", "import { targetOrigin } from '@/methods/targetOrigin.js';\nimport { setDebug } from '@/debug.js';\nimport { offAll } from '@/events/emitter.js';\nimport { postMessageImplementation } from '@/methods/postMessage.js';\n\n/**\n * Resets the package state. Normally, you don't use this function in your application.\n * We are using it only for test purposes.\n */\nexport function resetPackageState() {\n  offAll();\n  setDebug(false);\n  [postMessageImplementation, targetOrigin].forEach(s => {\n    s.unsubAll();\n    s.reset();\n  });\n}", "/**\n * Returns the first navigation entry from window.performance.\n * @returns First navigation entry or null, in case performance functionality is not supported\n * or navigation entry was not found.\n */\nexport function getFirstNavigationEntry(): PerformanceNavigationTiming | undefined {\n  return performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming | undefined;\n}\n", "import { getFirstNavigationEntry } from './getFirstNavigationEntry.js';\n\n/**\n * @returns True, if the current page was reloaded.\n * @see https://stackoverflow.com/a/36444134/11894710\n */\nexport function isPageReload(): boolean {\n  const entry = getFirstNavigationEntry();\n  return !!entry && entry.type === 'reload';\n}\n", "/**\n * Ensures that the specified value starts with the specified prefix. If it doesn't, function\n * appends it.\n * @param value - value to check.\n * @param prefix - prefix to add.\n * @returns Value with the prefix.\n */\nexport function ensurePrefix(value: string, prefix: string): string {\n  return value.startsWith(prefix) ? value : `${prefix}${value}`;\n}\n", "import { ensurePrefix } from '@/ensurePrefix.js';\n\nimport type { URLLike } from './types.js';\n\n/**\n * Safely creates a new instance of URL with some predefined protocol \"http://\" and host \"a\".\n * @param urlOrPath - URL instance or path.\n */\nexport function createSafeURL(urlOrPath: string | Partial<URLLike>): URL {\n  return new URL(\n    typeof urlOrPath === 'string' ? urlOrPath : [\n      urlOrPath.pathname || '',\n      ensurePrefix(urlOrPath.search || '', '?'),\n      ensurePrefix(urlOrPath.hash || '', '#'),\n    ].join(''),\n    'http://a',\n  );\n}\n", "import { createSafeURL } from './createSafeURL.js';\nimport type { URLLike } from './types.js';\n\n/**\n * Extracts path part from a URL.\n * @param urlOrPath - URL instance or path.\n */\nexport function urlToPath(urlOrPath: string | Partial<URLLike>): string {\n  const isAbsolute = (\n    typeof urlOrPath === 'string'\n      ? urlOrPath\n      : urlOrPath.pathname || ''\n  ).startsWith('/');\n  const url = createSafeURL(urlOrPath);\n  const { pathname } = url;\n\n  return `${isAbsolute ? pathname : pathname.slice(1)}${url.search}${url.hash}`;\n}\n", "export const ERR_HISTORY_EMPTY = 'ERR_NAVIGATION_HISTORY_EMPTY';\nexport const ERR_CURSOR_INVALID = 'ERR_NAVIGATION_CURSOR_INVALID';", "import {\n  computed,\n  type Computed,\n  type Signal,\n  signal,\n  type SignalOptions,\n} from '@telegram-apps/signals';\n\nexport type SignalsTuple<T> = [Signal<T>, Computed<T>];\n\nconst signals: (Signal<any> | Computed<any>)[] = [];\n\n/**\n * Creates a new signal with the initial value.\n * @param initialValue - the initial value.\n * @param options - additional options.\n */\nexport function createSignal<T>(\n  initialValue: T,\n  options?: SignalOptions<T>,\n): Signal<T>;\n\n/**\n * Creates a new signal without the initial value.\n * @param initialValue - the initial value.\n * @param options - additional options.\n */\nexport function createSignal<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): Signal<T | undefined>;\n\n// #__NO_SIDE_EFFECTS__\nexport function createSignal<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): Signal<T | undefined> {\n  const s = signal(initialValue, options);\n  signals.push(s);\n  return s;\n}\n\n/**\n * Creates a signal, which wil be automatically updated if some of its dependant signals were\n * modified.\n * @param fn - computation function.\n * @param options - additional functions.\n */\n// #__NO_SIDE_EFFECTS__\nexport function createComputed<T>(fn: (prev?: T) => T, options?: SignalOptions<T>): Computed<T> {\n  const s = computed(fn, options);\n  signals.push(s);\n  return s;\n}\n\n/**\n * Resets all signals states.\n */\nexport function resetSignals() {\n  signals.forEach(s => {\n    s.unsubAll();\n    'reset' in s && s.reset();\n  });\n}\n\n/**\n * @returns A tuple, containing a manual and computed signals. The computed signal is based on\n * the manual one.\n * @param initialValue - the initial value.\n * @param options - additional options.\n */\nexport function createSignalsTuple<T>(\n  initialValue: T,\n  options?: SignalOptions<T>,\n): SignalsTuple<T>;\n\n/**\n * @returns A tuple, containing a manual and computed signals. The computed signal is based on\n * the manual one.\n * @param initialValue - an initial value.\n * @param options - additional options.\n */\nexport function createSignalsTuple<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): SignalsTuple<T | undefined>;\n\n// #__NO_SIDE_EFFECTS__\nexport function createSignalsTuple<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): SignalsTuple<T | undefined> {\n  const s = createSignal(initialValue, options);\n  return [s, createComputed(s)];\n}", "import { setDebug as setBridgeDebug } from '@telegram-apps/bridge';\n\n/**\n * The package debug mode.\n *\n * Enabling debug mode leads to printing additional messages in the console related to the\n * processes inside the package.\n */\nexport let debug = false;\n\n/**\n * Sets the package debug mode leading to outputting additional logs. This function also modifies\n * debug mode set in the `@telegram-apps/bridge` package.\n * @param value - enable debug mode.\n */\nexport function setDebug(value: boolean): void {\n  debug = value;\n  setBridgeDebug(value);\n}", "import { createLogger, type Logger } from '@telegram-apps/toolkit';\nimport { signal } from '@telegram-apps/signals';\n\nimport { debug } from '@/debug.js';\n\nexport type { Logger };\nexport const logger = signal<Logger>(createLogger('Bridge', {\n  bgColor: 'forestgreen',\n  textColor: 'white',\n  shouldLog() {\n    return debug;\n  },\n}));\n", "import {\n  retrieveLaunchParams,\n  postEvent as _postEvent,\n  request as _request,\n  invokeCustomMethod as _invokeCustomMethod,\n  createPostEvent,\n  type PostEventFn,\n  type RequestFn,\n  type InvokeCustomMethodOptions,\n  type CustomMethodParams,\n  type CustomMethodName,\n} from '@telegram-apps/bridge';\nimport type { AbortablePromise } from 'better-promises';\nimport type { LaunchParamsLike } from '@telegram-apps/transformers';\n\nimport { createComputed, createSignal, createSignalsTuple } from '@/signals-registry.js';\nimport { logger } from '@/logger.js';\n\n/**\n * Launch parameters stored in the package state.\n */\nexport type PackageLaunchParams =\n  & Omit<LaunchParamsLike, 'tgWebAppThemeParams'>\n  & Partial<Pick<LaunchParamsLike, 'tgWebAppThemeParams'>>;\n\nexport interface ConfigureOptions {\n  /**\n   * Launch parameters used across the package.\n   * @default Being extracted using the `retrieveLaunchParams` function.\n   * @see retrieveLaunchParams\n   */\n  launchParams?: PackageLaunchParams;\n  /**\n   * Custom postEvent function.\n   * @default The `createPostEvent` function will be used with the version, specified in\n   * the `launchParams` option.\n   * @see createPostEvent\n   */\n  postEvent?: PostEventFn;\n}\n\nconst $lastRequestId = createSignal(0);\nexport const $postEvent = createSignal<PostEventFn>(_postEvent);\nexport const [_$launchParams, $launchParams] = createSignalsTuple<PackageLaunchParams>({\n  tgWebAppPlatform: 'unknown',\n  tgWebAppVersion: '0.0',\n});\n\nexport const version = createComputed(() => $launchParams().tgWebAppVersion);\n\n/**\n * Configures package global dependencies.\n * @param options - configuration additional options.\n */\nexport function configure(options?: ConfigureOptions): void {\n  options ||= {};\n  const { postEvent } = options;\n  const lp = options.launchParams || retrieveLaunchParams();\n  _$launchParams.set(lp);\n  $postEvent.set(\n    typeof postEvent === 'function'\n      ? postEvent\n      : createPostEvent(lp.tgWebAppVersion),\n  );\n  logger().log('The package was configured. Launch params:', _$launchParams());\n}\n\n/**\n * @returns A new request identifier.\n */\nexport function createRequestId(): string {\n  $lastRequestId.set($lastRequestId() + 1);\n  return $lastRequestId().toString();\n}\n\n/**\n * Invokes known custom method. Returns method execution result.\n * @param method - method name.\n * @param params - method parameters.\n * @param options - additional options.\n * @throws {InvokeCustomMethodError} Invocation completed with some error.\n */\nexport function invokeCustomMethod<M extends CustomMethodName>(\n  method: M,\n  params: CustomMethodParams<M>,\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<unknown>;\n\n/**\n * Invokes unknown custom method. Returns method execution result.\n * @param method - method name.\n * @param params - method parameters.\n * @param options - additional options.\n * @throws {InvokeCustomMethodError} Invocation completed with some error.\n */\nexport function invokeCustomMethod(\n  method: string,\n  params: object,\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<unknown>;\n\nexport function invokeCustomMethod(\n  method: string,\n  params: object,\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<unknown> {\n  return _invokeCustomMethod(method, params, createRequestId(), {\n    ...options || {},\n    postEvent: postEvent,\n  });\n}\n\n/**\n * `request` function from the bridge with applied global `postEvent` option.\n */\nexport const request = ((method: any, eventOrEvents: any, options: any) => {\n  options ||= {};\n  options.postEvent ||= postEvent;\n  return _request(method, eventOrEvents, options);\n}) as RequestFn;\n\n/**\n * Shortcut for $postEvent call.\n */\nexport const postEvent = ((method: any, params: any) => {\n  return $postEvent()(method, params);\n}) as PostEventFn;\n", "import { type Computed } from '@telegram-apps/signals';\nimport { type MethodName, supports } from '@telegram-apps/bridge';\n\nimport { version } from '@/globals.js';\nimport { createComputed } from '@/signals-registry.js';\n\n/**\n * @returns A signal indicating if the specified Mini Apps method is supported.\n * @param method - Mini Apps method name\n */\nexport function createIsSupported(method: MethodName): Computed<boolean> {\n  return createComputed(() => supports(method, version()));\n}", "import { errorClass } from 'error-kid';\n\nfunction proxyMessage(message?: string): [string?] {\n  return [message];\n}\n\nexport const [\n  CSSVarsBoundError,\n  isCSSVarsBoundError,\n] = errorClass('CSSVarsBoundError', 'CSS variables are already bound');\n\nexport const [\n  NotAvailableError,\n  isNotAvailableError,\n] = errorClass<[message: string]>('NotAvailableError', proxyMessage);\n\nexport const [\n  InvalidEnvError,\n  isInvalidEnvError,\n] = errorClass<[message?: string]>('InvalidEnvError', proxyMessage);\n\nexport const [\n  FunctionUnavailableError,\n  isFunctionNotAvailableError,\n] = errorClass<[message?: string]>('FunctionNotAvailableError', proxyMessage);\n\nexport const [\n  InvalidArgumentsError,\n  isInvalidArguments,\n] = errorClass<[message: string, cause?: unknown]>(\n  'InvalidArgumentsError',\n  (message, cause) => [message, { cause }],\n);\n\nexport const [\n  ConcurrentCallError,\n  isConcurrentCallError,\n] = errorClass<[message: string]>('ConcurrentCallError', proxyMessage);\n\nexport const [\n  SetEmojiStatusError,\n  isSetEmojiStatusError,\n] = errorClass<[error: string]>(\n  'SetEmojiStatusError',\n  error => [`Failed to set emoji status: ${error}`],\n);\n\nexport const [\n  AccessDeniedError,\n  isAccessDeniedError,\n] = errorClass<[message: string]>('AccessDeniedError', proxyMessage);\n\nexport const [\n  FullscreenFailedError,\n  isFullscreenFailedError,\n] = errorClass<[message: string]>('FullscreenFailedError', proxyMessage);\n\nexport const [\n  ShareMessageError,\n  isShareMessageError,\n] = errorClass<[error: string]>('ShareMessageError', proxyMessage);\n\nexport const [\n  UnknownThemeParamsKeyError,\n  isUnknownThemeParamsKeyError,\n] = errorClass<[key: string]>('UnknownThemeParamsKeyError', key => {\n  return [`Unknown theme params key passed: ${key}`];\n});", "/**\n * @returns True, if current environment is server.\n */\nexport function isSSR(): boolean {\n  return typeof window === 'undefined';\n}\n", "import {\n  type MethodName,\n  supports,\n  isTMA,\n  type MethodNameWithVersionedParams,\n  type MethodVersionedParams,\n} from '@telegram-apps/bridge';\nimport type { Computed } from '@telegram-apps/signals';\nimport type { If, IsNever } from '@telegram-apps/toolkit';\n\nimport { version } from '@/globals.js';\nimport { FunctionUnavailableError } from '@/errors.js';\nimport { isSSR } from '@/utils/isSSR.js';\nimport type { AnyFn } from '@/types.js';\nimport { createComputed } from '@/signals-registry.js';\n\nexport type CustomSupportValidatorFn = () => string | undefined;\n\nexport type IsSupportedType =\n  | MethodName\n  | CustomSupportValidatorFn\n  | (MethodName | CustomSupportValidatorFn)[]\n  | { any: (MethodName | CustomSupportValidatorFn)[] };\n\n/**\n * A map where the key is a method name with versioned parameters, and the value is a tuple\n * containing the method and parameter names. The third tuple value is a function accepting\n * the wrapped function arguments and returning true if support check must be applied.\n */\nexport type Supports<Fn extends AnyFn> = Record<string, {\n  [M in MethodNameWithVersionedParams]: [\n    method: M,\n    param: MethodVersionedParams<M>,\n    shouldCheck: (...args: Parameters<Fn>) => boolean,\n  ];\n}[MethodNameWithVersionedParams]>;\n\nexport type IfAvailableFnResult<Data> = [called: true, data: Data] | [called: false];\n\nexport type SafeWrapped<\n  Fn extends AnyFn,\n  HasSupportCheck extends boolean,\n  SupportsSchema extends Record<string, any>\n> =\n  & Fn\n  & {\n  /**\n   * The signal returning `true` if the function is available in the current environment and\n   * conditions.\n   *\n   * To be more accurate, the method checks the following:\n   * 1. The current environment is Telegram Mini Apps.\n   * 2. The SDK package is initialized.\n   * 3. If passed, the `isSupported` signal returns true.\n   * 4. If passed, the `isMounted` signal returns true.\n   *\n   * *You should use this function when possible because it provides must-have code security\n   * mechanisms and makes a developer sure that he is using the package properly.*\n   *\n   * @returns True if the function is available in the current environment.\n   * @example\n   * if (showBackButton.isAvailable()) {\n   *   showBackButton();\n   * }\n   */\n  isAvailable: Computed<boolean>;\n  /**\n   * Calls the function only in case it is available.\n   *\n   * It uses the `isAvailable` internally to check if the function is supported.\n   * @example\n   * showBackButton.ifAvailable();\n   */\n  ifAvailable(...args: Parameters<Fn>): IfAvailableFnResult<ReturnType<Fn>>;\n}\n  & If<HasSupportCheck, {\n  /**\n   * The signal returning `true` if the function is supported by the Telegram client,\n   * including some possible additional conditions.\n   *\n   * It is highly recommended to use this signal only in certain narrow cases when only the\n   * function support check is required, but not its availability.\n   *\n   * This signal is not applying additional operations like checking if the current environment\n   * is Mini Apps and the SDK is initialized.\n   *\n   * To check if the function is available for use, use the `isAvailable` signal.\n   *\n   * @returns True if this function is supported.\n   * @see isAvailable\n   * @example\n   * if (setMiniAppBottomBarColor.isSupported()) {\n   *   console.log('Mini App bottom bar is supported, but the function may be unavailable');\n   * }\n   */\n  isSupported: Computed<boolean>;\n}, {}>\n  & If<IsNever<SupportsSchema>, {}, {\n  /**\n   * A map where the key is the function-specific option name and value is a signal indicating\n   * if it is supported by the current environment.\n   * @example\n   * if (setHeaderColor.isAvailable()) {\n   *   if (setHeaderColor.supports.rgb()) {\n   *     setHeaderColor('#ffaabb');\n   *   } else {\n   *     setHeaderColor('bg_color');\n   *   }\n   * }\n   */\n  supports: Record<keyof SupportsSchema, Computed<boolean>>\n}>\n\nexport interface WrapSafeOptions<Fn extends AnyFn> {\n  /**\n   * The component name owning the wrapped function.\n   */\n  component?: string;\n  /**\n   * Signal returning true if the owning component is mounted.\n   */\n  isMounted?: () => boolean;\n  /**\n   * Signal returning true if the owning component is mounting.\n   */\n  isMounting?: () => boolean;\n  /**\n   * Value determining if the function is supported by the current environment.\n   */\n  isSupported?: IsSupportedType;\n  /**\n   * A map where the key is a method name with versioned parameters, and the value is a tuple\n   * containing the method and parameter names. The third tuple value is a function accepting\n   * the wrapped function arguments and returning true if support check must be applied.\n   */\n  supports?: Supports<Fn>,\n}\n\n/**\n * Wraps the function enhancing it with the useful utilities described in the SafeWrapped type.\n * @see SafeWrapped\n * @param method - method name\n * @param fn - wrapped function\n */\nexport function wrapSafe<Fn extends AnyFn>(method: string, fn: Fn): SafeWrapped<Fn, false, never>;\n/**\n * Wraps the function enhancing it with the useful utilities described in the SafeWrapped type.\n * @see SafeWrapped\n * @param method - method name\n * @param fn - wrapped function\n * @param options - additional options\n */\nexport function wrapSafe<Fn extends AnyFn, O extends WrapSafeOptions<Fn>>(\n  method: string,\n  fn: Fn,\n  options: O,\n): SafeWrapped<\n  Fn,\n  O extends { isSupported: any } ? true : false,\n  O extends { supports: any } ? O['supports'] : never\n>\n/*@__NO_SIDE_EFFECTS__*/\nexport function wrapSafe<Fn extends AnyFn>(\n  method: string,\n  fn: Fn,\n  options?: WrapSafeOptions<Fn>,\n): SafeWrapped<Fn, boolean, Record<string, any> | never> {\n  options ||= {};\n  const {\n    isSupported: optionsIsSupported,\n    isMounted,\n    isMounting,\n    component,\n    supports: optionSupports,\n  } = options || {};\n\n  const functionId = `${component ? `${component}.` : ''}${method}()`;\n\n  // Simplify the isSupported value to work with an array of validators or a single object.\n  const isSupported = optionsIsSupported\n    ? Array.isArray(optionsIsSupported)\n      // (MethodName | CustomSupportValidator)[]\n      ? optionsIsSupported\n      : typeof optionsIsSupported === 'object' && 'any' in optionsIsSupported\n        // { any: (MethodName | CustomSupportValidator)[] }\n        ? optionsIsSupported\n        // MethodName | CustomSupportValidator\n        : [optionsIsSupported]\n    : undefined;\n\n  /**\n   * @returns True if the specified option is supported.\n   * @param option - option name.\n   */\n  function supportsOption(option: string): boolean {\n    if (optionSupports) {\n      const tuple = optionSupports[option];\n      return supports(tuple[0], tuple[1], version());\n    }\n    return true;\n  }\n\n  /**\n   * @returns All found errors according to the isSupported variable value.\n   */\n  function supportError(): string | undefined {\n    // isSupported was not specified.\n    // In this case, we assume that the function has no dependencies and is always supported.\n    if (!isSupported) {\n      return;\n    }\n\n    function getError(item: MethodName | CustomSupportValidatorFn): string | undefined {\n      return typeof item === 'function'\n        ? item()\n        : supports(item, version())\n          ? undefined\n          : `it is unsupported in Mini Apps version ${version()}`;\n    }\n\n    const isSupportedItems = Array.isArray(isSupported) ? isSupported : isSupported.any;\n    const errors = isSupportedItems.map(getError).filter(Boolean) as string[];\n\n    return Array.isArray(isSupported)\n      // An array is passed. It means, the function is supported only in case no errors were\n      // returned.\n      ? errors[0]\n      // An object with the \"any\" property is passed.\n      // Should return nothing if at least one item didn't return an error.\n      : errors.length === isSupportedItems.length\n        ? errors[errors.length - 1]\n        : undefined;\n  }\n\n  /**\n   * @returns An error related to supports.<name> check.\n   */\n  function supportsOptionError(...args: Parameters<Fn>): string | undefined {\n    for (const k in optionSupports) {\n      if (optionSupports[k][2](...args) && !supportsOption(k)) {\n        return `option ${k} is not supported in Mini Apps version ${version()}`;\n      }\n    }\n  }\n\n  let supportsMap: Record<string, Computed<boolean>> | undefined;\n  if (optionSupports) {\n    supportsMap = {};\n    for (const option in optionSupports) {\n      supportsMap[option] = createComputed(() => supportsOption(option));\n    }\n  }\n\n  const $isSupported = createComputed(() => !supportError());\n  const $isInitialized = createComputed(() => version() !== '0.0');\n  const $isMounted = createComputed(() => !isMounted || isMounted());\n  const $isAvailable = createComputed(\n    () => isTMA()\n      && !isSSR()\n      && $isInitialized()\n      && $isSupported()\n      && $isMounted(),\n  );\n\n  return Object.assign(\n    (...args: Parameters<Fn>): ReturnType<Fn> => {\n      const errMessagePrefix = `Unable to call the ${functionId} ${component ? 'method' : 'function'}:`;\n\n      if (isSSR() || !isTMA()) {\n        throw new FunctionUnavailableError(`${errMessagePrefix} it can't be called outside Mini Apps`);\n      }\n      if (!$isInitialized()) {\n        throw new FunctionUnavailableError(`${errMessagePrefix} the SDK was not initialized. Use the SDK init() function`);\n      }\n      const supportErr = supportError();\n      if (supportErr) {\n        throw new FunctionUnavailableError(`${errMessagePrefix} ${supportErr}`);\n      }\n      const supportsOptionErr = supportsOptionError(...args);\n      if (supportsOptionErr) {\n        throw new FunctionUnavailableError(`${errMessagePrefix} ${supportsOptionErr}`);\n      }\n      if (!$isMounted()) {\n        const message = isMounting && isMounting()\n          ? 'mounting. Wait for the mount completion'\n          : `unmounted. Use the ${component}.mount() method`;\n        throw new FunctionUnavailableError(`${errMessagePrefix} the component is ${message}`);\n      }\n      return fn(...args);\n    },\n    fn,\n    {\n      isAvailable: $isAvailable,\n      ifAvailable(...args: Parameters<Fn>): IfAvailableFnResult<ReturnType<Fn>> {\n        return $isAvailable() ? [true, fn(...args)] : [false];\n      },\n    },\n    isSupported ? { isSupported: $isSupported } : {},\n    supportsMap ? { supports: supportsMap } : {},\n  );\n}\n", "import type { AnyFn } from '@/types.js';\nimport {\n  wrapSafe,\n  type IsSupportedType,\n  type SafeWrapped,\n  type Supports,\n} from '@/scopes/wrappers/wrapSafe.js';\n\nexport interface SafeWrapFn<S extends boolean> {\n  <Fn extends AnyFn>(method: string, fn: Fn): SafeWrapped<Fn, S, never>;\n  <Fn extends AnyFn>(method: string, fn: Fn, isSupported: IsSupportedType): SafeWrapped<Fn, true, never>;\n  <Fn extends AnyFn, S extends Supports<Fn>>(\n    method: string,\n    fn: Fn,\n    isSupported: IsSupportedType,\n    supports: S,\n  ): SafeWrapped<Fn, true, S>;\n}\n\ninterface Options {\n  isMounted?: () => boolean;\n  isSupported?: IsSupportedType;\n}\n\nexport function createWrapSafe(component?: string): SafeWrapFn<false>;\n\nexport function createWrapSafe<O extends Options>(\n  component: string,\n  options: O,\n): SafeWrapFn<O extends { isSupported: any } ? true : false>;\n\nexport function createWrapSafe(\n  component?: string,\n  options?: Options,\n): SafeWrapFn<boolean> {\n  options ||= {};\n  return ((method, fn, overrideIsSupported, supports) => wrapSafe(method, fn, {\n    ...options,\n    isSupported: overrideIsSupported || options.isSupported,\n    supports,\n    component,\n  })) as SafeWrapFn<boolean>;\n}\n", "import type { IsSupportedType } from '@/scopes/wrappers/wrapSafe.js';\nimport { createWrapSafe, type SafeWrapFn } from '@/scopes/wrappers/createWrapSafe.js';\n\nexport function createWrapComplete(\n  component: string,\n  isMounted: () => boolean,\n  isSupported: IsSupportedType,\n): SafeWrapFn<true> {\n  return createWrapSafe(component, { isSupported, isMounted });\n}\n", "import {\n  createWrapSafe,\n  type SafeWrapFn,\n} from '@/scopes/wrappers/createWrapSafe.js';\nimport type { IsSupportedType } from '@/scopes/wrappers/wrapSafe.js';\n\nexport function createWrapSupported(\n  component: string,\n  isSupported: IsSupportedType,\n): SafeWrapFn<true> {\n  return createWrapSafe(component, { isSupported });\n}", "import { off, on, type EventListener } from '@telegram-apps/bridge';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\nimport { isPageReload } from '@telegram-apps/navigation';\n\nimport { createSignalsTuple } from '@/signals-registry.js';\nimport { postEvent } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\n\ntype StorageValue = boolean;\n\nconst SETUP_METHOD_NAME = 'web_app_setup_back_button';\nconst CLICK_EVENT_NAME = 'back_button_pressed';\nconst COMPONENT_NAME = 'backButton';\n\n/**\n * Signal indicating if the Back Button is currently visible.\n */\nexport const [_isVisible, isVisible] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Back Button is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Back Button is supported.\n */\nexport const isSupported = createIsSupported(SETUP_METHOD_NAME);\n\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, _isMounted, SETUP_METHOD_NAME);\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, SETUP_METHOD_NAME);\n\n/**\n * Hides the Back Button.\n * @param\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @since Mini Apps v6.1\n * @example\n * if (hide.isAvailable()) {\n *   hide();\n * }\n */\nexport const hide = wrapComplete('hide', (): void => {\n  setVisibility(false);\n});\n\n/**\n * Mounts the Back Button restoring its state.\n * @param\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.1\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapSupported('mount', (): void => {\n  if (!_isMounted()) {\n    setVisibility(isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || false);\n    _isMounted.set(true);\n  }\n});\n\nfunction setVisibility(value: boolean): void {\n  if (value !== _isVisible()) {\n    postEvent(SETUP_METHOD_NAME, { is_visible: value });\n    setStorageValue<StorageValue>(COMPONENT_NAME, value);\n    _isVisible.set(value);\n  }\n}\n\n/**\n * Adds a new Back Button click listener.\n * @param fn - event listener.\n * @returns A function to remove bound listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.1\n * @example\n * if (onClick.isAvailable()) {\n *   const off = onClick(() => {\n *     console.log('User clicked the Back Button');\n *     off();\n *   });\n * }\n */\nexport const onClick = wrapSupported(\n  'onClick',\n  (fn: EventListener<'back_button_pressed'>): VoidFunction => on(CLICK_EVENT_NAME, fn),\n);\n\n/**\n * Removes the Back Button click listener.\n * @param fn - an event listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.1\n * @example\n * if (offClick.isAvailable()) {\n *   function listener() {\n *     console.log('User clicked the Back Button');\n *     offClick(listener);\n *   }\n *   onClick(listener);\n * }\n */\nexport const offClick = wrapSupported(\n  'offClick',\n  (fn: EventListener<'back_button_pressed'>): void => {\n    off(CLICK_EVENT_NAME, fn);\n  },\n);\n\n/**\n * Shows the Back Button.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @since Mini Apps v6.1\n * @example\n * if (show.isAvailable()) {\n *   show();\n * }\n */\nexport const show = wrapComplete('show', (): void => {\n  setVisibility(true);\n});\n\n/**\n * Unmounts the Back Button.\n *\n * Note that this function does not remove listeners added via the `onClick`\n * function, so you have to remove them on your own.\n * @see onClick\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}\n", "import { AbortablePromise } from 'better-promises';\nimport {\n  batch,\n  type Computed,\n  type Signal,\n} from '@telegram-apps/signals';\nimport { createComputed, createSignalsTuple, type SignalsTuple } from '@/signals-registry.js';\nimport { ConcurrentCallError } from '@/errors.js';\n\nexport function defineNonConcurrentFn<Fn extends (...args: any) => AbortablePromise<any>>(\n  fn: Fn,\n  errorMessage: string,\n  options?: {\n    /**\n     * A signal with the promise to use instead of the generated one.\n     */\n    promise?: Signal<AbortablePromise<Awaited<ReturnType<Fn>>> | undefined>;\n    /**\n     * A signal with the error to use instead of the generated one.\n     */\n    error?: Signal<Error | undefined>;\n  },\n): [\n  fn: Fn,\n  promise: [\n    ...SignalsTuple<AbortablePromise<Awaited<ReturnType<Fn>>> | undefined>,\n    isRequesting: Computed<boolean>,\n  ],\n  error: SignalsTuple<Error | undefined>\n] {\n  options ||= {};\n  const {\n    promise: optionsPromise,\n    error: optionsError,\n  } = options;\n  const [_promise, promise] =\n    optionsPromise\n      ? [optionsPromise, createComputed(optionsPromise)]\n      : createSignalsTuple<AbortablePromise<Awaited<ReturnType<Fn>>> | undefined>();\n  const [_error, error] =\n    optionsError\n      ? [optionsError, createComputed(optionsError)]\n      : createSignalsTuple<Error | undefined>();\n\n  return [\n    Object.assign((...args: Parameters<Fn>): AbortablePromise<Awaited<ReturnType<Fn>>> => {\n      if (_promise()) {\n        const err = new ConcurrentCallError(errorMessage);\n        _error.set(err);\n        return AbortablePromise.reject(err);\n      }\n\n      batch(() => {\n        _promise.set(fn(...args));\n        _error.set(undefined);\n      });\n\n      let error: Error | undefined;\n      return _promise()!\n        .catch(e => {\n          error = e;\n          throw e;\n        })\n        .finally(() => {\n          batch(() => {\n            _promise.set(undefined);\n            _error.set(error);\n          });\n        });\n    }, fn),\n    [_promise, promise, createComputed(() => !!_promise())],\n    [_error, error],\n  ];\n}", "import { batch, type Computed } from '@telegram-apps/signals';\nimport { AbortablePromise } from 'better-promises';\n\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { createSignalsTuple, type SignalsTuple } from '@/signals-registry.js';\n\n/**\n * Creates a mount function for a component.\n * @param component - the component name\n * @param mount - function mounting the component\n * @param onMounted - function that will be called whenever mount was completed.\n */\n// #__NO_SIDE_EFFECTS__\nexport function defineMountFn<Fn extends (...args: any) => AbortablePromise<any>>(\n  component: string,\n  mount: Fn,\n  onMounted: (result: Awaited<ReturnType<Fn>>) => void,\n): [\n  fn: (...args: Parameters<Fn>) => AbortablePromise<void>,\n  promise: [\n    ...SignalsTuple<AbortablePromise<Awaited<ReturnType<Fn>>> | undefined>,\n    isRequesting: Computed<boolean>,\n  ],\n  error: SignalsTuple<Error | undefined>,\n  isMounted: SignalsTuple<boolean>,\n] {\n  const [fn, ...rest] =\n    defineNonConcurrentFn(mount, `The ${component} component is already mounting`);\n  const [_isMounted, isMounted] = createSignalsTuple(false);\n\n  return [\n    (...args) => _isMounted()\n      ? AbortablePromise.resolve()\n      : fn(...args).then(data => {\n        batch(() => {\n          _isMounted.set(true);\n          onMounted(data);\n        });\n      }),\n    ...rest,\n    [_isMounted, isMounted],\n  ];\n}\n", "import { createComputed, createSignalsTuple } from '@/signals-registry.js';\n\nimport type { State } from './types.js';\n\n/**\n * Complete biometry manager state.\n */\nexport const [_state, state] = createSignalsTuple<State>({\n  available: false,\n  type: '',\n  accessGranted: false,\n  accessRequested: false,\n  deviceId: '',\n  tokenSaved: false,\n});\n\n/**\n * Signal indicating biometry is available.\n */\nexport const isAvailable = createComputed(() => _state().available);\n", "import type { EventPayload } from '@telegram-apps/bridge';\nimport type { AbortablePromise } from 'better-promises';\n\nimport { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_biometry_get_info';\n\n/**\n * Requests biometry information.\n * @since Mini Apps v7.2\n * @param options - additional execution options.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (requestBiometry.isAvailable()) {\n *   const biometryState = await requestBiometry();\n * }\n */\nexport const requestBiometry = wrapSafe(\n  'requestBiometry',\n  (options?: RequestOptionsNoCapture): AbortablePromise<EventPayload<'biometry_info_received'>> => {\n    return request(METHOD_NAME, 'biometry_info_received', options);\n  },\n  { isSupported: METHOD_NAME },\n);\n", "import { isCancelledError } from 'better-promises';\n\n/**\n * Throw the value if is not CanceledError.\n * @param e - value to check.\n */\nexport function ignoreCanceled(e: unknown): never | void {\n  if (!isCancelledError(e)) {\n    throw e;\n  }\n}", "import type { AbortablePromise } from 'better-promises';\nimport { ignoreCanceled } from '@/utils/ignoreCanceled.js';\n\n/**\n * Cancels the promise stored in the signal.\n * @param signal - signal with promise.\n */\nexport function signalCancel(signal: () => (AbortablePromise<any> | undefined)): void {\n  const p = signal();\n  p && p.catch(ignoreCanceled).cancel();\n}", "import {\n  on,\n  off,\n  type BiometryTokenUpdateStatus,\n  type BiometryAuthRequestStatus,\n  type EventListener,\n  type EventPayload,\n} from '@telegram-apps/bridge';\nimport { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\nimport { AbortablePromise } from 'better-promises';\n\nimport { postEvent, request } from '@/globals.js';\nimport { defineMountFn } from '@/scopes/defineMountFn.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { NotAvailableError } from '@/errors.js';\n\nimport { _state } from './signals.js';\nimport { requestBiometry } from './requestBiometry.js';\nimport type {\n  State,\n  AuthenticateOptions,\n  RequestAccessOptions,\n  UpdateTokenOptions,\n} from './types.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\n\ntype StorageValue = State;\n\nconst COMPONENT_NAME = 'biometry';\nconst REQUEST_AUTH_METHOD = 'web_app_biometry_request_auth';\nconst INFO_RECEIVED_EVENT = 'biometry_info_received';\n\nconst onBiometryInfoReceived: EventListener<'biometry_info_received'> = e => {\n  setState(eventToState(e));\n};\n\nfunction throwNotAvailable(): never {\n  throw new NotAvailableError('Biometry is not available');\n}\n\n/**\n * Converts `biometry_info_received` to some common shape.\n * @param event - event payload.\n * @see biometry_info_received\n */\nfunction eventToState(event: EventPayload<'biometry_info_received'>): State {\n  let available = false;\n  let tokenSaved = false;\n  let deviceId = '';\n  let accessRequested = false;\n  let type = '';\n  let accessGranted = false;\n  if (event.available) {\n    available = true;\n    tokenSaved = event.token_saved;\n    deviceId = event.device_id;\n    accessRequested = event.access_requested;\n    type = event.type;\n    accessGranted = event.access_granted;\n  }\n  return { available, tokenSaved, deviceId, type, accessGranted, accessRequested };\n}\n\n/**\n * @returns True if the biometry manager is supported.\n */\nexport const isSupported = createIsSupported(REQUEST_AUTH_METHOD);\n\nconst [\n  mountFn,\n  tMountPromise,\n  tMountError,\n  tIsMounted,\n] = defineMountFn(\n  COMPONENT_NAME,\n  abortSignal => {\n    const s = isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME);\n    return s ? AbortablePromise.resolve(s) : requestBiometry({ abortSignal }).then(eventToState);\n  },\n  s => {\n    on(INFO_RECEIVED_EVENT, onBiometryInfoReceived);\n    setState(s);\n  },\n);\n\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, REQUEST_AUTH_METHOD);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, tIsMounted[0], REQUEST_AUTH_METHOD);\n\n/**\n * Mounts the Biometry component.\n * @since Mini Apps v7.2\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mount.isAvailable()) {\n *   await mount();\n * }\n */\nexport const mount = wrapSupported('mount', mountFn);\nexport const [, mountPromise, isMounting] = tMountPromise;\nexport const [, mountError] = tMountError;\nexport const [_isMounted, isMounted] = tIsMounted;\n\nconst [\n  authFn,\n  tAuthPromise,\n  tAuthError,\n] = defineNonConcurrentFn(\n  (options?: AuthenticateOptions): AbortablePromise<{\n    /**\n     * Authentication status.\n     */\n    status: BiometryAuthRequestStatus;\n    /**\n     * Token from the local secure storage saved previously.\n     */\n    token?: string;\n  }> => {\n    return AbortablePromise.fn(async context => {\n      const s = _state();\n      if (!s.available) {\n        throwNotAvailable();\n      }\n      const data = await request(REQUEST_AUTH_METHOD, 'biometry_auth_requested', {\n        ...options,\n        ...context,\n        params: { reason: ((options || {}).reason || '').trim() },\n      });\n      const { token } = data;\n      if (typeof token === 'string') {\n        setState({ ...s, token });\n      }\n      return data;\n    }, options);\n  },\n  'Biometry authentication is already in progress',\n);\n\n/**\n * Attempts to authenticate a user using biometrics and fetch a previously stored secure token.\n * @param options - method options.\n * @since Mini Apps v7.2\n * @returns Token from the local secure storage saved previously or undefined.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {ConcurrentCallError} Biometry authentication is already in progress\n * @throws {NotAvailableError} Biometry is not available\n * @example\n * if (authenticate.isAvailable()) {\n *   const { status, token } = await authenticate({\n *     reason: 'Authenticate to open wallet',\n *   });\n * }\n */\nexport const authenticate = wrapComplete('authenticate', authFn);\nexport const [, authPromise, isAuthenticating] = tAuthPromise;\nexport const [, authError] = tAuthError;\n\n/**\n * Opens the biometric access settings for bots. Useful when you need to request biometrics\n * access to users who haven't granted it yet.\n *\n * _Note that this method can be called only in response to user interaction with the Mini App\n * interface (e.g. a click inside the Mini App or on the main button)_.\n * @since Mini Apps v7.2\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (openSettings.isAvailable()) {\n *   openSettings();\n * }\n */\nexport const openSettings = wrapSupported('openSettings', (): void => {\n  postEvent('web_app_biometry_open_settings');\n});\n\nconst [\n  requestAccessFn,\n  tRequestAccessPromise,\n  tRequestAccessError,\n] = defineNonConcurrentFn(\n  (options?: RequestAccessOptions): AbortablePromise<boolean> => {\n    return AbortablePromise.fn(async context => {\n      const data = await request('web_app_biometry_request_access', INFO_RECEIVED_EVENT, {\n        ...options,\n        ...context,\n        params: { reason: (options || {}).reason || '' },\n      }).then(eventToState);\n\n      if (!data.available) {\n        throwNotAvailable();\n      }\n      setState(data);\n\n      return data.accessGranted;\n    }, options);\n  },\n  'Biometry access request is already in progress',\n);\n\n/**\n * Requests permission to use biometrics.\n * @since Mini Apps v7.2\n * @returns Promise with true, if access was granted.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {ConcurrentCallError} Biometry access request is already in progress\n * @throws {NotAvailableError} Biometry is not available\n * @example\n * if (requestAccess.isAvailable()) {\n *   const accessGranted = await requestAccess({\n *     reason: 'Authenticate to open wallet',\n *   });\n * }\n */\nexport const requestAccess = wrapComplete('requestAccess', requestAccessFn);\nexport const [, requestAccessPromise, isRequestingAccess] = tRequestAccessPromise;\nexport const [, requestAccessError] = tRequestAccessError;\n\nfunction setState(s: State): void {\n  _state.set(s);\n  setStorageValue<StorageValue>(COMPONENT_NAME, s);\n}\n\n/**\n * Unmounts the component.\n */\nexport function unmount() {\n  [authPromise, requestAccessPromise, mountPromise].forEach(signalCancel);\n  off(INFO_RECEIVED_EVENT, onBiometryInfoReceived);\n  _isMounted.set(false);\n}\n\n/**\n * Updates the biometric token in a secure storage on the device.\n * @since Mini Apps v7.2\n * @returns Promise with `true`, if token was updated.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example Setting a new token\n * if (updateToken.isAvailable()) {\n *   updateToken({\n *     token: 'abcdef',\n *   })\n * }\n * @example Deleting the token\n * if (updateToken.isAvailable()) {\n *   updateToken();\n * }\n */\nexport const updateToken = wrapComplete(\n  'updateToken',\n  (options?: UpdateTokenOptions): AbortablePromise<BiometryTokenUpdateStatus> => {\n    options ||= {};\n    return request('web_app_biometry_update_token', 'biometry_token_updated', {\n      ...options,\n      params: {\n        token: options.token || '',\n        reason: options.reason,\n      },\n    }).then(r => r.status);\n  },\n);\n", "import { createWrapSafe, type SafeWrapFn } from '@/scopes/wrappers/createWrapSafe.js';\n\nexport function createWrapMounted(\n  component: string,\n  isMounted: () => boolean,\n): SafeWrapFn<false> {\n  return createWrapSafe(component, { isMounted });\n}", "import { createWrapSafe } from '@/scopes/wrappers/createWrapSafe.js';\n\nexport const createWrapBasic = createWrapSafe;", "import { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { postEvent } from '@/globals.js';\nimport { createWrapMounted } from '@/scopes/wrappers/createWrapMounted.js';\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { createSignalsTuple } from '@/signals-registry.js';\n\ntype StorageValue = boolean;\n\nconst COMPONENT_NAME = 'closingBehavior';\n\n/**\n * Signal indicating if the confirmation dialog should be shown, while the user\n * is trying to close the Mini App.\n */\nexport const [_isConfirmationEnabled, isConfirmationEnabled] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Closing Behavior component is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\nconst wrapMounted = createWrapMounted(COMPONENT_NAME, isMounted);\nconst wrapBasic = createWrapBasic(COMPONENT_NAME);\n\n/**\n * Disables the closing confirmation dialog.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (disableConfirmation.isAvailable()) {\n *   disableConfirmation();\n * }\n */\nexport const disableConfirmation = wrapMounted('disableConfirmation', (): void => {\n  setClosingConfirmation(false);\n});\n\n/**\n * Enables the closing confirmation dialog.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (enableConfirmation.isAvailable()) {\n *   enableConfirmation();\n * }\n */\nexport const enableConfirmation = wrapMounted('enableConfirmation', (): void => {\n  setClosingConfirmation(true);\n});\n\n/**\n * Mounts the Closing Behavior component restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapBasic('mount', (): void => {\n  if (!_isMounted()) {\n    setClosingConfirmation(\n      isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || false,\n    );\n    _isMounted.set(true);\n  }\n});\n\nfunction setClosingConfirmation(value: boolean): void {\n  if (value !== _isConfirmationEnabled()) {\n    postEvent('web_app_setup_closing_behavior', { need_confirmation: value });\n    setStorageValue<StorageValue>(COMPONENT_NAME, value);\n    _isConfirmationEnabled.set(value);\n  }\n}\n\n/**\n * Unmounts the Closing Behavior component.\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}\n", "import { AbortablePromise } from 'better-promises';\nimport { array, parse, record, string } from 'valibot';\n\nimport { invokeCustomMethod } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport type { InvokeCustomMethodOptions } from '@telegram-apps/bridge';\n\nconst INVOKE_METHOD_NAME = 'web_app_invoke_custom_method';\nconst wrapSupported = createWrapSupported('cloudStorage', INVOKE_METHOD_NAME);\n\n/**\n * Signal indicating if the Cloud Storage is supported.\n */\nexport const isSupported = createIsSupported(INVOKE_METHOD_NAME);\n\n/**\n * Deletes specified key or keys from the cloud storage.\n * @param keyOrKeys - key or keys to delete.\n * @param options - request execution options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example Deleting a single key\n * if (deleteItem.isAvailable()) {\n *   await deleteItem('my-key');\n * }\n * @example Deleting multiple keys\n * if (deleteItem.isAvailable()) {\n *   await deleteItem(['key1', 'key2']);\n * }\n */\nexport const deleteItem = wrapSupported('deleteItem', (\n  keyOrKeys: string | string[],\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<void> => {\n  const keys = Array.isArray(keyOrKeys) ? keyOrKeys : [keyOrKeys];\n  return keys.length\n    ? invokeCustomMethod('deleteStorageValues', { keys }, options).then()\n    : AbortablePromise.resolve();\n});\n\n/**\n * Gets multiple keys' values from the cloud storage.\n * @param keys - keys list.\n * @param options - request execution options.\n * @returns Map, where a key is one of the specified in the `keys` argument,\n * and a value is a corresponding storage value.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (deleteItem.isAvailable()) {\n *   const { key1, key2 } = await getItem(['key1', 'key2']);\n * }\n */\nfunction _getItem<K extends string>(\n  keys: K[],\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<Record<K, string>>;\n\n/**\n * Gets a single key value from the cloud storage.\n * @param key - cloud storage key.\n * @param options - request execution options.\n * @return Value of the specified key. If the key was not created previously,\n * the function will return an empty string.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (getItem.isAvailable()) {\n *   const keyValue = await getItem('my-key');\n * }\n */\nfunction _getItem(key: string, options?: InvokeCustomMethodOptions): AbortablePromise<string>;\n\nfunction _getItem(\n  keyOrKeys: string | string[],\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<string | Record<string, string>> {\n  const keys = Array.isArray(keyOrKeys) ? keyOrKeys : [keyOrKeys];\n\n  return keys.length\n    ? invokeCustomMethod('getStorageValues', { keys }, options).then(data => {\n      const response = {\n        // Fulfill the response with probably missing keys.\n        ...keys.reduce<Record<string, string>>((acc, key) => {\n          acc[key] = '';\n          return acc;\n        }, {}),\n        ...parse(record(string(), string()), data),\n      };\n\n      return typeof keyOrKeys === 'string' ? response[keyOrKeys] : response;\n    })\n    : AbortablePromise.resolve(Array.isArray(keyOrKeys) ? {} : '');\n}\n\nexport const getItem = wrapSupported('getItem', _getItem);\n\n/**\n * Returns a list of all keys presented in the cloud storage.\n * @param options - request execution options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (getKeys.isAvailable()) {\n *   const keysArray = await getKeys();\n * }\n */\nexport const getKeys = wrapSupported('getKeys', (\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<string[]> => {\n  return invokeCustomMethod('getStorageKeys', {}, options).then(\n    data => parse(array(string()), data),\n  );\n});\n\n/**\n * Saves the specified value by a key.\n * @param key - storage key.\n * @param value - storage value.\n * @param options - request execution options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (setItem.isAvailable()) {\n *   await setItem('key', 'value');\n * }\n */\nexport const setItem = wrapSupported('setItem', (\n  key: string,\n  value: string,\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<void> => {\n  return invokeCustomMethod('saveStorageValue', {\n    key,\n    value,\n  }, options).then();\n});\n\n/**\n * Clears the cloud storage.\n * @param options - additional options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (clear.isAvailable()) {\n *   await clear();\n * }\n */\nexport const clear = wrapSupported('clear', (\n  options?: InvokeCustomMethodOptions,\n) => getKeys(options).then(deleteItem));", "import type {\n  ImpactHapticFeedbackStyle,\n  NotificationHapticFeedbackType,\n} from '@telegram-apps/bridge';\n\nimport { postEvent } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\n\nconst HAPTIC_METHOD_NAME = 'web_app_trigger_haptic_feedback';\nconst wrapSupported = createWrapSupported('hapticFeedback', HAPTIC_METHOD_NAME);\n\n/**\n * Signal indicating if the Haptic Feedback is supported.\n */\nexport const isSupported = createIsSupported(HAPTIC_METHOD_NAME);\n\n/**\n * A method that tells if an impact occurred. The Telegram app may play the\n * appropriate haptics based on style value passed.\n * @param style - impact style.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (impactOccurred.isAvailable()) {\n *   impactOccurred('medium');\n * }\n */\nexport const impactOccurred = wrapSupported(\n  'impactOccurred',\n  (style: ImpactHapticFeedbackStyle): void => {\n    postEvent(HAPTIC_METHOD_NAME, {\n      type: 'impact',\n      impact_style: style,\n    });\n  },\n);\n\n/**\n * A method tells that a task or action has succeeded, failed, or produced\n * a warning. The Telegram app may play the appropriate haptics based on type\n * value passed.\n * @param type - notification type.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (notificationOccurred.isAvailable()) {\n *   notificationOccurred('success');\n * }\n */\nexport const notificationOccurred = wrapSupported(\n  'notificationOccurred',\n  (type: NotificationHapticFeedbackType): void => {\n    postEvent(HAPTIC_METHOD_NAME, {\n      type: 'notification',\n      notification_type: type,\n    });\n  },\n);\n\n/**\n * A method tells that the user has changed a selection. The Telegram app may\n * play the appropriate haptics.\n *\n * Do not use this feedback when the user makes or confirms a selection; use\n * it only when the selection changes.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (selectionChanged.isAvailable()) {\n *   selectionChanged();\n * }\n */\nexport const selectionChanged = wrapSupported(\n  'selectionChanged',\n  (): void => {\n    postEvent(HAPTIC_METHOD_NAME, { type: 'selection_change' });\n  },\n);\n", "import type { Computed } from '@telegram-apps/signals';\nimport { retrieveLaunchParams, retrieveRawInitData } from '@telegram-apps/bridge';\nimport type { InitData } from '@telegram-apps/types';\n\nimport { createComputed, createSignalsTuple } from '@/signals-registry.js';\n\n/**\n * Complete component state.\n */\nexport const [_state, state] =\n  createSignalsTuple<InitData | undefined>(undefined);\n\nfunction fromState<K extends keyof InitData>(key: K): Computed<InitData[K] | undefined> {\n  return createComputed(() => {\n    const s = _state();\n    return s ? s[key] : undefined;\n  });\n}\n\n/**\n * @see InitData.auth_date\n */\nexport const authDate = fromState('auth_date');\n\n/**\n * @see InitData.can_send_after\n */\nexport const canSendAfter = fromState('can_send_after');\n\n/**\n * Date after which it is allowed to call\n * the [answerWebAppQuery](https://core.telegram.org/bots/api#answerwebappquery) method.\n */\nexport const canSendAfterDate = createComputed(() => {\n  const authDateValue = authDate();\n  const canSendAfterValue = canSendAfter();\n\n  return canSendAfterValue && authDateValue\n    ? new Date(authDateValue.getTime() + canSendAfterValue * 1000)\n    : undefined;\n});\n\n/**\n * @see InitData.chat\n */\nexport const chat = fromState('chat');\n\n/**\n * @see InitData.chat_type\n */\nexport const chatType = fromState('chat_type');\n\n/**\n * @see InitData.chat_instance\n */\nexport const chatInstance = fromState('chat_instance');\n\n/**\n * @see InitData.hash\n */\nexport const hash = fromState('hash');\n\n/**\n * @see InitData.query_id\n */\nexport const queryId = fromState('query_id');\n\n/**\n * Raw representation of init data.\n */\nexport const [_raw, raw] = createSignalsTuple<string | undefined>();\n\n/**\n * @see InitData.receiver\n */\nexport const receiver = fromState('receiver');\n\n/**\n * Restores the component state.\n */\nexport function restore(): void {\n  const lp = retrieveLaunchParams();\n  _state.set(lp.tgWebAppData);\n  _raw.set(retrieveRawInitData());\n}\n\n/**\n * @see InitData.start_param\n */\nexport const startParam = fromState('start_param');\n\n/**\n * @see InitData.user\n */\nexport const user = fromState('user');", "import type { InvoiceStatus } from '@telegram-apps/bridge';\nimport type { AbortablePromise } from 'better-promises';\n\nimport { request } from '@/globals.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { InvalidArgumentsError } from '@/errors.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_open_invoice';\nconst wrapSupported = createWrapSupported('invoice', METHOD_NAME);\n\n/**\n * Signal indicating if invoices are supported.\n */\nexport const isSupported = createIsSupported(METHOD_NAME);\n\n/**\n * Opens an invoice using its slug.\n * @param slug - invoice slug.\n * @param options - additional options.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {InvalidArgumentsError} An invoice is already opened\n * @example\n * if (open.isAvailable()) {\n *   const status = await open('kJNFS331');\n * }\n */\nfunction _open(slug: string, options?: RequestOptionsNoCapture): AbortablePromise<InvoiceStatus>;\n\n/**\n * Opens an invoice using its url.\n * @param url - invoice URL.\n * @param type - value type.\n * @param options - additional options.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {InvalidArgumentsError} An invoice is already opened\n * @throws {InvalidArgumentsError} Link has unexpected hostname\n * @example\n * if (open.isAvailable()) {\n *   const status = await open('https://t.me/$kJNFS331', 'url');\n * }\n * @example\n * if (open.isAvailable()) {\n *   const status = await open('https://t.me/invoice/kJNFS331', 'url');\n * }\n */\nfunction _open(url: string, type: 'url', options?: RequestOptionsNoCapture): AbortablePromise<InvoiceStatus>;\n\nfunction _open(\n  urlOrSlug: string,\n  optionsOrType?: 'url' | RequestOptionsNoCapture,\n  options?: RequestOptionsNoCapture,\n): AbortablePromise<InvoiceStatus> {\n  let slug: string;\n  if (optionsOrType === 'url') {\n    const { hostname, pathname } = new URL(urlOrSlug, window.location.href);\n    if (hostname !== 't.me') {\n      throw new InvalidArgumentsError(`Link has unexpected hostname: ${hostname}`);\n    }\n\n    // Valid examples:\n    // \"/invoice/my-slug\"\n    // \"/$my-slug\"\n    const match = pathname.match(/^\\/(\\$|invoice\\/)([A-Za-z0-9\\-_=]+)$/);\n    if (!match) {\n      throw new InvalidArgumentsError(\n        `Expected to receive a link with a pathname in format \"/invoice/{slug}\" or \"/\\${slug}\"`,\n      );\n    }\n    [, , slug] = match;\n  } else {\n    // todo: validate slug?\n    slug = urlOrSlug;\n    options = optionsOrType;\n  }\n\n  return request(METHOD_NAME, 'invoice_closed', {\n    ...options,\n    params: { slug },\n    capture: (data) => slug === data.slug,\n  })\n    .then(d => d.status);\n}\n\nconst [\n  fn,\n  tOpenPromise,\n  tOpenError,\n] = defineNonConcurrentFn(_open, 'Invoice is already opened');\n\nexport const open = wrapSupported('open', fn);\nexport const [, openPromise, isOpened] = tOpenPromise;\nexport const [, openError] = tOpenError;\n", "import { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, Maybe, setStorageValue } from '@telegram-apps/toolkit';\nimport { AbortablePromise } from 'better-promises';\nimport type { EventPayload } from '@telegram-apps/bridge';\nimport type { Computed } from '@telegram-apps/signals';\n\nimport { defineMountFn } from '@/scopes/defineMountFn.js';\nimport { postEvent, request } from '@/globals.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { NotAvailableError } from '@/errors.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\nimport type { AsyncOptions } from '@/types.js';\nimport { createComputed, createSignal } from '@/signals-registry.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\n\nconst COMPONENT_NAME = 'locationManager';\nconst CHECK_LOCATION_METHOD = 'web_app_check_location';\nconst OPEN_SETTINGS_METHOD = 'web_app_open_location_settings';\n\nexport interface State {\n  /**\n   * If true, indicates that location data tracking is available on the current device.\n   */\n  available: boolean;\n  /**\n   * Indicates whether the app has previously requested permission to track location data.\n   */\n  accessRequested: boolean;\n  /**\n   * Indicates whether the user has granted the app permission to track location data.\n   *\n   * If false and `accessRequested` is true may indicate that:\n   *\n   * - The user has simply canceled the permission popup.\n   * - The user has denied the app permission to track location data.\n   */\n  accessGranted: boolean;\n}\n\ntype StorageValue = State;\n\nconst state = createSignal<State>({\n  available: false,\n  accessGranted: false,\n  accessRequested: false,\n});\n\nfunction fromState<K extends keyof State>(key: K): Computed<State[K]> {\n  return createComputed(() => state()[key]);\n}\n\n/**\n * Signal indicating whether the location data tracking is currently supported.\n */\nexport const isSupported = createIsSupported(CHECK_LOCATION_METHOD);\n\n/**\n * Signal indicating whether the location data tracking is currently available.\n */\nexport const isAvailable = fromState('available');\n\n/**\n * Signal indicating whether the user has granted the app permission to track location data.\n */\nexport const isAccessGranted = fromState('accessGranted');\n\n/**\n * Signal indicating whether the app has previously requested permission to track location data.\n */\nexport const isAccessRequested = fromState('accessRequested');\n\n/**\n * Converts `location_checked` to some common shape.\n * @param event - event payload.\n * @see location_checked\n */\nfunction eventToState(event: EventPayload<'location_checked'>): State {\n  let available = false;\n  let accessRequested: Maybe<boolean>;\n  let accessGranted: Maybe<boolean>;\n  if (event.available) {\n    available = true;\n    accessRequested = event.access_requested;\n    accessGranted = event.access_granted;\n  }\n  return {\n    available,\n    accessGranted: accessGranted || false,\n    accessRequested: accessRequested || false,\n  };\n}\n\nconst [\n  mountFn,\n  tMountPromise,\n  tMountError,\n  tIsMounted,\n] = defineMountFn(\n  COMPONENT_NAME,\n  (options?: AsyncOptions) => {\n    const s = isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME);\n    return s\n      ? AbortablePromise.resolve(s)\n      : request('web_app_check_location', 'location_checked', options).then(eventToState);\n  },\n  s => {\n    state.set(s);\n    setStorageValue<State>(COMPONENT_NAME, s);\n  },\n);\n\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, CHECK_LOCATION_METHOD);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, tIsMounted[0], CHECK_LOCATION_METHOD);\n\n/**\n * Mounts the location manager component.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mount.isAvailable()) {\n *   await mount();\n * }\n */\nexport const mount = wrapSupported('mount', mountFn);\nexport const [, mountPromise, isMounting] = tMountPromise;\nexport const [, mountError] = tMountError;\nexport const [_isMounted, isMounted] = tIsMounted;\n\nconst [\n  reqLocationFn,\n  tReqLocationPromise,\n  tReqLocationError,\n] = defineNonConcurrentFn(\n  (options?: AsyncOptions) => {\n    return request('web_app_request_location', 'location_requested', options).then(data => {\n      if (!data.available) {\n        state.set({ ...state(), available: false });\n        throw new NotAvailableError('Location data tracking is not available');\n      }\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const { available, ...rest } = data;\n      return rest;\n    });\n  },\n  'Location request is currently in progress',\n);\n\n\n/**\n * Requests location data.\n * @since Mini Apps v8.0\n * @returns Promise with location data.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {ConcurrentCallError} Location request is currently in progress\n * @throws {NotAvailableError} Location data tracking is not available\n * @example\n * if (requestLocation.isAvailable()) {\n *   const location = await requestLocation();\n * }\n */\nexport const requestLocation = wrapComplete('requestLocation', reqLocationFn);\nexport const [, requestLocationPromise, isRequestingLocation] = tReqLocationPromise;\nexport const [, requestLocationError] = tReqLocationError;\n\n/**\n * Opens the location access settings for bots. Useful when you need to request location access\n * from users who haven't granted it yet.\n *\n * Note that this method can be called only in response to user interaction with the Mini App\n * interface (e.g., a click inside the Mini App or on the main button).\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (openSettings.isAvailable()) {\n *   openSettings();\n * }\n */\nexport const openSettings = wrapSupported('openSettings', () => {\n  postEvent(OPEN_SETTINGS_METHOD);\n}, OPEN_SETTINGS_METHOD);\n\n/**\n * Unmounts the component.\n */\nexport function unmount(): void {\n  signalCancel(requestLocationPromise);\n  _isMounted.set(false);\n}", "import type { UnionRequiredKeys } from '@telegram-apps/toolkit';\n\ntype RemoveUndefined<T> = {\n  [K in UnionRequiredKeys<T>]-?: T[K]\n};\n\n/**\n * @returns Object with keys having undefined values.\n * @param value - an object to remove undefined values from.\n */\nexport function removeUndefined<T extends {}>(value: T): RemoveUndefined<T> {\n  const result = {} as RemoveUndefined<T>;\n  for (const k in value) {\n    const v = value[k];\n    v !== undefined && ((result as any)[k] = v);\n  }\n  return result;\n}", "import { toRGB } from '@telegram-apps/transformers';\n\n/**\n * @param color - color in any format acceptable by the `toRGB` function.\n * @returns True if the color is recognized as dark.\n * @see toRGB\n */\nexport function isColorDark(color: string): boolean {\n  const rgb = toRGB(color);\n\n  // Real formula: hsp = Math.sqrt(0.299 * r * r + 0.587 * g * g + 0.114 * b * b)\n  // See: https://stackoverflow.com/a/596243\n  return Math.sqrt(\n    [0.299, 0.587, 0.114].reduce<number>((acc, modifier, idx) => {\n      // Extract part of #RRGGBB pattern and convert it to DEC.\n      const dec = parseInt(rgb.slice(1 + idx * 2, 1 + (idx + 1) * 2), 16);\n      return acc + dec * dec * modifier;\n    }, 0),\n  ) < 120;\n}\n", "import type { ThemeParams } from '@telegram-apps/types';\nimport type { Computed } from '@telegram-apps/signals';\n\nimport { isColorDark } from '@/utils/isColorDark.js';\nimport { createComputed, createSignalsTuple } from '@/signals-registry.js';\n\n/**\n * True if CSS variables are currently bound.\n */\nexport const [_isCssVarsBound, isCssVarsBound] = createSignalsTuple(false);\n\n/**\n * Complete component state.\n */\nexport const [_state, state] = createSignalsTuple<ThemeParams>({});\n\nfunction fromState<K extends keyof ThemeParams>(key: K): Computed<ThemeParams[K] | undefined> {\n  return createComputed(() => _state()[key]);\n}\n\n/**\n * @since v6.10\n */\nexport const accentTextColor = fromState('accent_text_color');\n\nexport const backgroundColor = fromState('bg_color');\n\nexport const buttonColor = fromState('button_color');\n\nexport const buttonTextColor = fromState('button_text_color');\n\n/**\n * @since v7.10\n */\nexport const bottomBarBgColor = fromState('bottom_bar_bg_color');\n\nexport const destructiveTextColor = fromState('destructive_text_color');\n\n/**\n * @since v6.10\n */\nexport const headerBackgroundColor = fromState('header_bg_color');\n\nexport const hintColor = fromState('hint_color');\n\n/**\n * @returns True if the current color scheme is recognized as dark.\n * This value is calculated based on the current theme's background color.\n */\nexport const isDark = createComputed(() => {\n  const color = backgroundColor();\n  return !color || isColorDark(color);\n});\n\nexport const linkColor = fromState('link_color');\n\nexport const secondaryBackgroundColor = fromState('secondary_bg_color');\n\n/**\n * @since v6.10\n */\nexport const sectionBackgroundColor = fromState('section_bg_color');\n\n/**\n * @since v6.10\n */\nexport const sectionHeaderTextColor = fromState('section_header_text_color');\n\n/**\n * @since v7.6\n */\nexport const sectionSeparatorColor = fromState('section_separator_color');\n\n/**\n * @since v6.10\n */\nexport const subtitleTextColor = fromState('subtitle_text_color');\n\nexport const textColor = fromState('text_color');\n", "import type { Computed } from '@telegram-apps/signals';\n\nimport {\n  buttonColor,\n  buttonTextColor,\n} from '@/scopes/components/theme-params/signals.js';\nimport { createComputed, createSignal, createSignalsTuple } from '@/signals-registry.js';\n\nimport type { State } from './types.js';\n\nfunction fromState<K extends keyof Required<State>>(\n  key: K,\n): Computed<Required<State>[K]> {\n  return createComputed(() => state()[key]);\n}\n\nexport const internalState = createSignal<State>({\n  hasShineEffect: false,\n  isEnabled: true,\n  isLoaderVisible: false,\n  isVisible: false,\n  text: 'Continue',\n});\n\n/**\n * Complete component state.\n */\nexport const state = createComputed<Required<State>>(() => {\n  const s = internalState();\n  return {\n    ...s,\n    backgroundColor: s.backgroundColor || buttonColor() || '#2481cc',\n    textColor: s.textColor || buttonTextColor() || '#ffffff',\n  };\n});\n\n/**\n * Signal indicating if the Main Button is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\n/**\n * Signal containing the current Main Button background color.\n */\nexport const backgroundColor = fromState('backgroundColor');\n\n/**\n * Signal indicating if the Main Button has a shining effect.\n */\nexport const hasShineEffect = fromState('hasShineEffect');\n\n/**\n * Signal indicating if the Main Button is currently active and can be clicked.\n */\nexport const isEnabled = fromState('isEnabled');\n\n/**\n * Signal indicating if the Main Button displays a loader inside it.\n */\nexport const isLoaderVisible = fromState('isLoaderVisible');\n\n/**\n * Signal indicating if the Main Button is currently visible.\n */\nexport const isVisible = fromState('isVisible');\n\n/**\n * Signal containing the Main Button text.\n */\nexport const text = fromState('text');\n\n/**\n * Signal containing the current Main Button text color.\n */\nexport const textColor = fromState('textColor');\n", "import {\n  off,\n  on,\n  type EventListener,\n} from '@telegram-apps/bridge';\nimport { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { postEvent } from '@/globals.js';\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { createWrapMounted } from '@/scopes/wrappers/createWrapMounted.js';\nimport { removeUndefined } from '@/utils/removeUndefined.js';\n\nimport { internalState, isMounted, state, _isMounted } from './signals.js';\nimport type { State } from './types.js';\n\ntype StorageValue = State;\n\nconst SETUP_METHOD_NAME = 'web_app_setup_main_button';\nconst CLICK_EVENT_NAME = 'main_button_pressed';\nconst COMPONENT_NAME = 'mainButton';\n\nconst wrapBasic = createWrapBasic(COMPONENT_NAME);\nconst wrapMounted = createWrapMounted(COMPONENT_NAME, isMounted);\n\n/**\n * Mounts the Main Button restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapBasic('mount', (): void => {\n  if (!_isMounted()) {\n    const prev = isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME);\n    prev && internalState.set(prev);\n    _isMounted.set(true);\n  }\n});\n\n/**\n * Adds a new Main Button click listener.\n * @param fn - event listener.\n * @returns A function to remove bound listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (onClick.isAvailable()) {\n *   const off = onClick(() => {\n *     console.log('User clicked the Main Button');\n *     off();\n *   });\n * }\n */\nexport const onClick = wrapBasic(\n  'onClick',\n  (fn: EventListener<'main_button_pressed'>): VoidFunction => {\n    return on(CLICK_EVENT_NAME, fn);\n  },\n);\n\n/**\n * Removes the Main Button click listener.\n * @param fn - an event listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (offClick.isAvailable()) {\n *   function listener() {\n *     console.log('User clicked the Main Button');\n *     offClick(listener);\n *   }\n *   onClick(listener);\n * }\n */\nexport const offClick = wrapBasic(\n  'offClick',\n  (fn: EventListener<'main_button_pressed'>): void => {\n    off(CLICK_EVENT_NAME, fn);\n  },\n);\n\n/**\n * Updates the Main Button state.\n * @param updates - state changes to perform.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example\n * if (setParams.isAvailable()) {\n *   setParams({\n *     text: 'Submit',\n *     isEnabled: true,\n *     hasShineEffect: true,\n *   });\n * }\n */\nexport const setParams = wrapMounted(\n  'setParams',\n  (updates: Partial<State>): void => {\n    internalState.set({ ...internalState(), ...removeUndefined(updates) });\n    setStorageValue<StorageValue>(COMPONENT_NAME, internalState());\n\n    // We should not commit changes until the payload is correct.\n    // Some version of Telegram will crash due to the empty value of the text.\n    const s = state();\n    s.text && postEvent(SETUP_METHOD_NAME, {\n      color: s.backgroundColor,\n      has_shine_effect: s.hasShineEffect,\n      is_active: s.isEnabled,\n      is_progress_visible: s.isLoaderVisible,\n      is_visible: s.isVisible,\n      text: s.text,\n      text_color: s.textColor,\n    });\n  },\n);\n\n/**\n * Unmounts the Main Button.\n *\n * Note that this function does not remove listeners added via the `onClick`\n * function, so you have to remove them on your own.\n * @see onClick\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}\n", "/**\n * Sets CSS variable globally.\n * @param name - variable name.\n * @param value - variable value.\n */\nexport function setCssVar(name: string, value: string | null): void {\n  document.documentElement.style.setProperty(name, value);\n}\n\n/**\n * Deletes specified CSS variable.\n * @param name - variable name.\n */\nexport function deleteCssVar(name: string): void {\n  document.documentElement.style.removeProperty(name);\n}\n", "import {\n  off,\n  on,\n  type EventListener,\n} from '@telegram-apps/bridge';\nimport { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue, snakeToKebab } from '@telegram-apps/toolkit';\nimport { batch } from '@telegram-apps/signals';\nimport type { RGB, ThemeParams } from '@telegram-apps/types';\nimport { AbortablePromise } from 'better-promises';\n\nimport { createWrapMounted } from '@/scopes/wrappers/createWrapMounted.js';\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { deleteCssVar, setCssVar } from '@/utils/css-vars.js';\nimport { CSSVarsBoundError } from '@/errors.js';\nimport { defineMountFn } from '@/scopes/defineMountFn.js';\nimport { $launchParams } from '@/globals.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nimport { _isCssVarsBound, _state } from './signals.js';\nimport type { GetCssVarNameFn } from './types.js';\n\ntype StorageValue = ThemeParams;\n\nconst COMPONENT_NAME = 'themeParams';\nconst THEME_CHANGED_EVENT = 'theme_changed';\nconst wrapBasic = createWrapBasic(COMPONENT_NAME);\n\nconst onThemeChanged: EventListener<'theme_changed'> = ({ theme_params: value }) => {\n  _state.set(value);\n  setStorageValue<StorageValue>(COMPONENT_NAME, value);\n};\n\nconst [\n  mountFn,\n  tMountPromise,\n  tMountError,\n  tIsMounted,\n] = defineMountFn(\n  COMPONENT_NAME,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  (_options?: RequestOptionsNoCapture): AbortablePromise<ThemeParams> => {\n    return AbortablePromise.resolve(\n      (isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME))\n      || $launchParams().tgWebAppThemeParams\n      || {},\n    );\n  },\n  s => {\n    on(THEME_CHANGED_EVENT, onThemeChanged);\n    _state.set(s);\n  },\n);\n\nconst wrapMounted = createWrapMounted(COMPONENT_NAME, tIsMounted[0]);\n\n/**\n * Creates CSS variables connected with the current theme parameters.\n *\n * By default, created CSS variables names are following the pattern \"--tg-theme-{name}\", where\n * {name} is a theme parameters key name converted from snake case to kebab case.\n *\n * Default variables:\n * - `--tg-theme-bg-color`\n * - `--tg-theme-secondary-text-color`\n *\n * Variables are being automatically updated if theme parameters were changed.\n *\n * @param getCSSVarName - function, returning complete CSS variable name for the specified\n * theme parameters key.\n * @returns Function to stop updating variables.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {CSSVarsBoundError} CSS variables are already bound\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example Using no arguments\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars();\n * }\n * @example Using custom CSS vars generator\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars(key => `--my-prefix-${key}`);\n * }\n */\nexport const bindCssVars = wrapMounted(\n  'bindCssVars',\n  (getCSSVarName?: GetCssVarNameFn): VoidFunction => {\n    if (_isCssVarsBound()) {\n      throw new CSSVarsBoundError();\n    }\n\n    getCSSVarName ||= (prop) => `--tg-theme-${snakeToKebab(prop)}`;\n\n    function forEachEntry(fn: (key: string, value: RGB) => void): void {\n      Object.entries(_state()).forEach(([k, v]) => {\n        v && fn(k, v);\n      });\n    }\n\n    function actualize(): void {\n      forEachEntry((k, v) => {\n        setCssVar(getCSSVarName!(k), v);\n      });\n    }\n\n    actualize();\n    _state.sub(actualize);\n    _isCssVarsBound.set(true);\n\n    return () => {\n      forEachEntry(deleteCssVar);\n      _state.unsub(actualize);\n      _isCssVarsBound.set(false);\n    };\n  },\n);\n\n/**\n * Mounts the Theme Params component restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @deprecated Use `mountSync`.\n * @example\n * if (mount.isAvailable()) {\n *   await mount();\n * }\n */\nexport const mount = wrapBasic('mount', mountFn);\n/**\n * @deprecated The initialization is synchronous. Use `mountSync`.\n */\nexport const isMounting = tMountPromise[2];\n/**\n * @deprecated The initialization is synchronous. Use `mountSync`.\n */\nexport const mountPromise = tMountPromise[1];\n/**\n * @deprecated The initialization is synchronous. Use `mountSync`.\n */\nexport const mountError = tMountError[1];\n\nexport const [_isMounted, isMounted] = tIsMounted;\n\n/**\n * Mounts the Theme Params component restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mountSync.isAvailable()) {\n *   mountSync();\n * }\n */\nexport const mountSync = wrapBasic('mountSync', () => {\n  if (!_isMounted()) {\n    const tp = (isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME))\n      || $launchParams().tgWebAppThemeParams\n      || {};\n    on(THEME_CHANGED_EVENT, onThemeChanged);\n    batch(() => {\n      _state.set(tp);\n      _isMounted.set(true);\n    });\n  }\n});\n\n/**\n * Unmounts the Theme Params component.\n */\nexport function unmount(): void {\n  signalCancel(mountPromise);\n  off(THEME_CHANGED_EVENT, onThemeChanged);\n  _isMounted.set(false);\n}", "import type { Computed } from '@telegram-apps/signals';\nimport type { RGB } from '@telegram-apps/types';\nimport { isRGB } from '@telegram-apps/transformers';\n\nimport { state as themeParamsState } from '@/scopes/components/theme-params/signals.js';\nimport { createComputed } from '@/signals-registry.js';\n\nimport type { AnyColor } from './types.js';\n\n// #__NO_SIDE_EFFECTS__\nexport function rgbComputedBasedOn(signal: Computed<AnyColor>): Computed<RGB | undefined> {\n  return createComputed<RGB | undefined>(() => rgbBasedOn(signal()));\n}\n\nexport function rgbBasedOn(color: AnyColor): RGB | undefined {\n  return isRGB(color) ? color : themeParamsState()[color];\n}", "import { isRGB } from '@telegram-apps/transformers';\nimport type { RGB } from '@telegram-apps/types';\n\nimport { isColorDark } from '@/utils/isColorDark.js';\nimport {\n  secondaryBackgroundColor as themeSecondaryBgColor,\n  state as themeParamsState,\n} from '@/scopes/components/theme-params/signals.js';\nimport { createComputed, createSignalsTuple } from '@/signals-registry.js';\nimport { rgbComputedBasedOn } from './utils.js';\n\nimport type { AnyColor, State } from './types.js';\n\n/**\n * The Mini App background color.\n *\n * Represents an RGB color, or theme parameters key, like \"bg_color\", \"secondary_bg_color\", etc.\n *\n * Note that using a theme parameters key, background color becomes bound to the current\n * theme parameters, making it automatically being updated whenever theme parameters change.\n * In order to remove this bind, use an explicit RGB color.\n */\nexport const [_backgroundColor, backgroundColor] = createSignalsTuple<AnyColor>('bg_color');\n\n/**\n * RGB representation of the background color.\n *\n * This value requires the Theme Params component to be mounted to extract a valid RGB value\n * of the color key.\n */\nexport const backgroundColorRGB = rgbComputedBasedOn(_backgroundColor);\n\n\n/**\n * The Mini App bottom bar background color.\n */\nexport const [_bottomBarColor, bottomBarColor] = createSignalsTuple<AnyColor>('bottom_bar_bg_color');\n\n/**\n * RGB representation of the bottom bar background color.\n *\n * This value requires the Theme Params component to be mounted to extract a valid RGB value\n * of the color key.\n */\nexport const bottomBarColorRGB = createComputed<RGB | undefined>(() => {\n  const color = _bottomBarColor();\n  return isRGB(color)\n    ? color\n    // Falling back to secondary_bg_color following the logic from the Telegram SDK.\n    : themeParamsState()[color] || themeSecondaryBgColor();\n});\n\n/**\n * The Mini App header color.\n */\nexport const [_headerColor, headerColor] = createSignalsTuple<AnyColor>('bg_color');\n\n/**\n * RGB representation of the header color.\n *\n * This value requires the Theme Params component to be mounted to extract a valid RGB value\n * of the color key.\n */\nexport const headerColorRGB = rgbComputedBasedOn(_headerColor);\n\n/**\n * True if CSS variables are currently bound.\n */\nexport const [_isCssVarsBound, isCssVarsBound] = createSignalsTuple(false);\n\n/**\n * True if the current Mini App background color is recognized as dark.\n */\nexport const isDark = createComputed(() => {\n  const color = backgroundColorRGB();\n  return color ? isColorDark(color) : false;\n});\n\n/**\n * Signal indicating if the mini app is currently active.\n */\nexport const [_isActive, isActive] = createSignalsTuple(true);\n\n/**\n * Complete component state.\n */\nexport const state = createComputed<State>(() => ({\n  backgroundColor: _backgroundColor(),\n  bottomBarColor: _bottomBarColor(),\n  headerColor: _headerColor(),\n  isActive: _isActive(),\n}));\n", "import {\n  supports,\n  on,\n  off,\n  type EventListener,\n  type MethodName,\n} from '@telegram-apps/bridge';\nimport { isRGB } from '@telegram-apps/transformers';\nimport { isPageReload } from '@telegram-apps/navigation';\nimport { type Computed, type SubscribeListenerFn, batch } from '@telegram-apps/signals';\nimport {\n  camelToKebab,\n  createCbCollector,\n  getStorageValue,\n  setStorageValue,\n} from '@telegram-apps/toolkit';\nimport type { RGB, ThemeParams } from '@telegram-apps/types';\n\nimport { version, postEvent } from '@/globals.js';\nimport {\n  mount as mountThemeParams,\n  mountSync as mountThemeParamsSync,\n} from '@/scopes/components/theme-params/methods.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { createComputed } from '@/signals-registry.js';\nimport { CSSVarsBoundError, UnknownThemeParamsKeyError } from '@/errors.js';\nimport { deleteCssVar, setCssVar } from '@/utils/css-vars.js';\nimport { defineMountFn } from '@/scopes/defineMountFn.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nimport {\n  _isCssVarsBound,\n  state,\n  headerColorRGB,\n  bottomBarColorRGB,\n  backgroundColorRGB,\n  _isActive,\n  _backgroundColor,\n  _bottomBarColor,\n  _headerColor,\n} from './signals.js';\nimport type { AnyColor, GetCssVarNameFn, State } from './types.js';\nimport { rgbBasedOn } from './utils.js';\nimport { themeParamsState } from '@/scopes/components/theme-params/exports.js';\n\ntype StorageValue = State;\n\nconst SET_BG_COLOR_METHOD = 'web_app_set_background_color';\nconst SET_BOTTOM_BAR_COLOR_METHOD = 'web_app_set_bottom_bar_color';\nconst SET_HEADER_COLOR_METHOD = 'web_app_set_header_color';\nconst VISIBILITY_CHANGED_EVENT = 'visibility_changed';\nconst COMPONENT_NAME = 'miniApp';\n\nconst isSupportedSchema = {\n  any: [\n    SET_BG_COLOR_METHOD,\n    SET_BOTTOM_BAR_COLOR_METHOD,\n    SET_HEADER_COLOR_METHOD,\n  ] as MethodName[],\n};\n\n/**\n * True if the Mini App component is supported.\n */\nexport const isSupported = createComputed(() => {\n  return isSupportedSchema.any.some(method => supports(method, version()));\n});\n\nconst onVisibilityChanged: EventListener<'visibility_changed'> = (data) => {\n  _isActive.set(data.is_visible);\n  saveState();\n};\n\nconst onThemeParamsChanged: SubscribeListenerFn<ThemeParams> = themeParams => {\n  ([\n    [_headerColor, SET_HEADER_COLOR_METHOD],\n    [_backgroundColor, SET_BG_COLOR_METHOD],\n    [_bottomBarColor, SET_BOTTOM_BAR_COLOR_METHOD],\n  ] as const).forEach(([signal, method]) => {\n    const color = signal();\n    if (!isRGB(color) && (\n      // Header color setter uses additional checks. We don't apply changes if the current\n      // value is a known color key because it updates automatically by itself.\n      method !== SET_HEADER_COLOR_METHOD\n      || (color !== 'bg_color' && color !== 'secondary_bg_color')\n    )) {\n      const rgb = themeParams[color];\n      rgb && postEvent(method, { color: rgb });\n    }\n  });\n};\n\nconst [\n  mountFn,\n  tMountPromise,\n  tMountError,\n  tIsMounted,\n] = defineMountFn(\n  COMPONENT_NAME,\n  (options?: RequestOptionsNoCapture) => {\n    return mountThemeParams(options).then(() => {\n      return isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || undefined;\n    });\n  },\n  s => {\n    setBackgroundColor.ifAvailable(s ? s.backgroundColor : 'bg_color');\n    setBottomBarColor.ifAvailable(s ? s.bottomBarColor : 'bottom_bar_bg_color');\n    setHeaderColor.ifAvailable(s ? s.headerColor : 'bg_color');\n    _isActive.set(s ? s.isActive : true);\n\n    on(VISIBILITY_CHANGED_EVENT, onVisibilityChanged);\n    themeParamsState.sub(onThemeParamsChanged);\n  },\n);\n\nconst wrapBasic = createWrapBasic(COMPONENT_NAME);\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, isSupportedSchema);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, tIsMounted[0], isSupportedSchema);\n\n/**\n * Creates CSS variables connected with the mini app.\n *\n * Default variables:\n * - `--tg-bg-color`\n * - `--tg-header-color`\n * - `--tg-bottom-bar-color`\n *\n * Variables are being automatically updated if theme parameters were changed.\n *\n * @param getCSSVarName - function, returning complete CSS variable name for the specified\n * mini app key.\n * @returns Function to stop updating variables.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {CSSVarsBoundError} CSS variables are already bound\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example Using no arguments\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars();\n * }\n * @example Using custom CSS vars generator\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars(key => `--my-prefix-${key}`);\n * }\n */\nexport const bindCssVars = wrapComplete(\n  'bindCssVars',\n  (getCSSVarName?: GetCssVarNameFn): VoidFunction => {\n    if (_isCssVarsBound()) {\n      throw new CSSVarsBoundError();\n    }\n\n    const [addCleanup, cleanup] = createCbCollector();\n\n    /**\n     * Binds specified CSS variable to a signal.\n     * @param cssVar - CSS variable name.\n     * @param signal - signal to listen changes to.\n     */\n    function bind(cssVar: string, signal: Computed<RGB | undefined>) {\n      function update() {\n        setCssVar(cssVar, signal() || null);\n      }\n\n      // Instantly set CSS variable.\n      update();\n\n      // Remember to clean this relation up.\n      addCleanup(signal.sub(update), deleteCssVar.bind(null, cssVar));\n    }\n\n    getCSSVarName ||= (prop) => `--tg-${camelToKebab(prop)}`;\n    bind(getCSSVarName('bgColor'), backgroundColorRGB);\n    bind(getCSSVarName('bottomBarColor'), bottomBarColorRGB);\n    bind(getCSSVarName('headerColor'), headerColorRGB);\n    addCleanup(() => {\n      _isCssVarsBound.set(false);\n    });\n\n    _isCssVarsBound.set(true);\n\n    return cleanup;\n  },\n);\n\n/**\n * Closes the Mini App.\n * @param returnBack - should the client return to the previous activity.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (close.isAvailable()) {\n *   close();\n * }\n */\nexport const close = wrapBasic('close', (returnBack?: boolean): void => {\n  postEvent('web_app_close', { return_back: returnBack });\n});\n\n/**\n * Mounts the component.\n *\n * This function restores the component state and is automatically saving it in the local storage\n * if it changed.\n *\n * Internally, the function mounts the Theme Params component to work with correctly extracted\n * theme palette values.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @deprecated Use `mountSync`.\n * @example\n * if (mount.isAvailable()) {\n *   await mount();\n * }\n */\nexport const mount = wrapSupported('mount', mountFn);\n/**\n * @deprecated The initialization is synchronous. Use `mountSync`.\n */\nexport const isMounting = tMountPromise[2];\n/**\n * @deprecated The initialization is synchronous. Use `mountSync`.\n */\nexport const mountPromise = tMountPromise[1];\n/**\n * @deprecated The initialization is synchronous. Use `mountSync`.\n */\nexport const mountError = tMountError[1];\n\nexport const [_isMounted, isMounted] = tIsMounted;\n\n/**\n * Mounts the component.\n *\n * This function restores the component state and is automatically saving it in the local storage\n * if it changed.\n *\n * Internally, the function mounts the Theme Params component to work with correctly extracted\n * theme palette values.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mountSync.isAvailable()) {\n *   mountSync();\n * }\n */\nexport const mountSync = wrapSupported('mountSync', () => {\n  if (!_isMounted()) {\n    mountThemeParamsSync();\n    const s = isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || undefined;\n\n    setBackgroundColor.ifAvailable(s ? s.backgroundColor : 'bg_color');\n    setBottomBarColor.ifAvailable(s ? s.bottomBarColor : 'bottom_bar_bg_color');\n    setHeaderColor.ifAvailable(s ? s.headerColor : 'bg_color');\n    on(VISIBILITY_CHANGED_EVENT, onVisibilityChanged);\n    themeParamsState.sub(onThemeParamsChanged);\n\n    batch(() => {\n      _isActive.set(s ? s.isActive : true);\n      _isMounted.set(true);\n    });\n  }\n});\n\n/**\n * Informs the Telegram app that the Mini App is ready to be displayed.\n *\n * It is recommended to call this method as early as possible, as soon as all\n * essential interface elements loaded.\n *\n * Once this method is called, the loading placeholder is hidden and the Mini\n * App shown.\n *\n * If the method is not called, the placeholder will be hidden only when the\n * page was fully loaded.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (ready.isAvailable()) {\n *   ready();\n * }\n */\nexport const ready = wrapBasic('ready', (): void => {\n  postEvent('web_app_ready');\n});\n\nfunction saveState() {\n  setStorageValue<StorageValue>(COMPONENT_NAME, state());\n}\n\n/**\n * Updates the background color.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {UnknownThemeParamsKeyError} Unknown theme params key passed\n * @example\n * if (setBackgroundColor.isAvailable()) {\n *   setBackgroundColor('bg_color');\n * }\n */\nexport const setBackgroundColor = wrapComplete(\n  'setBackgroundColor',\n  (color: AnyColor): void => {\n    if (color === _backgroundColor()) {\n      return;\n    }\n    const rgb = rgbBasedOn(color);\n    if (!rgb) {\n      throw new UnknownThemeParamsKeyError(color);\n    }\n    postEvent(SET_BG_COLOR_METHOD, { color: rgb });\n    _backgroundColor.set(color);\n    saveState();\n  },\n  SET_BG_COLOR_METHOD,\n);\n\n/**\n * Updates the bottom bar background color.\n * @since Mini Apps v7.10\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {UnknownThemeParamsKeyError} Unknown theme params key passed\n * @example\n * if (setBottomBarColor.isAvailable()) {\n *   setBottomBarColor('#ff11a3');\n * }\n */\nexport const setBottomBarColor = wrapComplete(\n  'setBottomBarColor',\n  (color: AnyColor) => {\n    if (color === _bottomBarColor()) {\n      return;\n    }\n    const rgb = rgbBasedOn(color);\n    if (!rgb) {\n      throw new UnknownThemeParamsKeyError(color);\n    }\n    postEvent(SET_BOTTOM_BAR_COLOR_METHOD, { color: rgb });\n    _bottomBarColor.set(color);\n    saveState();\n  },\n  SET_BOTTOM_BAR_COLOR_METHOD,\n);\n\n/**\n * Updates the header color.\n * @since Mini Apps v6.1\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {UnknownThemeParamsKeyError} Unknown theme params key passed\n * @example Using known color key\n * if (setHeaderColor.isAvailable()) {\n *   setHeaderColor('bg_color');\n * }\n * @example Using RGB\n * if (setHeaderColor.isAvailable() && setHeaderColor.supports.rgb()) {\n *   setHeaderColor('#ffaabb');\n * }\n */\nexport const setHeaderColor = wrapComplete(\n  'setHeaderColor',\n  (color: AnyColor): void => {\n    if (color === _headerColor()) {\n      return;\n    }\n    if (color === 'bg_color' || color === 'secondary_bg_color') {\n      postEvent(SET_HEADER_COLOR_METHOD, { color_key: color });\n    } else {\n      const rgb = rgbBasedOn(color);\n      if (!rgb) {\n        throw new UnknownThemeParamsKeyError(color);\n      }\n      postEvent(SET_HEADER_COLOR_METHOD, { color: rgb });\n    }\n    _headerColor.set(color);\n    saveState();\n  },\n  SET_HEADER_COLOR_METHOD,\n  {\n    rgb: [SET_HEADER_COLOR_METHOD, 'color', isRGB],\n  },\n);\n\n/**\n * Unmounts the component, removing the listener, saving the component state in the local storage.\n */\nexport function unmount(): void {\n  signalCancel(mountPromise);\n  off(VISIBILITY_CHANGED_EVENT, onVisibilityChanged);\n  themeParamsState.unsub(onThemeParamsChanged);\n  _isMounted.set(false);\n}\n", "import { type PopupParams } from '@telegram-apps/bridge';\n\nimport { InvalidArgumentsError } from '@/errors.js';\n\nimport type { OpenOptions } from './types.js';\n\n/**\n * Prepares popup parameters before sending them to native app.\n * @param params - popup parameters.\n * @throws {InvalidArgumentsError} Invalid title\n * @throws {InvalidArgumentsError} Invalid message\n * @throws {InvalidArgumentsError} Invalid buttons count\n * @throws {InvalidArgumentsError} Invalid button id length\n * @throws {InvalidArgumentsError} Invalid button text length\n */\nexport function prepareParams(params: OpenOptions): PopupParams {\n  const message = params.message.trim();\n  const title = (params.title || '').trim();\n  const buttons = params.buttons || [];\n\n  if (title.length > 64) {\n    throw new InvalidArgumentsError(`Invalid title: ${title}`);\n  }\n  if (!message || message.length > 256) {\n    throw new InvalidArgumentsError(`Invalid message: ${message}`);\n  }\n  if (buttons.length > 3) {\n    throw new InvalidArgumentsError(`Invalid buttons count: ${buttons.length}`);\n  }\n\n  return {\n    title,\n    message,\n    buttons: buttons.length\n      ? buttons.map((b, idx) => {\n        const id = b.id || '';\n        if (id.length > 64) {\n          throw new InvalidArgumentsError(`Button with index ${idx} has invalid id: ${id}`);\n        }\n\n        if (!b.type || b.type === 'default' || b.type === 'destructive') {\n          const text = b.text.trim();\n          if (!text || text.length > 64) {\n            throw new InvalidArgumentsError(`Button with index ${idx} has invalid text: ${text}`);\n          }\n          return { type: b.type, text, id };\n        }\n        return { type: b.type, id };\n      })\n      : [{ type: 'close', id: '' }],\n  };\n}", "import type { AbortablePromise } from 'better-promises';\n\nimport { request } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\n\nimport { prepareParams } from './prepareParams.js';\nimport type { ShowOptions } from './types.js';\n\nconst OPEN_METHOD = 'web_app_open_popup';\nconst wrapSupported = createWrapSupported('popup', OPEN_METHOD);\n\n/**\n * Signal indicating if popups are supported.\n */\nexport const isSupported = createIsSupported(OPEN_METHOD);\n\nconst [fn, tPromise, tShowError] = defineNonConcurrentFn(\n  (options: ShowOptions): AbortablePromise<string | null> => {\n    return request(OPEN_METHOD, 'popup_closed', {\n      ...options,\n      params: prepareParams(options),\n    }).then(({ button_id: buttonId }) => buttonId === undefined ? null : buttonId);\n  },\n  'A popup is already opened',\n);\n\n/**\n * @deprecated Deprecated for consistence naming, to be removed in the next major update. Use\n *   `show` instead.\n */\nexport const open = wrapSupported('open', fn);\n/**\n * @deprecated Deprecated for consistence naming, to be removed in the next major update. Use\n *   `showPromise` instead.\n */\nconst openPromise = tPromise[1];\n/**\n * @deprecated Deprecated for consistence naming, to be removed in the next major update. Use\n *   `isShown` instead.\n */\nconst isOpened = tPromise[2];\n/**\n * @deprecated Deprecated for consistence naming, to be removed in the next major update. Use\n *   `showError` instead.\n */\nconst openError = tShowError[1];\n\nexport { openPromise, isOpened, openError };\n\n/**\n * A method that shows a native popup described by the `params` argument.\n * The promise will be resolved when the popup is closed. Resolved value will have\n * an identifier of the pressed button.\n *\n * If a user clicked outside the popup or clicked the top right popup close\n * button, null will be resolved.\n *\n * @param options - popup parameters.\n * @since Mini Apps v6.2\n * @throws {InvalidArgumentsError} Invalid title\n * @throws {InvalidArgumentsError} Invalid message\n * @throws {InvalidArgumentsError} Invalid buttons count\n * @throws {InvalidArgumentsError} Invalid button id length\n * @throws {InvalidArgumentsError} Invalid button text length\n * @throws {ConcurrentCallError} A popup is already opened\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (open.isAvailable()) {\n *   const buttonId = await open({\n *     title: 'Confirm action',\n *     message: 'Do you really want to buy this burger?',\n *     buttons: [\n *       { id: 'yes', text: 'Yes' },\n *       { id: 'no', type: 'destructive', text: 'No' },\n *     ],\n *   });\n * }\n */\nexport const show = wrapSupported('show', fn);\nexport const [, showPromise, isShown] = tPromise;\nexport const [, showError] = tShowError;\n", "import { on } from '@telegram-apps/bridge';\nimport { createCbCollector } from '@telegram-apps/toolkit';\nimport { AbortablePromise, ManualPromise } from 'better-promises';\n\nimport { postEvent } from '@/globals.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\nimport { ignoreCanceled } from '@/utils/ignoreCanceled.js';\n\ninterface OpenSharedOptions extends RequestOptionsNoCapture {\n  /**\n   * Title to be displayed in the scanner.\n   */\n  text?: string;\n}\n\nconst CLOSE_METHOD = 'web_app_close_scan_qr_popup';\nconst OPEN_METHOD = 'web_app_open_scan_qr_popup';\nconst CLOSED_EVENT = 'scan_qr_popup_closed';\nconst TEXT_RECEIVED_EVENT = 'qr_text_received';\n\nconst wrapSupported = createWrapSupported('qrScanner', OPEN_METHOD);\n\n/**\n * Closes the scanner.\n * @since Mini Apps v6.4\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (close.isAvailable()) {\n *   close();\n * }\n */\nexport const close = wrapSupported('close', (): void => {\n  postEvent(CLOSE_METHOD);\n  signalCancel(openPromise);\n});\n\n/**\n * Signal indicating if the QR Scanner is currently opened.\n */\nexport const isSupported = createIsSupported(OPEN_METHOD);\n\n/**\n * Opens the scanner and returns a promise which will be resolved with the QR content if the\n * passed `capture` function returned true.\n *\n * The `capture` option may be ommited. In this case, the first scanned QR will be returned.\n *\n * Promise may also be resolved to undefined if the scanner was closed.\n * @param options - method options.\n * @returns A promise with QR content presented as string or undefined if the\n * scanner was closed.\n * @since Mini Apps v6.4\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {ConcurrentCallError} The QR Scanner is already opened\n * @example Without `capture` option\n * if (captureOne.isAvailable()) {\n *   const qr = await captureOne({ text: 'Scan any QR' });\n * }\n * @example Using `capture` option\n * if (captureOne.isAvailable()) {\n *   const qr = await captureOne({\n *     text: 'Scan any QR',\n *     capture(scannedQr) {\n *       return scannedQr === 'any expected by me qr';\n *     }\n *   });\n * }\n */\nfunction _open(\n  options?: OpenSharedOptions & {\n    /**\n     * Function, which should return true if the scanned QR should be captured.\n     * @param qr - scanned QR content.\n     */\n    capture?: (qr: string) => boolean;\n  },\n): AbortablePromise<string | undefined>;\n\n/**\n * Opens the scanner and calls the `onCaptured` function each time, a QR was scanned.\n *\n * The function returns a promise which will be resolved when the QR scanner was closed. It expects\n * the scanner to be closed externally by a user or via the `close` method.\n * @param options - method options.\n * @since Mini Apps v6.4\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {ConcurrentCallError} The QR Scanner is already opened\n * @example\n * if (captureMany.isAvailable()) {\n *   const promise = await captureMany({\n *     text: 'Scan any QR',\n *     onCaptured(scannedQr) {\n *       if (scannedQr === 'any expected by me qr') {\n *         close();\n *       }\n *     }\n *   });\n *   console.log('The scanner was closed');\n * }\n */\nfunction _open(\n  options: OpenSharedOptions & {\n    /**\n     * Function which will be called if a QR code was scanned.\n     * @param qr - scanned QR content.\n     */\n    onCaptured: (qr: string) => void;\n  },\n): AbortablePromise<void>;\n\nfunction _open(\n  options?: OpenSharedOptions & {\n    onCaptured?: (qr: string) => void;\n    capture?: (qr: string) => boolean;\n  },\n): AbortablePromise<string | undefined | void> {\n  options ||= {};\n  const { onCaptured, text, capture } = options;\n  const [, cleanup] = createCbCollector(\n    on(CLOSED_EVENT, () => {\n      promise.resolve();\n    }),\n    on(TEXT_RECEIVED_EVENT, (event) => {\n      if (onCaptured) {\n        onCaptured(event.data);\n      } else if (!capture || capture(event.data)) {\n        promise.resolve(event.data);\n        postEvent(CLOSE_METHOD);\n      }\n    }),\n  );\n\n  const promise = new ManualPromise<string | void>(options);\n  (options.postEvent || postEvent)(OPEN_METHOD, { text });\n\n  return AbortablePromise.resolve(promise).catch(ignoreCanceled).finally(cleanup);\n}\n\nconst [\n  openFn,\n  tOpenPromise,\n  tOpenError,\n] = defineNonConcurrentFn(_open, 'The QR Scanner is already opened');\n\nexport const open = wrapSupported('open', openFn);\nexport const [, openPromise, isOpened] = tOpenPromise;\nexport const [, openError] = tOpenError;", "import type { Computed } from '@telegram-apps/signals';\n\nimport { buttonColor } from '@/scopes/components/theme-params/signals.js';\nimport { bottomBarColorRGB } from '@/scopes/components/mini-app/signals.js';\nimport { createComputed, createSignal, createSignalsTuple } from '@/signals-registry.js';\n\nimport type { State } from './types.js';\n\nfunction fromState<K extends keyof Required<State>>(key: K): Computed<Required<State>[K]> {\n  return createComputed(() => state()[key]);\n}\n\nexport const internalState = createSignal<State>({\n  hasShineEffect: false,\n  isEnabled: true,\n  isLoaderVisible: false,\n  isVisible: false,\n  position: 'left',\n  text: 'Cancel',\n});\n\n/**\n * Complete component state.\n */\nexport const state = createComputed<Required<State>>(() => {\n  const s = internalState();\n  return {\n    ...s,\n    backgroundColor: s.backgroundColor || bottomBarColorRGB() || '#000000',\n    textColor: s.textColor || buttonColor() || '#2481cc',\n  };\n});\n\n/**\n * True if the component is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\n/**\n * @see State.backgroundColor\n */\nexport const backgroundColor = fromState('backgroundColor');\n\n/**\n * @see State.hasShineEffect\n */\nexport const hasShineEffect = fromState('hasShineEffect');\n\n/**\n * @see State.isEnabled\n */\nexport const isEnabled = fromState('isEnabled');\n\n/**\n * @see State.isLoaderVisible\n */\nexport const isLoaderVisible = fromState('isLoaderVisible');\n\n/**\n * @see State.isVisible\n */\nexport const isVisible = fromState('isVisible');\n\n/**\n * @see State.position\n */\nexport const position = fromState('position');\n\n/**\n * @see State.text\n */\nexport const text = fromState('text');\n\n/**\n * @see State.textColor\n */\nexport const textColor = fromState('textColor');\n", "import {\n  off,\n  on,\n  type EventListener,\n} from '@telegram-apps/bridge';\nimport { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { postEvent } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\n\nimport { internalState, isMounted, _isMounted, state } from './signals.js';\nimport type { State } from './types.js';\nimport { removeUndefined } from '@/utils/removeUndefined.js';\n\ntype StorageValue = State;\n\nconst SETUP_METHOD_NAME = 'web_app_setup_secondary_button';\nconst CLICK_EVENT_NAME = 'secondary_button_pressed';\nconst COMPONENT_NAME = 'secondaryButton';\n\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, SETUP_METHOD_NAME);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, isMounted, SETUP_METHOD_NAME);\n\n/**\n * Signal indicating if the Secondary Button is supported.\n */\nexport const isSupported = createIsSupported(SETUP_METHOD_NAME);\n\n/**\n * Mounts the Secondary Button restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapSupported('mount', (): void => {\n  if (!_isMounted()) {\n    const prev = isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME);\n    prev && internalState.set(prev);\n    _isMounted.set(true);\n  }\n});\n\n/**\n * Adds a new Secondary Button click listener.\n * @param fn - event listener.\n * @returns A function to remove bound listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (onClick.isAvailable()) {\n *   const off = onClick(() => {\n *     console.log('User clicked the Secondary Button');\n *     off();\n *   });\n * }\n */\nexport const onClick = wrapSupported(\n  'onClick',\n  (fn: EventListener<'secondary_button_pressed'>): VoidFunction => on(CLICK_EVENT_NAME, fn),\n);\n\n/**\n * Removes the Secondary Button click listener.\n * @param fn - an event listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (offClick.isAvailable()) {\n *   function listener() {\n *     console.log('User clicked the Secondary Button');\n *     offClick(listener);\n *   }\n *   onClick(listener);\n * }\n */\nexport const offClick = wrapSupported(\n  'offClick',\n  (fn: EventListener<'secondary_button_pressed'>): void => {\n    off(CLICK_EVENT_NAME, fn);\n  },\n);\n\n/**\n * Updates the Secondary Button state.\n * @param updates - state changes to perform.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (setParams.isAvailable()) {\n *   setParams({\n *     text: 'Submit',\n *     isEnabled: true,\n *     isVisible: true,\n *     position: 'left',\n *   });\n * }\n */\nexport const setParams = wrapComplete(\n  'setParams',\n  (updates: Partial<State>): void => {\n    internalState.set({ ...internalState(), ...removeUndefined(updates) });\n    setStorageValue<StorageValue>(COMPONENT_NAME, internalState());\n\n    // We should not commit changes until the payload is correct. Some version of Telegram will\n    // crash due to the empty value of the text.\n    const s = state();\n    s.text && postEvent(SETUP_METHOD_NAME, {\n      color: s.backgroundColor,\n      has_shine_effect: s.hasShineEffect,\n      is_active: s.isEnabled,\n      is_progress_visible: s.isLoaderVisible,\n      is_visible: s.isVisible,\n      position: s.position,\n      text: s.text,\n      text_color: s.textColor,\n    });\n  },\n);\n\n/**\n * Unmounts the Secondary Button.\n *\n * Note that this function does not remove listeners added via the `onClick`\n * function, so you have to remove them on your own.\n * @see onClick\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}", "import { off, on, type EventListener } from '@telegram-apps/bridge';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\nimport { isPageReload } from '@telegram-apps/navigation';\n\nimport { postEvent } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport {\n  createWrapSupported,\n} from '@/scopes/wrappers/createWrapSupported.js';\nimport { createSignalsTuple } from '@/signals-registry.js';\n\ntype StorageValue = boolean;\n\nconst SETUP_METHOD_NAME = 'web_app_setup_settings_button';\nconst CLICK_EVENT_NAME = 'settings_button_pressed';\nconst COMPONENT_NAME = 'settingsButton';\n\n/**\n * Signal indicating if the Settings Button is currently visible.\n */\nexport const [_isVisible, isVisible] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Settings Button is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Settings Button is supported.\n */\nexport const isSupported = createIsSupported(SETUP_METHOD_NAME);\n\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, SETUP_METHOD_NAME);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, _isMounted, SETUP_METHOD_NAME);\n\n/**\n * Hides the Settings Button.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @since Mini Apps v6.10\n * @example\n * if (hide.isAvailable()) {\n *   hide();\n * }\n */\nexport const hide = wrapComplete('hide', (): void => {\n  setVisibility(false);\n});\n\n/**\n * Mounts the Settings Button restoring its state.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.10\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapSupported('mount', (): void => {\n  if (!_isMounted()) {\n    setVisibility(isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || false);\n    _isMounted.set(true);\n  }\n});\n\nfunction setVisibility(value: boolean): void {\n  if (value !== _isVisible()) {\n    postEvent(SETUP_METHOD_NAME, { is_visible: value });\n    setStorageValue<StorageValue>(COMPONENT_NAME, value);\n    _isVisible.set(value);\n  }\n}\n\n/**\n * Adds a new Settings Button click listener.\n * @param fn - event listener.\n * @returns A function to remove bound listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.10\n * @example\n * if (onClick.isAvailable()) {\n *   const off = onClick(() => {\n *     console.log('User clicked the Settings Button');\n *     off();\n *   });\n * }\n */\nexport const onClick = wrapSupported(\n  'onClick',\n  (fn: EventListener<'settings_button_pressed'>): VoidFunction => on(CLICK_EVENT_NAME, fn),\n);\n\n/**\n * Removes the Settings Button click listener.\n * @param fn - an event listener.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v6.10\n * @example\n * if (offClick.isAvailable()) {\n *   function listener() {\n *     console.log('User clicked the Settings Button');\n *     offClick(listener);\n *   }\n *   onClick(listener);\n * }\n */\nexport const offClick = wrapSupported(\n  'offClick',\n  (fn: EventListener<'settings_button_pressed'>): void => {\n    off(CLICK_EVENT_NAME, fn);\n  },\n);\n\n/**\n * Shows the Settings Button.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @since Mini Apps v6.10\n * @example\n * if (show.isAvailable()) {\n *   show();\n * }\n */\nexport const show = wrapComplete('show', (): void => {\n  setVisibility(true);\n});\n\n/**\n * Unmounts the Settings Button.\n *\n * Note that this function does not remove listeners added via the `onClick`\n * function, so you have to remove them on your own.\n * @see onClick\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}\n", "import { isPageReload } from '@telegram-apps/navigation';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { postEvent } from '@/globals.js';\nimport { createIsSupported } from '@/scopes/createIsSupported.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport {\n  createWrapSupported,\n} from '@/scopes/wrappers/createWrapSupported.js';\nimport { createSignalsTuple } from '@/signals-registry.js';\n\ntype StorageValue = boolean;\n\nconst SETUP_METHOD_NAME = 'web_app_setup_swipe_behavior';\nconst COMPONENT_NAME = 'swipeBehavior';\n\n/**\n * Signal indicating if the Swipe Behavior component is currently mounted.\n */\nexport const [_isMounted, isMounted] = createSignalsTuple(false);\n\n/**\n * Signal indicating if the Swipe Behavior is supported.\n */\nexport const isSupported = createIsSupported(SETUP_METHOD_NAME);\n\n/**\n * Signal indicating if vertical swipes are enabled.\n */\nexport const [_isVerticalEnabled, isVerticalEnabled] = createSignalsTuple(true);\n\nconst wrapSupported = createWrapSupported(COMPONENT_NAME, SETUP_METHOD_NAME);\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, _isMounted, SETUP_METHOD_NAME);\n\n/**\n * Disables vertical swipes.\n * @since Mini Apps v7.7\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example\n * if (disableVertical.isAvailable()) {\n *   disableVertical();\n * }\n */\nexport const disableVertical = wrapComplete('disableVertical', (): void => {\n  setVerticalEnabled(false);\n});\n\n/**\n * Enables vertical swipes.\n * @since Mini Apps v7.7\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @example\n * if (enableVertical.isAvailable()) {\n *   enableVertical();\n * }\n */\nexport const enableVertical = wrapComplete('enableVertical', (): void => {\n  setVerticalEnabled(true);\n});\n\n/**\n * Mounts the Swipe Behavior component restoring its state.\n * @since Mini Apps v7.7\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (mount.isAvailable()) {\n *   mount();\n * }\n */\nexport const mount = wrapSupported('mount', (): void => {\n  if (!_isMounted()) {\n    setVerticalEnabled(\n      isPageReload() && getStorageValue<StorageValue>(COMPONENT_NAME) || false,\n      true,\n    );\n    _isMounted.set(true);\n  }\n});\n\nfunction setVerticalEnabled(value: boolean, force?: boolean): void {\n  if (value !== _isVerticalEnabled() || force) {\n    postEvent(SETUP_METHOD_NAME, { allow_vertical_swipe: value });\n    setStorageValue<StorageValue>(COMPONENT_NAME, value);\n    _isVerticalEnabled.set(value);\n  }\n}\n\n/**\n * Unmounts the Swipe Behavior component.\n */\nexport function unmount(): void {\n  _isMounted.set(false);\n}\n", "export const COMPONENT_NAME = 'viewport';\nexport const FS_CHANGED_EVENT = 'fullscreen_changed';\nexport const SA_CHANGED_EVENT = 'safe_area_changed';\nexport const CSA_CHANGED_EVENT = 'content_safe_area_changed';\nexport const VIEWPORT_CHANGED_EVENT = 'viewport_changed';", "import { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\n\nimport { COMPONENT_NAME } from './const.js';\n\nexport const wrapBasic = createWrapBasic(COMPONENT_NAME);\n", "import type { Computed } from '@telegram-apps/signals';\nimport type { SafeAreaInsets } from '@telegram-apps/bridge';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { createComputed, createSignalsTuple } from '@/signals-registry.js';\nimport type { State } from '@/scopes/components/viewport/types.js';\nimport { removeUndefined } from '@/utils/removeUndefined.js';\nimport { COMPONENT_NAME } from '@/scopes/components/viewport/const.js';\n\nconst initialInsets: SafeAreaInsets = { left: 0, top: 0, bottom: 0, right: 0 };\n\nfunction nonNegative(value: number): number {\n  return Math.max(value, 0);\n}\n\n//#region Core State.\n\n/**\n * Signal containing the component complete state.\n */\nexport const [_state, state] = createSignalsTuple<State>({\n  contentSafeAreaInsets: initialInsets,\n  height: 0,\n  isExpanded: false,\n  isFullscreen: false,\n  safeAreaInsets: initialInsets,\n  stableHeight: 0,\n  width: 0,\n});\n\nexport function signalFromState<K extends keyof State>(key: K): Computed<State[K]> {\n  return createComputed(() => state()[key]);\n}\n\n/**\n * Signal containing the current height of the **visible area** of the Mini App.\n *\n * The application can display just the top part of the Mini App, with its\n * lower part remaining outside the screen area. From this position, the user\n * can \"pull\" the Mini App to its maximum height, while the bot can do the same\n * by calling `expand` method. As the position of the Mini App changes, the\n * current height value of the visible area will be updated  in real time.\n *\n * Please note that the refresh rate of this value is not sufficient to\n * smoothly follow the lower border of the window. It should not be used to pin\n * interface elements to the bottom of the visible area. It's more appropriate\n * to use the value of the `stableHeight` field for this purpose.\n *\n * @see stableHeight\n */\nexport const height = signalFromState('height');\n\n/**\n * Signal containing the height of the visible area of the Mini App in its last stable state.\n *\n * The application can display just the top part of the Mini App, with its\n * lower part remaining outside the screen area. From this position, the user\n * can \"pull\" the Mini App to its maximum height, while the application can do\n * the same by calling `expand` method.\n *\n * Unlike the value of `height`, the value of `stableHeight` does not change as\n * the position of the Mini App changes with user gestures or during\n * animations. The value of `stableHeight` will be updated after all gestures\n * and animations are completed and the Mini App reaches its final size.\n *\n * @see height\n */\nexport const stableHeight = signalFromState('stableHeight');\n\n/**\n * Signal containing the currently visible area width.\n */\nexport const width = signalFromState('width');\n\n/**\n * Signal indicating if the Mini App is expanded to the maximum available height. Otherwise,\n * if the Mini App occupies part of the screen and can be expanded to the full\n * height using `expand` method.\n * @see expand\n */\nexport const isExpanded = signalFromState('isExpanded');\n\n/**\n * Signal indicating if the current viewport height is stable and is not going to change in\n * the next moment.\n */\nexport const isStable = createComputed(() => height() === stableHeight());\n\n/**\n * Updates the viewport signal state saving it in the storage.\n * @param s - state updates.\n */\nexport function setState(s: Partial<State>): void {\n  const { height, stableHeight, width } = s;\n\n  _state.set({\n    ..._state(),\n    ...removeUndefined({\n      ...s,\n      height: height ? nonNegative(height) : undefined,\n      width: width ? nonNegative(width) : undefined,\n      stableHeight: stableHeight ? nonNegative(stableHeight) : undefined,\n    }),\n  });\n  setStorageValue<State>(COMPONENT_NAME, _state());\n}\n\n/**\n * Retrieves the viewport state from the storage.\n */\nexport function getStateFromStorage(): State | undefined {\n  return getStorageValue<State>(COMPONENT_NAME);\n}\n\n//#endregion\n\n//#region Content Safe Area Insets.\n\nfunction fromCsaState(key: keyof SafeAreaInsets): Computed<number> {\n  return createComputed(() => contentSafeAreaInsets()[key]);\n}\n\nexport const contentSafeAreaInsets = signalFromState('contentSafeAreaInsets');\nexport const contentSafeAreaInsetBottom = fromCsaState('bottom');\nexport const contentSafeAreaInsetLeft = fromCsaState('left');\nexport const contentSafeAreaInsetRight = fromCsaState('right');\nexport const contentSafeAreaInsetTop = fromCsaState('top');\n\n//#endregion\n\n//#region Safe Area Insets.\n\nfunction fromSaState(key: keyof SafeAreaInsets): Computed<number> {\n  return createComputed(() => safeAreaInsets()[key]);\n}\n\nexport const safeAreaInsets = signalFromState('safeAreaInsets');\nexport const safeAreaInsetBottom = fromSaState('bottom');\nexport const safeAreaInsetLeft = fromSaState('left');\nexport const safeAreaInsetRight = fromSaState('right');\nexport const safeAreaInsetTop = fromSaState('top');\n\n//#endregion", "import type { AbortablePromise } from 'better-promises';\nimport type { EventPayload } from '@telegram-apps/bridge';\n\nimport { request } from '@/globals.js';\nimport { createWrapSupported } from '@/scopes/wrappers/createWrapSupported.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nimport {\n  COMPONENT_NAME,\n  CSA_CHANGED_EVENT,\n  SA_CHANGED_EVENT,\n  VIEWPORT_CHANGED_EVENT,\n} from './const.js';\n\nconst REQUEST_SA_METHOD_NAME = 'web_app_request_safe_area';\nconst wrapSafe = createWrapSupported(COMPONENT_NAME, REQUEST_SA_METHOD_NAME);\n\n/**\n * Requests the actual viewport content safe area insets information.\n * @param options - request options.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v8.0\n * @example\n * if (requestContentSafeAreaInsets.isAvailable()) {\n *   const insets = await requestContentSafeAreaInsets();\n * }\n */\nexport const requestContentSafeAreaInsets = wrapSafe(\n  'requestContentSafeAreaInsets',\n  (options?: RequestOptionsNoCapture): AbortablePromise<EventPayload<'content_safe_area_changed'>> => {\n    return request('web_app_request_content_safe_area', CSA_CHANGED_EVENT, options);\n  },\n);\n\n/**\n * Requests viewport actual information from the Telegram application.\n * @param options - request options.\n * @example\n * if (requestViewport.isAvailable()) {\n *   const viewport = await requestViewport();\n * }\n */\nexport function requestViewport(\n  options?: RequestOptionsNoCapture,\n): AbortablePromise<EventPayload<'viewport_changed'>> {\n  return request('web_app_request_viewport', VIEWPORT_CHANGED_EVENT, options);\n}\n\n/**\n * Requests the actual viewport safe area insets information.\n * @param options - request options.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @since Mini Apps v8.0\n * @example\n * if (requestSafeAreaInsets.isAvailable()) {\n *   const insets = await requestSafeAreaInsets();\n * }\n */\nexport const requestSafeAreaInsets = wrapSafe(\n  'requestSafeAreaInsets',\n  (options?: RequestOptionsNoCapture): AbortablePromise<EventPayload<'safe_area_changed'>> => {\n    return request(REQUEST_SA_METHOD_NAME, SA_CHANGED_EVENT, options);\n  },\n);", "import { isPageReload } from '@telegram-apps/navigation';\nimport { type EventListener, off, on } from '@telegram-apps/bridge';\nimport { AbortablePromise } from 'better-promises';\n\nimport { defineMountFn } from '@/scopes/defineMountFn.js';\nimport { $launchParams } from '@/globals.js';\nimport { signalCancel } from '@/scopes/signalCancel.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nimport { wrapBasic } from './wrappers.js';\nimport {\n  COMPONENT_NAME,\n  CSA_CHANGED_EVENT,\n  FS_CHANGED_EVENT,\n  SA_CHANGED_EVENT,\n  VIEWPORT_CHANGED_EVENT,\n} from './const.js';\nimport { contentSafeAreaInsets, getStateFromStorage, safeAreaInsets, setState } from './signals.js';\nimport { requestContentSafeAreaInsets, requestSafeAreaInsets, requestViewport } from './static.js';\n\nconst onViewportChanged: EventListener<'viewport_changed'> = (data) => {\n  const { height } = data;\n  setState({\n    isExpanded: data.is_expanded,\n    height,\n    width: data.width,\n    stableHeight: data.is_state_stable ? height : undefined,\n  });\n};\n\nconst onFullscreenChanged: EventListener<'fullscreen_changed'> = (data) => {\n  setState({ isFullscreen: data.is_fullscreen });\n};\n\nconst onSafeAreaChanged: EventListener<'safe_area_changed'> = (data) => {\n  setState({ safeAreaInsets: data });\n};\n\nconst onContentSafeAreaChanged: EventListener<'content_safe_area_changed'> = (data) => {\n  setState({ contentSafeAreaInsets: data });\n};\n\nconst [\n  fn,\n  tMountPromise,\n  tMountError,\n  tIsMounted,\n] = defineMountFn(\n  COMPONENT_NAME,\n  (options?: RequestOptionsNoCapture) => {\n    // Try to restore the state using the storage.\n    const s = isPageReload() && getStateFromStorage();\n    return s\n      ? AbortablePromise.resolve(s)\n      : AbortablePromise.fn(async context => {\n        // Request all insets.\n        const insets = await AbortablePromise.all([\n          requestSafeAreaInsets.isAvailable()\n            ? requestSafeAreaInsets(context)\n            : safeAreaInsets(),\n          requestContentSafeAreaInsets.isAvailable()\n            ? requestContentSafeAreaInsets(context)\n            : contentSafeAreaInsets(),\n        ]);\n\n        const lp = $launchParams();\n        const shared = {\n          contentSafeAreaInsets: insets[1],\n          isFullscreen: !!lp.tgWebAppFullscreen,\n          safeAreaInsets: insets[0],\n        };\n\n        // If the platform has a stable viewport, it means we could use the window global object\n        // properties.\n        if (['macos', 'tdesktop', 'unigram', 'webk', 'weba', 'web'].includes(lp.tgWebAppPlatform)) {\n          const w = window;\n          return {\n            ...shared,\n            height: w.innerHeight,\n            isExpanded: true,\n            stableHeight: w.innerHeight,\n            width: w.innerWidth,\n          };\n        }\n\n        // We were unable to retrieve data locally. In this case, we are\n        // sending a request returning the viewport information.\n        return requestViewport(context).then(data => ({\n          ...shared,\n          height: data.height,\n          isExpanded: data.is_expanded,\n          stableHeight: data.is_state_stable ? data.height : 0,\n          width: data.width,\n        }));\n      }, options);\n  },\n  (result) => {\n    on(VIEWPORT_CHANGED_EVENT, onViewportChanged);\n    on(FS_CHANGED_EVENT, onFullscreenChanged);\n    on(SA_CHANGED_EVENT, onSafeAreaChanged);\n    on(CSA_CHANGED_EVENT, onContentSafeAreaChanged);\n    setState(result);\n  },\n);\n\n/**\n * Mounts the Viewport component.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {ConcurrentCallError} The component is already mounting\n * @example\n * if (mount.isAvailable() && !isMounting()) {\n *   await mount();\n * }\n */\nexport const mount = wrapBasic('mount', fn);\nexport const [, mountPromise, isMounting] = tMountPromise;\nexport const [, mountError] = tMountError;\nexport const [_isMounted, isMounted] = tIsMounted;\n\n/**\n * Unmounts the Viewport.\n */\nexport function unmount(): void {\n  signalCancel(mountPromise);\n  off(VIEWPORT_CHANGED_EVENT, onViewportChanged);\n  off(FS_CHANGED_EVENT, onFullscreenChanged);\n  off(SA_CHANGED_EVENT, onSafeAreaChanged);\n  off(CSA_CHANGED_EVENT, onContentSafeAreaChanged);\n  _isMounted.set(false);\n}\n", "import { camelToKebab } from '@telegram-apps/toolkit';\nimport { deleteCssVar, setCssVar } from '@/utils/css-vars.js';\n\nimport { CSSVarsBoundError } from '@/errors.js';\nimport { createSignalsTuple } from '@/signals-registry.js';\nimport { createWrapMounted } from '@/scopes/wrappers/createWrapMounted.js';\nimport { COMPONENT_NAME } from '@/scopes/components/viewport/const.js';\nimport { _isMounted } from '@/scopes/components/viewport/mounting.js';\n\nimport {\n  safeAreaInsetBottom,\n  safeAreaInsetTop,\n  safeAreaInsetRight,\n  safeAreaInsetLeft,\n  height,\n  width,\n  stableHeight,\n  contentSafeAreaInsetBottom,\n  contentSafeAreaInsetTop,\n  contentSafeAreaInsetRight,\n  contentSafeAreaInsetLeft,\n} from './signals.js';\nimport type { GetCSSVarNameFn } from './types.js';\n\nconst wrapMounted = createWrapMounted(COMPONENT_NAME, _isMounted);\n\n/**\n * True if CSS variables are currently bound.\n */\nexport const [_isCssVarsBound, isCssVarsBound] = createSignalsTuple(false);\n\n/**\n * Creates CSS variables connected with the current viewport.\n *\n * By default, created CSS variables names are following the pattern \"--tg-theme-{name}\", where\n * {name} is a viewport property name converted from camel case to kebab case.\n *\n * Default variables:\n * - `--tg-viewport-height`\n * - `--tg-viewport-width`\n * - `--tg-viewport-stable-height`\n * - `--tg-viewport-content-safe-area-inset-top`\n * - `--tg-viewport-content-safe-area-inset-bottom`\n * - `--tg-viewport-content-safe-area-inset-left`\n * - `--tg-viewport-content-safe-area-inset-right`\n * - `--tg-viewport-safe-area-inset-top`\n * - `--tg-viewport-safe-area-inset-bottom`\n * - `--tg-viewport-safe-area-inset-left`\n * - `--tg-viewport-safe-area-inset-right`\n *\n * Variables are being automatically updated if the viewport was changed.\n *\n * @param getCSSVarName - function, returning computed complete CSS variable name. The CSS\n * variable will only be defined if the function returned non-empty string value.\n * @returns Function to stop updating variables.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {CSSVarsBoundError} CSS variables are already bound\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example Using no arguments\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars();\n * }\n * @example Using custom CSS vars generator\n * if (bindCssVars.isAvailable()) {\n *   bindCssVars(key => `--my-prefix-${key}`);\n * }\n */\nexport const bindCssVars = wrapMounted(\n  'bindCssVars',\n  (getCSSVarName?: GetCSSVarNameFn): VoidFunction => {\n    if (_isCssVarsBound()) {\n      throw new CSSVarsBoundError();\n    }\n\n    getCSSVarName ||= (prop) => `--tg-viewport-${camelToKebab(prop)}`;\n\n    const settings = ([\n      ['height', height],\n      ['stableHeight', stableHeight],\n      ['width', width],\n      ['safeAreaInsetTop', safeAreaInsetTop],\n      ['safeAreaInsetBottom', safeAreaInsetBottom],\n      ['safeAreaInsetLeft', safeAreaInsetLeft],\n      ['safeAreaInsetRight', safeAreaInsetRight],\n      ['contentSafeAreaInsetTop', contentSafeAreaInsetTop],\n      ['contentSafeAreaInsetBottom', contentSafeAreaInsetBottom],\n      ['contentSafeAreaInsetLeft', contentSafeAreaInsetLeft],\n      ['contentSafeAreaInsetRight', contentSafeAreaInsetRight],\n    ] as const).reduce<[\n      update: VoidFunction,\n      removeListener: VoidFunction,\n      cssVar: string\n    ][]>((acc, [key, signal]) => {\n      const cssVar = getCSSVarName(key);\n      if (cssVar) {\n        const update = () => {\n          setCssVar(cssVar, `${signal()}px`);\n        };\n        acc.push([update, signal.sub(update), cssVar]);\n      }\n      return acc;\n    }, []);\n\n    // Instantly set CSS variables.\n    settings.forEach(setting => {\n      setting[0]();\n    });\n    _isCssVarsBound.set(true);\n\n    return () => {\n      settings.forEach(s => {\n        // Remove update listener.\n        s[1]();\n        // Remove CSS variable.\n        deleteCssVar(s[2]);\n      });\n      _isCssVarsBound.set(false);\n    };\n  },\n);\n", "import { postEvent } from '@/globals.js';\n\nimport { wrapBasic } from './wrappers.js';\n\n/**\n * A method that expands the Mini App to the maximum available height. To find\n * out if the Mini App is expanded to the maximum height, refer to the value of\n * the `isExpanded`.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @see isExpanded\n * @example\n * if (expand.isAvailable()) {\n *   expand();\n * }\n */\nexport const expand = wrapBasic('expand', (): void => {\n  postEvent('web_app_expand');\n});\n", "import type { AbortablePromise, PromiseOptions } from 'better-promises';\n\nimport { request } from '@/globals.js';\nimport { FullscreenFailedError } from '@/errors.js';\nimport { createWrapComplete } from '@/scopes/wrappers/createWrapComplete.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\n\nimport { COMPONENT_NAME, FS_CHANGED_EVENT } from './const.js';\nimport { setState, signalFromState } from './signals.js';\nimport { _isMounted } from './mounting.js';\nimport { createSignalsTuple } from '@/signals-registry.js';\n\nconst REQUEST_METHOD_NAME = 'web_app_request_fullscreen';\nconst wrapComplete = createWrapComplete(COMPONENT_NAME, _isMounted, REQUEST_METHOD_NAME);\n\n/**\n * Signal indicating if the viewport is currently in fullscreen mode.\n */\nexport const isFullscreen = signalFromState('isFullscreen');\n\n/**\n * Signal containing fullscreen request or exit promise.\n */\nexport const [\n  _changeFullscreenPromise,\n  changeFullscreenPromise,\n] = createSignalsTuple<AbortablePromise<void>>();\n\n/**\n * Signal containing an error received during the last fullscreen mode request.\n */\nexport const [\n  _changeFullscreenError,\n  changeFullscreenError,\n] = createSignalsTuple<Error | undefined>();\n\nfunction createFullscreenFn(method: string, isRequest?: boolean) {\n  return wrapComplete(\n    method,\n    defineNonConcurrentFn(\n      (options?: PromiseOptions) => {\n        return request(\n          isRequest ? REQUEST_METHOD_NAME : 'web_app_exit_fullscreen',\n          [FS_CHANGED_EVENT, 'fullscreen_failed'],\n          options,\n        )\n          .then(data => {\n            if ('error' in data && data.error !== 'ALREADY_FULLSCREEN') {\n              throw new FullscreenFailedError(data.error);\n            }\n            const value = 'is_fullscreen' in data ? data.is_fullscreen : true;\n            value !== isFullscreen() && setState({ isFullscreen: value });\n          });\n      },\n      'Fullscreen mode change is already being requested',\n      {\n        promise: _changeFullscreenPromise,\n        error: _changeFullscreenError,\n      },\n    )[0],\n  );\n}\n\n/**\n * Requests fullscreen mode for the mini application.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FullscreenFailedError}\n * @example Using `isAvailable()`\n * if (requestFullscreen.isAvailable() && !isChangingFullscreen()) {\n *   await requestFullscreen();\n * }\n * @example Using `ifAvailable()`\n * if (!isChangingFullscreen()) {\n *   await requestFullscreen.ifAvailable();\n * }\n */\nexport const requestFullscreen = createFullscreenFn('requestFullscreen', true);\n\n/**\n * Exits mini application fullscreen mode.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The parent component is not mounted\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FullscreenFailedError}\n * @example Using `isAvailable()`\n * if (exitFullscreen.isAvailable() && !isChangingFullscreen()) {\n *   await exitFullscreen();\n * }\n * @example Using `ifAvailable()`\n * if (!isChangingFullscreen()) {\n *   await exitFullscreen.ifAvailable();\n * }\n */\nexport const exitFullscreen = createFullscreenFn('exitFullscreen');", "import type { RequestOptionsNoCapture } from '@/types.js';\nimport { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\n\nconst METHOD = 'web_app_request_emoji_status_access';\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn((options?: RequestOptionsNoCapture) => {\n  return request(METHOD, 'emoji_status_access_requested', options).then(d => d.status);\n}, 'Emoji status access request is already in progress');\n\n/**\n * Shows a native popup requesting permission for the bot to manage user's emoji status.\n * @param options - additional options.\n * @since Mini Apps v8.0\n * @throws {ConcurrentCallError} Emoji status access request is already in progress\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (requestEmojiStatusAccess.isAvailable()) {\n *   const status = await requestEmojiStatusAccess();\n * }\n */\nexport const requestEmojiStatusAccess = wrapSafe(\n  'requestEmojiStatusAccess',\n  fn,\n  { isSupported: METHOD },\n);\nexport const [, requestEmojiStatusAccessPromise, isRequestingEmojiStatusAccess] = tPromise;\nexport const [, requestEmojiStatusAccessError] = tError;", "import type { RequestOptionsNoCapture } from '@/types.js';\nimport { SetEmojiStatusError } from '@/errors.js';\nimport { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\n\nconst METHOD = 'web_app_set_emoji_status';\n\nexport interface SetEmojiStatusOptions extends RequestOptionsNoCapture {\n  duration?: number;\n}\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn(\n  (customEmojiId: string, options?: SetEmojiStatusOptions) => {\n    return request(METHOD, ['emoji_status_set', 'emoji_status_failed'], {\n      params: {\n        custom_emoji_id: customEmojiId,\n        duration: (options || {}).duration,\n      },\n      ...options,\n    })\n      .then(d => {\n        if (d && 'error' in d) {\n          throw new SetEmojiStatusError(d.error);\n        }\n      });\n  },\n  'Emoji status set request is currently in progress',\n);\n\n/**\n * Opens a dialog allowing the user to set the specified custom emoji as their status.\n * @returns Promise with boolean value indicating if the status was set.\n * @param options - additional options.\n * @since Mini Apps v8.0\n * @throws {ConcurrentCallError} Emoji status set request is currently in progress\n * @throws {SetEmojiStatusError} Failed to set emoji status\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (setEmojiStatus.isAvailable()) {\n *   const statusSet = await setEmojiStatus('5361800828313167608');\n * }\n */\nexport const setEmojiStatus = wrapSafe('setEmojiStatus', fn, {\n  isSupported: METHOD,\n});\nexport const [, setEmojiStatusPromise, isSettingEmojiStatus] = tPromise;\nexport const [, setEmojiStatusError] = tError;", "import { on, type EventListener, off } from '@telegram-apps/bridge';\n\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\nconst wrapOptions = { isSupported: 'web_app_add_to_home_screen' } as const;\nconst EVENT_NAME = 'home_screen_failed';\n\n/**\n * Adds the event listener that being called whenever the user declines the request to add the\n * current mini app to the device's home screen.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (onAddToHomeScreenFailed.isAvailable()) {\n *   const off = onAddToHomeScreenFailed(() => {\n *     console.log('Failed to add to home screen');\n *     off();\n *   });\n * }\n */\nexport const onAddToHomeScreenFailed = wrapSafe(\n  'onAddToHomeScreenFailed',\n  (listener: EventListener<typeof EVENT_NAME>, once?: boolean): VoidFunction => {\n    return on(EVENT_NAME, listener, once);\n  },\n  { isSupported: 'web_app_add_to_home_screen' },\n);\n\n/**\n * Removes add to home screen failed event listener.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (offAddToHomeScreenFailed.isAvailable()) {\n *   const handler = () => {\n *     console.log('Failed to add');\n *     offAddToHomeScreenFailed(handler);\n *   };\n *   onAddToHomeScreenFailed(handler);\n * }\n */\nexport const offAddToHomeScreenFailed = wrapSafe(\n  'offAddToHomeScreenFailed',\n  (listener: EventListener<typeof EVENT_NAME>): void => {\n    off(EVENT_NAME, listener);\n  },\n  wrapOptions,\n);", "import { type EventListener, off, on } from '@telegram-apps/bridge';\n\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\nconst wrapOptions = { isSupported: 'web_app_add_to_home_screen' } as const;\nconst EVENT_NAME = 'home_screen_added';\n\n/**\n * Adds the event listener that being called whenever the user adds the current mini app to the\n * device's home screen.\n *\n * Note that if the device cannot determine the installation status, a corresponding event may\n * not be received even if the icon has been added.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (onAddedToHomeScreen.isAvailable()) {\n *   const off = onAddedToHomeScreen(() => {\n *     console.log('Added');\n *     off();\n *   });\n * }\n */\nexport const onAddedToHomeScreen = wrapSafe(\n  'onAddedToHomeScreen',\n  (listener: EventListener<typeof EVENT_NAME>, once?: boolean): VoidFunction => {\n    return on(EVENT_NAME, listener, once);\n  },\n  wrapOptions,\n);\n\n/**\n * Removes the event listener that being called whenever the user adds the current mini app to the\n * device's home screen.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (offAddedToHomeScreen.isAvailable()) {\n *   const handler = () => {\n *     console.log('Added');\n *     offAddedToHomeScreen(handler);\n *   };\n *   onAddedToHomeScreen(handler);\n * }\n */\nexport const offAddedToHomeScreen = wrapSafe(\n  'offAddedToHomeScreen',\n  (listener: EventListener<typeof EVENT_NAME>): void => {\n    off(EVENT_NAME, listener);\n  },\n  wrapOptions,\n);", "import { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { postEvent } from '@/globals.js';\n\nconst METHOD_NAME = 'web_app_add_to_home_screen';\n\n/**\n * Prompts the user to add the Mini App to the home screen.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example Using `isAvailable`\n * if (addToHomeScreen.isAvailable()) {\n *   addToHomeScreen();\n * }\n * @example Using `ifAvailable`\n * addToHomeScreen.ifAvailable()\n */\nexport const addToHomeScreen = wrapSafe(\n  'addToHomeScreen',\n  () => {\n    postEvent(METHOD_NAME);\n  },\n  { isSupported: METHOD_NAME },\n);", "import type { AbortablePromise, PromiseOptions } from 'better-promises';\nimport type { HomeScreenStatus } from '@telegram-apps/bridge';\n\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\nconst METHOD_NAME = 'web_app_check_home_screen';\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn((options?: PromiseOptions): AbortablePromise<HomeScreenStatus> => {\n  return request(METHOD_NAME, 'home_screen_checked', options).then(d => d.status || 'unknown');\n}, 'Check home screen status request is currently in progress');\n\n/**\n * Sends a request to the native Telegram application to check if the current mini\n * application is added to the device's home screen.\n * @param options - additional options.\n * @since Mini Apps v8.0\n * @throws {ConcurrentCallError} Check home screen status request is currently in progress\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (checkHomeScreenStatus.isAvailable()) {\n *   const status = await checkHomeScreenStatus();\n * }\n */\nexport const checkHomeScreenStatus = wrapSafe('checkHomeScreenStatus', fn, {\n  isSupported: METHOD_NAME,\n});\nexport const [, checkHomeScreenStatusPromise, isCheckingHomeScreenStatus] = tPromise;\nexport const [, checkHomeScreenStatusError] = tError;", "import type { OpenLinkBrowser } from '@telegram-apps/bridge';\n\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { InvalidArgumentsError } from '@/errors.js';\nimport { postEvent } from '@/globals.js';\n\nexport interface OpenLinkOptions {\n  /**\n   * Attempts to use the instant view mode.\n   */\n  tryInstantView?: boolean;\n  /**\n   * A preferred browser to open the link in.\n   */\n  tryBrowser?: OpenLinkBrowser;\n}\n\nconst wrapBasic = createWrapBasic();\n\n/**\n * Opens a link.\n *\n * The Mini App will not be closed.\n *\n * Note that this method can be called only in response to the user\n * interaction with the Mini App interface (e.g. click inside the Mini App or on the main button).\n * @param url - URL to be opened.\n * @param options - additional options.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {InvalidArgumentsError} Invalid URL passed\n * @example\n * if (openLink.isAvailable()) {\n *   openLink('https://google.com', {\n *     tryInstantView: true,\n *     tryBrowser: 'chrome',\n *   });\n * }\n */\nexport const openLink = wrapBasic(\n  'openLink',\n  (url: string | URL, options?: OpenLinkOptions): void => {\n    if (typeof url === 'string') {\n      try {\n        url = new URL(url);\n      } catch (e) {\n        throw new InvalidArgumentsError(`\"${url.toString()}\" is invalid URL`, e);\n      }\n    }\n    options ||= {};\n    postEvent('web_app_open_link', {\n      url: url.toString(),\n      try_browser: options.tryBrowser,\n      try_instant_view: options.tryInstantView,\n    });\n  },\n);", "import { supports } from '@telegram-apps/bridge';\n\nimport { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { InvalidArgumentsError } from '@/errors.js';\nimport { version, postEvent } from '@/globals.js';\n\nconst OPEN_TG_LINK_METHOD = 'web_app_open_tg_link';\nconst wrapBasic = createWrapBasic();\n\n/**\n * Opens a Telegram link inside the Telegram app. The function expects passing a link in a full\n * format using the hostname \"t.me\".\n *\n * The Mini App will be closed.\n * @param url - URL to be opened.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {InvalidArgumentsError} Invalid URL passed\n * @example\n * if (openTelegramLink.isAvailable()) {\n *   openTelegramLink('https://t.me/heyqbnk');\n * }\n */\nexport const openTelegramLink = wrapBasic(\n  'openTelegramLink',\n  (url: string | URL): void => {\n    const urlString = url.toString();\n    if (!urlString.match(/^https:\\/\\/t.me\\/.+/)) {\n      throw new InvalidArgumentsError(`\"${urlString}\" is invalid URL`);\n    }\n\n    if (!supports(OPEN_TG_LINK_METHOD, version())) {\n      window.location.href = urlString;\n      return;\n    }\n\n    url = new URL(url);\n    postEvent(OPEN_TG_LINK_METHOD, { path_full: url.pathname + url.search });\n  },\n);", "import { createWrapBasic } from '@/scopes/wrappers/createWrapBasic.js';\nimport { openTelegramLink } from '@/scopes/utilities/links/openTelegramLink.js';\n\nconst wrapBasic = createWrapBasic();\n\n/**\n * Shares the specified URL with the passed to the chats, selected by user.\n * After being called, it closes the mini application.\n *\n * This method uses Telegram's Share Links.\n * @param url - URL to share.\n * @param text - text to append after the URL.\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {InvalidArgumentsError} Invalid URL passed\n * @see https://core.telegram.org/api/links#share-links\n * @see https://core.telegram.org/widgets/share#custom-buttons\n */\nexport const shareURL = wrapBasic(\n  'shareURL',\n  (url: string, text?: string): void => {\n    openTelegramLink(\n      `https://t.me/share/url?` + new URLSearchParams({ url, text: text || '' })\n        .toString()\n        // By default, URL search params encode spaces with \"+\".\n        // We are replacing them with \"%20\", because plus symbols are working incorrectly\n        // in Telegram.\n        .replace(/\\+/g, '%20'),\n    );\n  },\n);\n", "import { AbortablePromise } from 'better-promises';\n\n/**\n * Awaits for specified amount of time.\n * @param duration - duration in ms to await.\n * @param abortSignal - signal to stop function execution.\n */\nexport function sleep(duration: number, abortSignal?: AbortSignal): AbortablePromise<void> {\n  return new AbortablePromise<void>({ abortSignal, timeout: duration }).catch(() => {});\n}\n", "import { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_request_phone';\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn((options?: RequestOptionsNoCapture) => {\n  return request(METHOD_NAME, 'phone_requested', options).then(d => d.status);\n}, 'Phone access request is currently in progress');\n\n/**\n * Requests current user phone access. Method returns promise, which resolves\n * status of the request. In case, user accepted the request, Mini App bot will receive\n * the according notification.\n *\n * To obtain the retrieved information instead, utilize the `requestContact` method.\n * @param options - additional options.\n * @since Mini Apps v6.9\n * @see requestContact\n * @throws {ConcurrentCallError} Phone access request is currently in progress\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (requestPhoneAccess.isAvailable()) {\n *   const status = await requestPhoneAccess();\n * }\n */\nexport const requestPhoneAccess = wrapSafe('requestPhoneAccess', fn, {\n  isSupported: METHOD_NAME,\n});\nexport const [, requestPhoneAccessPromise, isRequestingPhoneAccess] = tPromise;\nexport const [, requestPhoneAccessError] = tError;", "import { jsonParse, transformQueryUsing } from '@telegram-apps/transformers';\nimport { AbortablePromise, type PromiseOptions } from 'better-promises';\nimport {\n  date,\n  instance,\n  looseObject,\n  number,\n  optional,\n  parse,\n  pipe,\n  string,\n  transform,\n  union,\n  ValiError,\n} from 'valibot';\nimport type { InvokeCustomMethodOptions } from '@telegram-apps/bridge';\n\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { invokeCustomMethod } from '@/globals.js';\nimport { AccessDeniedError } from '@/errors.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport { sleep } from '@/utils/sleep.js';\n\nimport { requestPhoneAccess } from './requestPhoneAccess.js';\n\n/**\n * Requested contact information.\n */\nexport interface RequestedContact {\n  contact: {\n    user_id: number;\n    phone_number: string;\n    first_name: string;\n    last_name?: string;\n    [key: string]: unknown;\n  };\n  auth_date: Date;\n  hash: string;\n  [key: string]: unknown;\n}\n\n/**\n * Requested contact complete data.\n */\nexport interface RequestedContactCompleteData {\n  /**\n   * Raw original representation of the contact data returned from the Telegram server.\n   */\n  raw: string;\n  /**\n   * Parsed representation of the contact data.\n   */\n  parsed: RequestedContact;\n}\n\nconst fnOptions = {\n  isSupported: 'web_app_request_phone',\n} as const;\n\n/**\n * Attempts to get requested contact.\n * @param options - execution options.\n * @throws {ValiError} Response has invalid structure\n */\nasync function getRequestedContact(options?: InvokeCustomMethodOptions): Promise<RequestedContactCompleteData> {\n  const raw = parse(string(), await invokeCustomMethod('getRequestedContact', {}, {\n    ...options,\n    timeout: (options || {}).timeout || 5000,\n  }));\n  return {\n    raw,\n    parsed: parse(\n      pipe(\n        // todo: Union is unnecessary here, but we use it to comply TypeScript checker.\n        union([string(), instance(URLSearchParams)]),\n        transformQueryUsing(\n          looseObject({\n            contact: pipe(\n              string(),\n              jsonParse(),\n              looseObject({\n                user_id: number(),\n                phone_number: string(),\n                first_name: string(),\n                last_name: optional(string()),\n              }),\n            ),\n            auth_date: pipe(\n              string(),\n              transform(input => new Date(Number(input) * 1000)),\n              date(),\n            ),\n            hash: string(),\n          }),\n        ),\n      ),\n      raw,\n    ),\n  };\n}\n\nconst [fn, tPromise, tError] = defineNonConcurrentFn(\n  (options?: PromiseOptions): AbortablePromise<RequestedContactCompleteData> => {\n    return new AbortablePromise<RequestedContactCompleteData>(\n      async (res, _, context) => {\n        // First of all, let's try to get the requested contact. Probably, we already requested it\n        // before.\n        try {\n          return res(await getRequestedContact(context));\n        } catch (e) {\n          if (e instanceof ValiError) {\n            throw e;\n          }\n        }\n\n        // Then, request access to the user's phone.\n        const status = await requestPhoneAccess(context);\n        if (status !== 'sent') {\n          throw new AccessDeniedError('User denied access');\n        }\n\n        // Time to wait before executing the next request.\n        let sleepTime = 50;\n\n        // We are trying to retrieve the requested contact until the deadline was reached.\n        while (!context.isAborted()) {\n          try {\n            return res(await getRequestedContact(context));\n          } catch (e) {\n            if (e instanceof ValiError) {\n              throw e;\n            }\n          }\n\n          // Sleep for some time.\n          await sleep(sleepTime);\n\n          // Increase the sleep time not to kill the backend service.\n          sleepTime += 50;\n        }\n      },\n      options,\n    );\n  },\n  'Contact is already being requested',\n);\n\n/**\n * Requests current user contact information. In contrary to requestPhoneAccess, this method\n * returns promise with contact information that rejects in case, user denied access, or request\n * failed.\n *\n * This function returns an object, containing both raw and parsed representations of the response,\n * received from the Telegram client.\n * @param options - additional options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {AccessDeniedError} User denied access\n * @throws {ValiError} Response has invalid structure\n * @example\n * if (requestContactComplete.isAvailable()) {\n *   const completeData = await requestContactComplete();\n * }\n */\nexport const requestContactComplete = wrapSafe('requestContactComplete', fn, fnOptions);\n\n/**\n * Works the same way as the `requestContactComplete` function, but returns only parsed\n * representation of the contact data.\n * @see requestContactComplete\n * @param options - additional options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {AccessDeniedError} User denied access\n * @throws {ValiError} Response has invalid structure\n * @example\n * if (requestContact.isAvailable()) {\n *   const contact = await requestContact();\n * }\n */\nexport const requestContact = wrapSafe(\n  'requestContact',\n  (options?: PromiseOptions): AbortablePromise<RequestedContact> => {\n    return requestContactComplete(options).then(r => r.parsed);\n  },\n  fnOptions,\n);\nexport const [, requestContactPromise, isRequestingContact] = tPromise;\nexport const [, requestContactError] = tError;", "import type { WriteAccessRequestedStatus } from '@telegram-apps/bridge';\nimport type { AbortablePromise } from 'better-promises';\n\nimport { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { defineNonConcurrentFn } from '@/scopes/defineNonConcurrentFn.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_request_write_access';\n\nconst [\n  fn,\n  tPromise,\n  tError,\n] = defineNonConcurrentFn(\n  (options?: RequestOptionsNoCapture): AbortablePromise<WriteAccessRequestedStatus> => {\n    return request(METHOD_NAME, 'write_access_requested', options).then(d => d.status);\n  },\n  'Write access request is currently in progress',\n);\n\n/**\n * Requests write message access to the current user.\n * @param options - additional options.\n * @since Mini Apps v6.9\n * @throws {ConcurrentCallError} Write access request is currently in progress\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (requestWriteAccess.isAvailable()) {\n *   const status = await requestWriteAccess();\n * }\n */\nexport const requestWriteAccess = wrapSafe('requestWriteAccess', fn, {\n  isSupported: METHOD_NAME,\n});\nexport const [, requestWriteAccessPromise, isRequestingWriteAccess] = tPromise;\nexport const [, requestWriteAccessError] = tError;\n", "function fallback(text: string) {\n  const textArea = document.createElement('textarea');\n  textArea.value = text;\n\n  // Avoid scrolling to bottom\n  textArea.style.top = '0';\n  textArea.style.left = '0';\n  textArea.style.position = 'fixed';\n\n  document.body.appendChild(textArea);\n  textArea.focus();\n  textArea.select();\n\n  try {\n    document.execCommand('copy');\n  } finally {\n    document.body.removeChild(textArea);\n  }\n}\n\n/**\n * Copies specified text to the clipboard.\n * @param text - text to copy.\n */\nexport async function copyTextToClipboard(text: string): Promise<void> {\n  try {\n    const { clipboard } = navigator;\n    if (clipboard) {\n      return await clipboard.writeText(text);\n    }\n  } catch {\n  }\n  fallback(text);\n}", "import { request } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { AccessDeniedError } from '@/errors.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_request_file_download';\n\n/**\n * Displays a native popup prompting the user to download a file.\n * @param url - the HTTPS URL of the file to be downloaded.\n * @param file - the suggested name for the downloaded file.\n * @param options - additional request execution options.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {AccessDeniedError} User denied the action\n * @example\n * if (downloadFile.isAvailable()) {\n *   await downloadFile('https://telegram.org/js/telegram-web-app.js', 'telegram-sdk.js');\n * }\n */\nexport const downloadFile = wrapSafe(\n  'downloadFile',\n  (url: string, fileName: string, options?: RequestOptionsNoCapture) => {\n    return request(\n      METHOD_NAME,\n      'file_download_requested',\n      { ...options, params: { url, file_name: fileName } },\n    ).then(response => {\n      if (response.status !== 'downloading') {\n        throw new AccessDeniedError('User denied the action');\n      }\n    });\n  }, { isSupported: METHOD_NAME },\n);", "import type { AbortablePromise } from 'better-promises';\nimport { date, integer, number, parse, pipe, transform } from 'valibot';\nimport type { InvokeCustomMethodOptions } from '@telegram-apps/bridge';\n\nimport { invokeCustomMethod } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\n/**\n * @returns Current server time.\n * @param options - execution options.\n * @since Mini Apps v6.9\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (getCurrentTime.isAvailable()) {\n *   const time = await getCurrentTime();\n * }\n */\nexport const getCurrentTime = wrapSafe(\n  'getCurrentTime',\n  (options?: InvokeCustomMethodOptions): AbortablePromise<Date> => {\n    return invokeCustomMethod('getCurrentTime', {}, options).then(value => {\n      return parse(\n        pipe(number(), integer(), transform(v => new Date(v * 1000)), date()),\n        value,\n      );\n    });\n  },\n  { isSupported: 'web_app_invoke_custom_method' },\n);", "import { captureSameReq } from '@telegram-apps/bridge';\nimport type { AbortablePromise } from 'better-promises';\n\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { createRequestId, request } from '@/globals.js';\nimport type { RequestOptionsNoCapture } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_read_text_from_clipboard';\n\n/**\n * Reads a text from the clipboard and returns a `string` or `null`. `null` is returned\n * in cases:\n * - A value in the clipboard is not a text.\n * - Access to the clipboard is not granted.\n * @since Mini Apps v6.4\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The function is not supported\n * @example\n * if (readTextFromClipboard.isAvailable()) {\n *   const value = await readTextFromClipboard();\n * }\n */\nexport const readTextFromClipboard = wrapSafe(\n  'readTextFromClipboard',\n  (options?: RequestOptionsNoCapture): AbortablePromise<string | null> => {\n    const reqId = createRequestId();\n\n    return request(METHOD_NAME, 'clipboard_text_received', {\n      ...options,\n      params: { req_id: reqId },\n      capture: captureSameReq(reqId),\n    }).then(({ data = null }) => data);\n  },\n  { isSupported: METHOD_NAME },\n);", "export interface AndroidDeviceData {\n  appVersion?: string;\n  manufacturer?: string;\n  model?: string;\n  androidVersion?: string;\n  sdkVersion?: number;\n  performanceClass?: 'LOW' | 'AVERAGE' | 'HIGH' | string;\n}\n\n/**\n * Retrieves Android device data from the specified User Agent.\n * @see https://core.telegram.org/bots/webapps#additional-data-in-user-agent\n * @param userAgent - user agent.\n */\nexport function retrieveAndroidDeviceDataFrom(userAgent: string): AndroidDeviceData {\n  const result: AndroidDeviceData = {};\n  const match = userAgent.match(/Telegram-Android(?:\\/([^ ]+))?(?: (\\([^)]+\\))?|$)/);\n  if (match) {\n    const [, appVersion, systemInfo] = match;\n    appVersion && (result.appVersion = appVersion);\n    systemInfo && systemInfo\n      .slice(1, systemInfo.length - 1)\n      .split(';')\n      .forEach(item => {\n        const [key, value] = item.trim().split(' ');\n        if (key === 'Android') {\n          result.androidVersion = value;\n        } else if (key === 'SDK') {\n          const parsed = parseInt(value, 10);\n          parsed && (result.sdkVersion = parsed);\n        } else if (value) {\n          result.manufacturer = key;\n          result.model = value;\n        } else {\n          result.performanceClass = key;\n        }\n      });\n  }\n  return result;\n}", "import {\n  type AndroidDeviceData,\n  retrieveAndroidDeviceDataFrom,\n} from './retrieveAndroidDeviceDataFrom.js';\n\n/**\n * Retrieves Android device data from the navigator.userAgent.\n * @see https://core.telegram.org/bots/webapps#additional-data-in-user-agent\n */\nexport function retrieveAndroidDeviceData(): AndroidDeviceData {\n  return retrieveAndroidDeviceDataFrom(navigator.userAgent);\n}", "import { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { InvalidArgumentsError } from '@/errors.js';\nimport { postEvent } from '@/globals.js';\n\nconst METHOD_NAME = 'web_app_data_send';\n\n/**\n * Sends data to the bot.\n *\n * When this method called, a service message sent to the bot containing the data of the length\n * up to 4096 bytes, and the Mini App closed.\n *\n * See the field `web_app_data` in the class [Message](https://core.telegram.org/bots/api#message).\n *\n * This method is only available for Mini Apps launched via a Keyboard button.\n * @param data - data to send to bot.\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {InvalidArgumentsError} Maximum size of data to send is 4096 bytes\n * @throws {InvalidArgumentsError} Attempted to send empty data\n * @example\n * if (sendData.isAvailable()) {\n *   sendData('Here comes my data');\n * }\n */\nexport const sendData = wrapSafe(\n  'sendData',\n  (data: string): void => {\n    const { size } = new Blob([data]);\n    if (!size || size > 4096) {\n      throw new InvalidArgumentsError(size\n        ? 'Maximum size of data to send is 4096 bytes'\n        : 'Attempted to send empty data');\n    }\n    postEvent(METHOD_NAME, { data });\n  },\n  { isSupported: METHOD_NAME },\n);\n", "import type { AbortablePromise } from 'better-promises';\n\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { request } from '@/globals.js';\nimport { ShareMessageError } from '@/errors.js';\nimport type { AsyncOptions } from '@/types.js';\n\nconst METHOD_NAME = 'web_app_send_prepared_message';\n\n/**\n * Opens a dialog allowing the user to share a message provided by the bot.\n * @since Mini Apps v8.0\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {ShareMessageError} Message sharing failed.\n * @example\n * if (shareMessage.isAvailable()) {\n *   await shareMessage('bbhjSYgvck23');\n * }\n */\nexport const shareMessage = wrapSafe(\n  'shareMessage',\n  (id: string, options?: AsyncOptions): AbortablePromise<void> => {\n    return request(METHOD_NAME, ['prepared_message_failed', 'prepared_message_sent'], {\n      ...options,\n      params: { id },\n    }).then(data => {\n      if (data && 'error' in data) {\n        throw new ShareMessageError(data.error);\n      }\n    });\n  },\n  { isSupported: METHOD_NAME },\n);", "import { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\nimport { postEvent } from '@/globals.js';\n\nconst SHARE_STORY_METHOD = 'web_app_share_to_story';\n\nexport interface ShareStoryOptions {\n  /**\n   * The caption to be added to the media.\n   * 0-200 characters for regular users and 0-2048 characters for premium subscribers.\n   * @see https://telegram.org/faq_premium#telegram-premium\n   */\n  text?: string;\n  /**\n   * An object that describes a widget link to be included in the story.\n   * Note that only premium subscribers can post stories with links.\n   * @see https://telegram.org/faq_premium#telegram-premium\n   */\n  widgetLink?: {\n    /**\n     * The URL to be included in the story.\n     */\n    url: string;\n    /**\n     * The name to be displayed for the widget link, 0-48 characters.\n     */\n    name?: string;\n  };\n}\n\n/**\n * Opens the native story editor.\n * @since Mini Apps v7.8\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @example\n * if (shareStory.isAvailable()) {\n *   shareStory('https://example.com/background.png', {\n *     text: 'Look at this cool group!',\n *     widgetLink: {\n *       url: 'https://t.me/heyqbnk',\n *       name: 'Vlad\\'s community',\n *     },\n *   });\n * }\n */\nexport const shareStory = wrapSafe(\n  'shareStory',\n  (mediaUrl: string, options?: ShareStoryOptions) => {\n    options ||= {};\n    postEvent(SHARE_STORY_METHOD, {\n      text: options.text,\n      media_url: mediaUrl,\n      widget_link: options.widgetLink,\n    });\n  },\n  { isSupported: SHARE_STORY_METHOD },\n);", "import type { SwitchInlineQueryChatType } from '@telegram-apps/bridge';\n\nimport { $launchParams, postEvent } from '@/globals.js';\nimport { wrapSafe } from '@/scopes/wrappers/wrapSafe.js';\n\nconst SWITCH_INLINE_QUERY_METHOD = 'web_app_switch_inline_query';\n\n/**\n * Inserts the bot's username and the specified inline query in the current chat's input field.\n * Query may be empty, in which case only the bot's username will be inserted. The client prompts\n * the user to choose a specific chat, then opens that chat and inserts the bot's username and\n * the specified inline query in the input field.\n * @param query - text which should be inserted in the input after the current bot name. Max\n * length is 256 symbols.\n * @param chatTypes - List of chat types which could be chosen to send the message. Could be an\n * empty list.\n * @since Mini Apps v6.7\n * @throws {FunctionNotAvailableError} The function is not supported\n * @throws {FunctionNotAvailableError} The environment is unknown\n * @throws {FunctionNotAvailableError} The SDK is not initialized\n * @throws {FunctionNotAvailableError} The application must be launched in the inline mode\n * @example\n * if (switchInlineQuery.isAvailable()) {\n *   switchInlineQuery('my query goes here', ['users']);\n * }\n */\nexport const switchInlineQuery = wrapSafe(\n  'switchInlineQuery',\n  (query: string, chatTypes?: SwitchInlineQueryChatType[]) => {\n    postEvent(SWITCH_INLINE_QUERY_METHOD, {\n      query: query,\n      chat_types: chatTypes || [],\n    });\n  },\n  {\n    isSupported() {\n      return $launchParams().tgWebAppBotInline\n        ? undefined\n        : 'The application must be launched in the inline mode';\n    }\n  }\n);\n", "export type SafeCallResult<Data, Error> = [ok: true, data: Data] | [ok: false, error: Error];\n\n/**\n * Calls the function and prevents it from throwing an error.\n * Instead, it handles the error and returns it as a value.\n * The returned tuple reminds tuples in GoLang.\n *\n * You can use this function to safely execute any other function.\n * @param fn - function to call.\n * @returns A tuple with either true on the first place and date on the second if the call\n * is successful, or false on the first place and error on the second if something went wrong.\n */\nexport function safeCall<T, E = unknown>(fn: () => T): SafeCallResult<T, E> {\n  try {\n    return [true, fn()];\n  } catch (error) {\n    return [false, error as E];\n  }\n}\n", "import { on } from '@telegram-apps/bridge';\nimport { createCbCollector } from '@telegram-apps/toolkit';\n\nimport { postEvent, configure, type ConfigureOptions } from '@/globals.js';\nimport { logger } from '@/logger.js';\n\nexport interface InitOptions extends ConfigureOptions {\n  /**\n   * True if SDK should accept styles sent from the Telegram application.\n   * @default true\n   */\n  acceptCustomStyles?: boolean;\n}\n\n/**\n * Initializes the SDK allowing it to properly handle events, sent from the native Telegram\n * application.\n * @param options - function options.\n * @returns A function, to perform a cleanup.\n */\nexport function init(options?: InitOptions): VoidFunction {\n  // Configure the package global dependencies.\n  configure(options);\n\n  const [addCleanup, cleanup] = createCbCollector(\n    on('reload_iframe', () => {\n      logger().log('Received a request to reload the page');\n      postEvent('iframe_will_reload');\n      window.location.reload();\n    }),\n  );\n\n  const { acceptCustomStyles = true } = options || {};\n  if (acceptCustomStyles) {\n    const style = document.createElement('style');\n    style.id = 'telegram-custom-styles';\n    document.head.appendChild(style);\n\n    addCleanup(\n      on('set_custom_style', html => {\n        // It is safe to use innerHTML here as long as style tag has a special behavior related\n        // to the specified content.\n        // In case any script will be passed here, it will not be executed, so XSS is not possible.\n        style.innerHTML = html;\n      }),\n      () => {\n        document.head.removeChild(style);\n      },\n    );\n  }\n\n  // Notify Telegram that the application is ready.\n  //\n  // This will result in sending style tag html content from the Telegram web application.\n  // We should call this method also to start receiving \"reload_iframe\" events from the Telegram\n  // application.\n  //\n  // It really has no effect outside non-Telegram web environment.\n  postEvent('iframe_ready', { reload_supported: true });\n\n  logger().log('The package was initialized');\n\n  return cleanup;\n}"],
  "mappings": "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",
  "names": ["f", "u", "r", "c", "a", "p", "n", "i", "o", "CancelledError", "isCancelledError", "errorClass", "TimeoutError", "isTimeoutError", "timeout", "cause", "RESOLVED_SYMBOL", "isPromiseResolveResult", "value", "withResolved", "reassignProps", "childPromise", "parentPromise", "AbortablePromise", "executorOrOptions", "maybeOptions", "reject", "abort", "res", "rej", "executor", "options", "cleanupFns", "withCleanup", "fn", "args", "result", "controller", "signal", "reason", "abortReason", "onAborted", "listener", "wrapped", "cleanup", "resolve", "abortSignal", "rejectOnAbort", "timeoutId", "isAborted", "isResolved", "resolved", "e", "__publicField", "context", "_", "onRejected", "onFinally", "onFulfilled", "assignResolve", "ManualPromise", "camelToKebab", "value", "match", "snakeToCamel", "value", "m", "snakeToCamelObjKeys", "acc", "k", "v", "deepSnakeToCamelObjKeys", "camelCased", "key", "snakeToKebab", "_", "letter", "formatKey", "setStorageValue", "getStorageValue", "createCbCollector", "cbs", "callbacks", "cb", "createLogger", "scope", "options", "textColor", "bgColor", "optionsShouldLog", "shouldLogValue", "shouldLog", "print", "level", "force", "args", "commonCss", "timeBgColor", "timeTextColor", "prefix", "forceMethod", "store", "getGlobalConfig", "config2", "store2", "getGlobalMessage", "lang", "store3", "getSchemaMessage", "store4", "getSpecificMessage", "reference", "_a", "_stringify", "input", "_b", "type", "_addIssue", "context", "label", "dataset", "other", "expected", "received", "issue", "isSchema", "message", "_getStandardProps", "value2", "_isValidObjectKey", "object2", "key", "_joinExpects", "values", "separator", "list", "ValiError", "issues", "check", "requirement", "integer", "transform", "operation", "getDefault", "schema", "is", "boolean", "date", "instance", "class_", "lazy", "getter", "looseObject", "entries", "valueSchema", "valueDataset", "pathItem", "number", "optional", "wrapped", "default_", "record", "entryKey", "entryValue", "keyDataset", "string", "_subIssues", "datasets", "union", "options", "option", "validDataset", "typedDatasets", "untypedDatasets", "optionDataset", "unknown", "parse", "pipe", "pipe2", "item", "$", "o", "e", "h", "r", "f", "conditionalSnakeKeys", "camelCase", "deepSnakeToCamelObjKeys", "createCamelCaseGen", "createCamelCaseSchemaParserGen", "jsonParse", "createJsonCamelCaseGen", "cc", "transformQueryUsing", "result", "value", "accValue", "createQueryCamelCaseGen", "lazyUser", "initDataUserJson", "InitDataChatSchema", "InitDataUserSchema", "InitDataQuerySchema", "initDataChatJson", "initDataQuery", "isRGB", "isRGBShort", "toRGB", "clean", "color", "i", "match", "acc", "component", "themeParams", "OptionalBoolean", "v", "themeParamsJson", "LaunchParamsSchema", "launchParamsQuery", "parseInitDataQuery", "parseLaunchParamsQuery", "MiniAppsMessageSchema", "serializeToQuery", "onObject", "_", "serializeInitDataQuery", "serializeLaunchParamsQuery", "k", "isLaunchParamsQuery", "all", "Map", "on", "type", "handler", "handlers", "get", "push", "set", "off", "splice", "indexOf", "emit", "evt", "slice", "map", "callbacks", "runInBatchMode", "signal", "fn", "batch", "cb", "initialValue", "options", "equals", "listeners", "value", "set", "v", "prev", "s", "once", "unsub", "formatSubOptions", "onceOrOptions", "idx", "listener", "lOptions", "collectSignal", "l", "collectContexts", "computed", "deps", "$signal", "compute", "update", "collectedSignals", "result", "args", "isErrorOfKind", "ErrorClass", "type", "value", "errorClass", "name", "toSuper", "CustomError", "args", "params", "__publicField", "errorClassWithData", "toData", "encodeBase64Url", "value", "_", "p1", "decodeBase64Url", "c", "hasWebviewProxy", "is", "looseObject", "fn", "isIframe", "createEmitter", "onFirst", "onEmpty", "eventToHandlersMap", "emitter", "mitt", "off", "event", "handler", "once", "handlersMap", "handlers", "index", "w", "item", "prevSize", "cleanup", "internalHandler", "args", "emitEvent", "eventType", "eventData", "debug", "listener", "logger", "setDebug", "on", "signal", "createLogger", "defineWithAccessors", "obj", "prop", "get", "set", "defineEnhanceableProperty", "v", "objKey", "objValue", "defineDefaultProperty", "defineFnComposer", "initialFn", "objProp", "pool", "callPool", "callPoolWrapped", "poolSize", "transformers", "string", "nullish", "optional", "unknown", "number", "boolean", "themeParams", "message", "parse", "pipe", "jsonParse", "MiniAppsMessageSchema", "schema", "data", "cause", "emit", "offAll", "wnd", "path", "cursor", "receiveEventOwner", "receiveEvent", "MethodUnsupportedError", "isMethodUnsupportedError", "errorClass", "method", "version", "MethodParameterUnsupportedError", "isMethodMethodParameterUnsupportedError", "param", "LaunchParamsRetrieveError", "isLaunchParamsRetrieveError", "errorClassWithData", "errors", "source", "error", "InvalidLaunchParamsError", "isInvalidLaunchParamsError", "launchParams", "UnknownEnvError", "isUnknownEnvError", "InvokeCustomMethodError", "isInvokeCustomMethodError", "postMessageImplementation", "e", "postMessage", "targetOrigin", "postEvent", "eventType", "eventData", "logger", "w", "message", "isIframe", "postMessage", "targetOrigin", "hasWebviewProxy", "is", "looseObject", "fn", "UnknownEnvError", "request", "method", "eventOrEvents", "options", "capture", "addCleanup", "cleanup", "createCbCollector", "AbortablePromise", "resolve", "event", "on", "payload", "SESSION_STORAGE_KEY", "fromURL", "urlString", "retrieveRawLaunchParams", "errors", "retrieve", "source", "navigationEntry", "getStorageValue", "v", "isLaunchParamsQuery", "setStorageValue", "parseLaunchParamsQuery", "e", "LaunchParamsRetrieveError", "retrieveLaunchParams", "camelCase", "launchParams", "deepSnakeToCamelObjKeys", "isTMA", "type", "context", "mockTelegramEnv", "onEvent", "resetPostMessage", "launchParamsQuery", "serializeLaunchParamsQuery", "InvalidLaunchParamsError", "MiniAppsMessageJson", "pipe", "string", "jsonParse", "MiniAppsMessageSchema", "postMessageImplementation", "original", "args", "next", "data", "parse", "proxy", "postEventDefaulted", "retrieveRawInitData", "captureSameReq", "reqId", "req_id", "parts", "a", "compareVersions", "b", "aParts", "bParts", "len", "i", "aVal", "bVal", "versionLessOrEqual", "supports", "paramOrVersion", "inVersion", "createPostEvent", "version", "onUnsupportedOrMode", "onUnsupported", "error", "MethodParameterUnsupportedError", "MethodUnsupportedError", "params", "any", "createStartParam", "value", "b64", "encodeBase64Url", "decodeStartParam", "arg2", "decoded", "decodeBase64Url", "isSafeToCreateStartParam", "invokeCustomMethod", "requestId", "result", "InvokeCustomMethodError", "applyPolyfills", "obj", "prop", "getFirstNavigationEntry", "isPageReload", "entry", "createSignal", "initialValue", "options", "signal", "createComputed", "fn", "computed", "createSignalsTuple", "s", "debug", "setDebug", "value", "setBridgeDebug", "logger", "createLogger", "$lastRequestId", "$postEvent", "_postEvent", "_$launchParams", "$launchParams", "version", "configure", "postEvent", "lp", "retrieveLaunchParams", "createPostEvent", "createRequestId", "invokeCustomMethod", "method", "params", "_invokeCustomMethod", "request", "eventOrEvents", "_request", "createIsSupported", "supports", "proxyMessage", "message", "CSSVarsBoundError", "isCSSVarsBoundError", "errorClass", "NotAvailableError", "isNotAvailableError", "InvalidEnvError", "isInvalidEnvError", "FunctionUnavailableError", "isFunctionNotAvailableError", "InvalidArgumentsError", "isInvalidArguments", "cause", "ConcurrentCallError", "isConcurrentCallError", "SetEmojiStatusError", "isSetEmojiStatusError", "error", "AccessDeniedError", "isAccessDeniedError", "FullscreenFailedError", "isFullscreenFailedError", "ShareMessageError", "isShareMessageError", "UnknownThemeParamsKeyError", "isUnknownThemeParamsKeyError", "key", "isSSR", "wrapSafe", "optionsIsSupported", "isMounted", "isMounting", "component", "optionSupports", "functionId", "isSupported", "supportsOption", "option", "tuple", "supportError", "getError", "item", "isSupportedItems", "errors", "supportsOptionError", "args", "k", "supportsMap", "$isSupported", "$isInitialized", "$isMounted", "$isAvailable", "isTMA", "errMessagePrefix", "supportErr", "supportsOptionErr", "createWrapSafe", "overrideIsSupported", "createWrapComplete", "createWrapSupported", "SETUP_METHOD_NAME", "CLICK_EVENT_NAME", "COMPONENT_NAME", "_isVisible", "isVisible", "_isMounted", "wrapComplete", "wrapSupported", "hide", "setVisibility", "mount", "isPageReload", "getStorageValue", "setStorageValue", "onClick", "on", "offClick", "off", "show", "unmount", "defineNonConcurrentFn", "errorMessage", "optionsPromise", "optionsError", "_promise", "promise", "_error", "err", "AbortablePromise", "batch", "e", "defineMountFn", "onMounted", "rest", "data", "_state", "state", "isAvailable", "METHOD_NAME", "requestBiometry", "ignoreCanceled", "isCancelledError", "signalCancel", "p", "REQUEST_AUTH_METHOD", "INFO_RECEIVED_EVENT", "onBiometryInfoReceived", "setState", "eventToState", "throwNotAvailable", "event", "available", "tokenSaved", "deviceId", "accessRequested", "type", "accessGranted", "mountFn", "tMountPromise", "tMountError", "tIsMounted", "abortSignal", "mountPromise", "mountError", "authFn", "tAuthPromise", "tAuthError", "context", "token", "authenticate", "authPromise", "isAuthenticating", "authError", "openSettings", "requestAccessFn", "tRequestAccessPromise", "tRequestAccessError", "requestAccess", "requestAccessPromise", "isRequestingAccess", "requestAccessError", "updateToken", "r", "createWrapMounted", "createWrapBasic", "_isConfirmationEnabled", "isConfirmationEnabled", "wrapMounted", "wrapBasic", "disableConfirmation", "setClosingConfirmation", "enableConfirmation", "INVOKE_METHOD_NAME", "deleteItem", "keyOrKeys", "keys", "_getItem", "response", "acc", "parse", "record", "string", "getItem", "getKeys", "array", "setItem", "clear", "HAPTIC_METHOD_NAME", "impactOccurred", "style", "notificationOccurred", "selectionChanged", "fromState", "authDate", "canSendAfter", "canSendAfterDate", "authDateValue", "canSendAfterValue", "chat", "chatType", "chatInstance", "hash", "queryId", "_raw", "raw", "receiver", "restore", "retrieveRawInitData", "startParam", "user", "_open", "urlOrSlug", "optionsOrType", "slug", "hostname", "pathname", "match", "d", "tOpenPromise", "tOpenError", "open", "openPromise", "isOpened", "openError", "CHECK_LOCATION_METHOD", "OPEN_SETTINGS_METHOD", "isAccessGranted", "isAccessRequested", "reqLocationFn", "tReqLocationPromise", "tReqLocationError", "requestLocation", "requestLocationPromise", "isRequestingLocation", "requestLocationError", "removeUndefined", "result", "v", "isColorDark", "color", "rgb", "toRGB", "modifier", "idx", "dec", "_isCssVarsBound", "isCssVarsBound", "accentTextColor", "backgroundColor", "buttonColor", "buttonTextColor", "bottomBarBgColor", "destructiveTextColor", "headerBackgroundColor", "hintColor", "isDark", "linkColor", "secondaryBackgroundColor", "sectionBackgroundColor", "sectionHeaderTextColor", "sectionSeparatorColor", "subtitleTextColor", "textColor", "internalState", "hasShineEffect", "isEnabled", "isLoaderVisible", "text", "prev", "setParams", "updates", "setCssVar", "name", "deleteCssVar", "THEME_CHANGED_EVENT", "onThemeChanged", "_options", "bindCssVars", "getCSSVarName", "prop", "snakeToKebab", "forEachEntry", "actualize", "mountSync", "tp", "rgbComputedBasedOn", "rgbBasedOn", "isRGB", "themeParamsState", "_backgroundColor", "backgroundColorRGB", "_bottomBarColor", "bottomBarColor", "bottomBarColorRGB", "themeSecondaryBgColor", "_headerColor", "headerColor", "headerColorRGB", "_isActive", "isActive", "SET_BG_COLOR_METHOD", "SET_BOTTOM_BAR_COLOR_METHOD", "SET_HEADER_COLOR_METHOD", "VISIBILITY_CHANGED_EVENT", "isSupportedSchema", "onVisibilityChanged", "saveState", "onThemeParamsChanged", "themeParams", "mountThemeParams", "setBackgroundColor", "setBottomBarColor", "setHeaderColor", "addCleanup", "cleanup", "createCbCollector", "bind", "cssVar", "update", "camelToKebab", "close", "returnBack", "mountThemeParamsSync", "ready", "prepareParams", "title", "buttons", "b", "id", "OPEN_METHOD", "tPromise", "tShowError", "buttonId", "showPromise", "isShown", "showError", "CLOSE_METHOD", "CLOSED_EVENT", "TEXT_RECEIVED_EVENT", "onCaptured", "capture", "ManualPromise", "openFn", "position", "_isVerticalEnabled", "isVerticalEnabled", "disableVertical", "setVerticalEnabled", "enableVertical", "force", "FS_CHANGED_EVENT", "SA_CHANGED_EVENT", "CSA_CHANGED_EVENT", "VIEWPORT_CHANGED_EVENT", "initialInsets", "nonNegative", "signalFromState", "height", "stableHeight", "width", "isExpanded", "isStable", "getStateFromStorage", "fromCsaState", "contentSafeAreaInsets", "contentSafeAreaInsetBottom", "contentSafeAreaInsetLeft", "contentSafeAreaInsetRight", "contentSafeAreaInsetTop", "fromSaState", "safeAreaInsets", "safeAreaInsetBottom", "safeAreaInsetLeft", "safeAreaInsetRight", "safeAreaInsetTop", "REQUEST_SA_METHOD_NAME", "requestContentSafeAreaInsets", "requestViewport", "requestSafeAreaInsets", "onViewportChanged", "onFullscreenChanged", "onSafeAreaChanged", "onContentSafeAreaChanged", "insets", "shared", "w", "settings", "setting", "expand", "REQUEST_METHOD_NAME", "isFullscreen", "_changeFullscreenPromise", "changeFullscreenPromise", "_changeFullscreenError", "changeFullscreenError", "createFullscreenFn", "isRequest", "requestFullscreen", "exitFullscreen", "METHOD", "tError", "requestEmojiStatusAccess", "requestEmojiStatusAccessPromise", "isRequestingEmojiStatusAccess", "requestEmojiStatusAccessError", "customEmojiId", "setEmojiStatus", "setEmojiStatusPromise", "isSettingEmojiStatus", "setEmojiStatusError", "wrapOptions", "EVENT_NAME", "onAddToHomeScreenFailed", "listener", "once", "offAddToHomeScreenFailed", "onAddedToHomeScreen", "offAddedToHomeScreen", "addToHomeScreen", "checkHomeScreenStatus", "checkHomeScreenStatusPromise", "isCheckingHomeScreenStatus", "checkHomeScreenStatusError", "openLink", "url", "OPEN_TG_LINK_METHOD", "openTelegramLink", "urlString", "shareURL", "sleep", "duration", "requestPhoneAccess", "requestPhoneAccessPromise", "isRequestingPhoneAccess", "requestPhoneAccessError", "fnOptions", "getRequestedContact", "pipe", "union", "instance", "transformQueryUsing", "looseObject", "jsonParse", "number", "optional", "transform", "input", "date", "res", "_", "ValiError", "sleepTime", "requestContactComplete", "requestContact", "requestContactPromise", "isRequestingContact", "requestContactError", "requestWriteAccess", "requestWriteAccessPromise", "isRequestingWriteAccess", "requestWriteAccessError", "fallback", "textArea", "copyTextToClipboard", "clipboard", "downloadFile", "fileName", "getCurrentTime", "integer", "readTextFromClipboard", "reqId", "captureSameReq", "retrieveAndroidDeviceDataFrom", "userAgent", "appVersion", "systemInfo", "parsed", "retrieveAndroidDeviceData", "sendData", "size", "shareMessage", "SHARE_STORY_METHOD", "shareStory", "mediaUrl", "SWITCH_INLINE_QUERY_METHOD", "switchInlineQuery", "query", "chatTypes", "safeCall", "init", "acceptCustomStyles", "html"]
}
